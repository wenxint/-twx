# 国际化(i18n)

> 国际化(Internationalization，简称i18n)是现代Web应用必备的功能，能够让应用支持多种语言和地区，提升全球用户体验。本文详细介绍国际化的实现方案和最佳实践。

## 基本概念

### 核心术语

- **i18n**: Internationalization（国际化）的缩写，指设计和开发能够适应不同语言和地区的应用
- **l10n**: Localization（本地化）的缩写，指将应用适配到特定语言和地区的过程
- **Locale**: 地区设置，通常格式为`语言-地区`，如`zh-CN`、`en-US`
- **翻译键(Translation Key)**: 用于标识需要翻译内容的唯一标识符
- **命名空间(Namespace)**: 用于组织翻译内容的逻辑分组

### 国际化的挑战

```javascript
/**
 * @description 国际化常见挑战示例
 */
const i18nChallenges = {
  // 1. 文本长度变化
  textLength: {
    'en': 'Save',        // 4个字符
    'zh-CN': '保存',      // 2个字符
    'de': 'Speichern',   // 9个字符
    'ar': 'حفظ'          // 3个字符（从右到左）
  },

  // 2. 日期时间格式
  dateFormat: {
    'en-US': 'MM/DD/YYYY',
    'zh-CN': 'YYYY-MM-DD',
    'de-DE': 'DD.MM.YYYY'
  },

  // 3. 数字格式
  numberFormat: {
    'en-US': '1,234.56',
    'zh-CN': '1,234.56',
    'de-DE': '1.234,56',
    'fr-FR': '1 234,56'
  },

  // 4. 货币格式
  currencyFormat: {
    'en-US': '$1,234.56',
    'zh-CN': '¥1,234.56',
    'de-DE': '1.234,56 €',
    'ja-JP': '¥1,234'
  }
};
```

## 核心实现方案

### 1. 基础国际化引擎

```javascript
/**
 * @description 国际化管理器
 * @class I18nManager
 */
class I18nManager {
  constructor(options = {}) {
    this.locale = options.locale || 'en';
    this.fallbackLocale = options.fallbackLocale || 'en';
    this.messages = new Map();
    this.pluralRules = new Map();
    this.dateFormats = new Map();
    this.numberFormats = new Map();
    this.storageKey = 'user-locale';

    // 加载默认配置
    this.init();
  }

  /**
   * @description 初始化国际化
   */
  async init() {
    // 1. 从存储中恢复用户语言偏好
    const savedLocale = this.getSavedLocale();

    // 2. 检测浏览器语言
    const browserLocale = this.detectBrowserLocale();

    // 3. 确定最终locale
    this.locale = savedLocale || browserLocale || this.fallbackLocale;

    // 4. 加载语言包
    await this.loadLocaleMessages(this.locale);

    // 5. 设置格式化器
    this.setupFormatters();
  }

  /**
   * @description 检测浏览器语言
   * @returns {string} 浏览器语言
   */
  detectBrowserLocale() {
    const browserLang = navigator.language || navigator.userLanguage;

    // 标准化locale格式
    return this.normalizeLocale(browserLang);
  }

  /**
   * @description 标准化locale格式
   * @param {string} locale - 原始locale
   * @returns {string} 标准化后的locale
   */
  normalizeLocale(locale) {
    if (!locale) return this.fallbackLocale;

    // 将 en_US 转换为 en-US
    return locale.replace('_', '-');
  }

  /**
   * @description 加载语言包
   * @param {string} locale - 目标locale
   */
  async loadLocaleMessages(locale) {
    try {
      // 尝试加载完整locale（如 zh-CN）
      const messages = await this.fetchMessages(locale);
      this.messages.set(locale, messages);

      // 如果是带地区的locale，也加载基础语言（如 zh）
      const baseLocale = locale.split('-')[0];
      if (baseLocale !== locale && !this.messages.has(baseLocale)) {
        try {
          const baseMessages = await this.fetchMessages(baseLocale);
          this.messages.set(baseLocale, baseMessages);
        } catch (error) {
          console.warn(`无法加载基础语言包 ${baseLocale}:`, error);
        }
      }
    } catch (error) {
      console.error(`加载语言包失败 ${locale}:`, error);

      // 如果加载失败，尝试加载fallback
      if (locale !== this.fallbackLocale) {
        await this.loadLocaleMessages(this.fallbackLocale);
      }
    }
  }

  /**
   * @description 获取翻译消息
   * @param {string} locale - 目标locale
   * @returns {Object} 翻译消息对象
   */
  async fetchMessages(locale) {
    // 支持多种加载方式

    // 1. 从远程API加载
    if (this.options?.apiEndpoint) {
      const response = await fetch(`${this.options.apiEndpoint}/${locale}.json`);
      return await response.json();
    }

    // 2. 动态导入
    const module = await import(`../locales/${locale}.js`);
    return module.default || module;
  }

  /**
   * @description 翻译文本
   * @param {string} key - 翻译键
   * @param {Object} params - 插值参数
   * @param {string} locale - 指定locale（可选）
   * @returns {string} 翻译后的文本
   */
  t(key, params = {}, locale = this.locale) {
    let message = this.getMessage(key, locale);

    if (!message) {
      // 尝试fallback locale
      message = this.getMessage(key, this.fallbackLocale);

      if (!message) {
        console.warn(`翻译缺失: ${key}`);
        return key;
      }
    }

    // 处理插值
    return this.interpolate(message, params);
  }

  /**
   * @description 获取消息
   * @param {string} key - 翻译键
   * @param {string} locale - 目标locale
   * @returns {string} 消息内容
   */
  getMessage(key, locale) {
    const messages = this.messages.get(locale);
    if (!messages) return null;

    // 支持嵌套键，如 'user.profile.name'
    return this.getNestedValue(messages, key);
  }

  /**
   * @description 获取嵌套对象的值
   * @param {Object} obj - 对象
   * @param {string} path - 路径
   * @returns {any} 值
   */
  getNestedValue(obj, path) {
    return path.split('.').reduce((current, key) => {
      return current && current[key] !== undefined ? current[key] : null;
    }, obj);
  }

  /**
   * @description 插值处理
   * @param {string} message - 消息模板
   * @param {Object} params - 参数对象
   * @returns {string} 插值后的消息
   */
  interpolate(message, params) {
    return message.replace(/\{\{(\w+)\}\}/g, (match, key) => {
      return params[key] !== undefined ? params[key] : match;
    });
  }

  /**
   * @description 复数处理
   * @param {string} key - 翻译键
   * @param {number} count - 数量
   * @param {Object} params - 其他参数
   * @returns {string} 翻译后的文本
   */
  tc(key, count, params = {}) {
    const pluralKey = this.getPluralKey(key, count);
    return this.t(pluralKey, { ...params, count });
  }

  /**
   * @description 获取复数形式的键
   * @param {string} key - 基础键
   * @param {number} count - 数量
   * @returns {string} 复数键
   */
  getPluralKey(key, count) {
    const rule = this.getPluralRule(this.locale);
    const suffix = rule(count);

    return `${key}${suffix}`;
  }

  /**
   * @description 获取复数规则
   * @param {string} locale - 目标locale
   * @returns {Function} 复数规则函数
   */
  getPluralRule(locale) {
    const baseLocale = locale.split('-')[0];

    // 简化的复数规则
    const rules = {
      'zh': () => '', // 中文无复数
      'ja': () => '', // 日文无复数
      'en': (n) => n === 1 ? '' : '_plural',
      'ru': (n) => {
        if (n % 10 === 1 && n % 100 !== 11) return '';
        if (n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20)) return '_few';
        return '_many';
      }
    };

    return rules[baseLocale] || rules['en'];
  }

  /**
   * @description 切换语言
   * @param {string} locale - 目标locale
   */
  async changeLocale(locale) {
    if (locale === this.locale) return;

    // 加载新语言包
    await this.loadLocaleMessages(locale);

    const oldLocale = this.locale;
    this.locale = locale;

    // 保存用户偏好
    this.saveLocale(locale);

    // 重新设置格式化器
    this.setupFormatters();

    // 触发语言变化事件
    this.emit('localeChange', {
      from: oldLocale,
      to: locale
    });
  }

  /**
   * @description 保存locale到存储
   * @param {string} locale - 要保存的locale
   */
  saveLocale(locale) {
    try {
      localStorage.setItem(this.storageKey, locale);
    } catch (error) {
      console.warn('无法保存locale到localStorage:', error);
    }
  }

  /**
   * @description 从存储获取locale
   * @returns {string|null} 保存的locale
   */
  getSavedLocale() {
    try {
      return localStorage.getItem(this.storageKey);
    } catch (error) {
      console.warn('无法从localStorage读取locale:', error);
      return null;
    }
  }

  /**
   * @description 设置格式化器
   */
  setupFormatters() {
    // 日期格式化器
    this.dateFormatter = new Intl.DateTimeFormat(this.locale);

    // 数字格式化器
    this.numberFormatter = new Intl.NumberFormat(this.locale);

    // 货币格式化器
    this.currencyFormatter = new Intl.NumberFormat(this.locale, {
      style: 'currency',
      currency: this.getCurrencyForLocale(this.locale)
    });
  }

  /**
   * @description 获取locale对应的货币
   * @param {string} locale - 目标locale
   * @returns {string} 货币代码
   */
  getCurrencyForLocale(locale) {
    const currencyMap = {
      'zh-CN': 'CNY',
      'en-US': 'USD',
      'en-GB': 'GBP',
      'de-DE': 'EUR',
      'ja-JP': 'JPY'
    };

    return currencyMap[locale] || 'USD';
  }

  /**
   * @description 格式化日期
   * @param {Date|string|number} date - 日期
   * @param {Object} options - 格式化选项
   * @returns {string} 格式化后的日期
   */
  formatDate(date, options = {}) {
    const dateObj = new Date(date);

    if (isNaN(dateObj.getTime())) {
      console.error('Invalid date:', date);
      return '';
    }

    const formatter = new Intl.DateTimeFormat(this.locale, options);
    return formatter.format(dateObj);
  }

  /**
   * @description 格式化数字
   * @param {number} number - 数字
   * @param {Object} options - 格式化选项
   * @returns {string} 格式化后的数字
   */
  formatNumber(number, options = {}) {
    const formatter = new Intl.NumberFormat(this.locale, options);
    return formatter.format(number);
  }

  /**
   * @description 格式化货币
   * @param {number} amount - 金额
   * @param {string} currency - 货币代码（可选）
   * @returns {string} 格式化后的货币
   */
  formatCurrency(amount, currency) {
    const finalCurrency = currency || this.getCurrencyForLocale(this.locale);

    const formatter = new Intl.NumberFormat(this.locale, {
      style: 'currency',
      currency: finalCurrency
    });

    return formatter.format(amount);
  }

  /**
   * @description 格式化相对时间
   * @param {Date|number} date - 日期
   * @returns {string} 相对时间描述
   */
  formatRelativeTime(date) {
    const dateObj = new Date(date);
    const now = new Date();
    const diffInSeconds = (now - dateObj) / 1000;

    const rtf = new Intl.RelativeTimeFormat(this.locale, { numeric: 'auto' });

    if (diffInSeconds < 60) {
      return rtf.format(-Math.floor(diffInSeconds), 'second');
    } else if (diffInSeconds < 3600) {
      return rtf.format(-Math.floor(diffInSeconds / 60), 'minute');
    } else if (diffInSeconds < 86400) {
      return rtf.format(-Math.floor(diffInSeconds / 3600), 'hour');
    } else {
      return rtf.format(-Math.floor(diffInSeconds / 86400), 'day');
    }
  }

  /**
   * @description 事件发射器（简化版）
   */
  emit(event, data) {
    if (this.listeners && this.listeners[event]) {
      this.listeners[event].forEach(callback => callback(data));
    }
  }

  /**
   * @description 事件监听
   */
  on(event, callback) {
    if (!this.listeners) this.listeners = {};
    if (!this.listeners[event]) this.listeners[event] = [];
    this.listeners[event].push(callback);
  }
}
```

### 2. React Hook集成

```javascript
import { createContext, useContext, useState, useEffect, useCallback } from 'react';

/**
 * @description 国际化上下文
 */
const I18nContext = createContext(null);

/**
 * @description 国际化Provider组件
 */
export function I18nProvider({ children, defaultLocale = 'zh-CN', fallbackLocale = 'en' }) {
  const [i18n] = useState(() => new I18nManager({
    locale: defaultLocale,
    fallbackLocale
  }));

  const [locale, setLocale] = useState(defaultLocale);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const initI18n = async () => {
      await i18n.init();
      setLocale(i18n.locale);
      setLoading(false);
    };

    initI18n();

    // 监听语言变化
    const handleLocaleChange = (event) => {
      setLocale(event.to);
    };

    i18n.on('localeChange', handleLocaleChange);

    return () => {
      // 清理监听器
      if (i18n.listeners && i18n.listeners.localeChange) {
        const index = i18n.listeners.localeChange.indexOf(handleLocaleChange);
        if (index > -1) {
          i18n.listeners.localeChange.splice(index, 1);
        }
      }
    };
  }, [i18n]);

  const changeLocale = useCallback(async (newLocale) => {
    setLoading(true);
    await i18n.changeLocale(newLocale);
    setLoading(false);
  }, [i18n]);

  const value = {
    i18n,
    locale,
    changeLocale,
    loading,
    t: i18n.t.bind(i18n),
    tc: i18n.tc.bind(i18n),
    formatDate: i18n.formatDate.bind(i18n),
    formatNumber: i18n.formatNumber.bind(i18n),
    formatCurrency: i18n.formatCurrency.bind(i18n),
    formatRelativeTime: i18n.formatRelativeTime.bind(i18n)
  };

  return (
    <I18nContext.Provider value={value}>
      {children}
    </I18nContext.Provider>
  );
}

/**
 * @description 使用国际化的Hook
 * @returns {Object} 国际化工具集
 */
export function useI18n() {
  const context = useContext(I18nContext);

  if (!context) {
    throw new Error('useI18n must be used within an I18nProvider');
  }

  return context;
}

/**
 * @description 翻译Hook
 * @param {string} key - 翻译键
 * @param {Object} params - 参数
 * @returns {string} 翻译后的文本
 */
export function useTranslation(key, params = {}) {
  const { t, locale } = useI18n();
  const [translation, setTranslation] = useState(() => t(key, params));

  useEffect(() => {
    setTranslation(t(key, params));
  }, [t, key, params, locale]);

  return translation;
}

/**
 * @description 格式化Hook
 * @returns {Object} 格式化函数集合
 */
export function useFormatters() {
  const { formatDate, formatNumber, formatCurrency, formatRelativeTime, locale } = useI18n();

  return {
    formatDate,
    formatNumber,
    formatCurrency,
    formatRelativeTime,
    locale
  };
}
```

### 3. Vue Composition API集成

```javascript
import { ref, reactive, provide, inject, onMounted, watch } from 'vue';

// 注入键
const I18N_KEY = Symbol('i18n');

/**
 * @description 创建国际化实例
 * @param {Object} options - 配置选项
 * @returns {Object} 国际化实例
 */
export function createI18n(options = {}) {
  const i18n = new I18nManager(options);
  const locale = ref(options.locale || 'zh-CN');
  const loading = ref(true);

  const state = reactive({
    locale,
    loading,
    messages: new Map()
  });

  /**
   * @description 翻译函数
   */
  const t = (key, params = {}) => {
    return i18n.t(key, params);
  };

  /**
   * @description 复数翻译函数
   */
  const tc = (key, count, params = {}) => {
    return i18n.tc(key, count, params);
  };

  /**
   * @description 切换语言
   */
  const changeLocale = async (newLocale) => {
    loading.value = true;
    await i18n.changeLocale(newLocale);
    locale.value = newLocale;
    loading.value = false;
  };

  /**
   * @description 初始化
   */
  const init = async () => {
    await i18n.init();
    locale.value = i18n.locale;
    loading.value = false;
  };

  return {
    i18n,
    state,
    t,
    tc,
    changeLocale,
    init,
    formatDate: i18n.formatDate.bind(i18n),
    formatNumber: i18n.formatNumber.bind(i18n),
    formatCurrency: i18n.formatCurrency.bind(i18n),
    formatRelativeTime: i18n.formatRelativeTime.bind(i18n)
  };
}

/**
 * @description 提供国际化
 * @param {Object} i18nInstance - 国际化实例
 */
export function provideI18n(i18nInstance) {
  provide(I18N_KEY, i18nInstance);

  onMounted(async () => {
    await i18nInstance.init();
  });
}

/**
 * @description 使用国际化
 * @returns {Object} 国际化实例
 */
export function useI18n() {
  const i18nInstance = inject(I18N_KEY);

  if (!i18nInstance) {
    throw new Error('useI18n must be used after provideI18n');
  }

  return i18nInstance;
}

/**
 * @description 翻译组合函数
 * @param {string} key - 翻译键
 * @param {Object} params - 参数
 * @returns {Object} 响应式翻译文本
 */
export function useTranslation(key, params = {}) {
  const { t, state } = useI18n();
  const translation = ref('');

  const updateTranslation = () => {
    translation.value = t(key, params);
  };

  // 监听语言变化
  watch(() => state.locale, updateTranslation, { immediate: true });

  return {
    translation,
    updateTranslation
  };
}
```

### 4. 语言包管理

```javascript
/**
 * @description 语言包管理器
 */
class LocaleManager {
  constructor() {
    this.locales = new Map();
    this.loadedLocales = new Set();
    this.loadingPromises = new Map();
  }

  /**
   * @description 注册语言包
   * @param {string} locale - 语言标识
   * @param {Object|Function} messages - 语言包或加载函数
   */
  register(locale, messages) {
    if (typeof messages === 'function') {
      // 延迟加载
      this.locales.set(locale, messages);
    } else {
      // 直接注册
      this.locales.set(locale, messages);
      this.loadedLocales.add(locale);
    }
  }

  /**
   * @description 加载语言包
   * @param {string} locale - 语言标识
   * @returns {Promise<Object>} 语言包对象
   */
  async load(locale) {
    if (this.loadedLocales.has(locale)) {
      return this.locales.get(locale);
    }

    // 避免重复加载
    if (this.loadingPromises.has(locale)) {
      return this.loadingPromises.get(locale);
    }

    const loaderOrMessages = this.locales.get(locale);

    if (!loaderOrMessages) {
      throw new Error(`Locale ${locale} not registered`);
    }

    if (typeof loaderOrMessages === 'function') {
      // 异步加载
      const loadingPromise = loaderOrMessages().then(messages => {
        this.locales.set(locale, messages.default || messages);
        this.loadedLocales.add(locale);
        this.loadingPromises.delete(locale);
        return this.locales.get(locale);
      });

      this.loadingPromises.set(locale, loadingPromise);
      return loadingPromise;
    } else {
      // 直接返回
      return loaderOrMessages;
    }
  }

  /**
   * @description 批量注册语言包
   * @param {Object} localesMap - 语言包映射
   */
  registerAll(localesMap) {
    Object.entries(localesMap).forEach(([locale, messages]) => {
      this.register(locale, messages);
    });
  }

  /**
   * @description 获取可用的语言列表
   * @returns {string[]} 语言列表
   */
  getAvailableLocales() {
    return Array.from(this.locales.keys());
  }

  /**
   * @description 预加载语言包
   * @param {string[]} locales - 要预加载的语言列表
   */
  async preload(locales) {
    const promises = locales.map(locale => this.load(locale));
    await Promise.all(promises);
  }
}

// 创建全局语言包管理器
const localeManager = new LocaleManager();

// 注册语言包（支持动态导入）
localeManager.registerAll({
  'zh-CN': () => import('../locales/zh-CN.js'),
  'en': () => import('../locales/en.js'),
  'ja': () => import('../locales/ja.js'),
  'de': () => import('../locales/de.js')
});

export default localeManager;
```

### 5. 语言包文件示例

```javascript
// locales/zh-CN.js
export default {
  common: {
    save: '保存',
    cancel: '取消',
    confirm: '确认',
    delete: '删除',
    edit: '编辑',
    loading: '加载中...',
    error: '错误',
    success: '成功',
    warning: '警告',
    info: '信息'
  },

  user: {
    profile: {
      name: '姓名',
      email: '邮箱',
      phone: '电话',
      avatar: '头像',
      settings: '设置'
    },
    auth: {
      login: '登录',
      logout: '退出',
      register: '注册',
      forgotPassword: '忘记密码？',
      resetPassword: '重置密码'
    }
  },

  message: {
    welcome: '欢迎，{{name}}！',
    itemCount: '共 {{count}} 项',
    itemCount_plural: '共 {{count}} 项', // 中文无复数形式
    lastLogin: '上次登录时间：{{time}}'
  },

  validation: {
    required: '此字段为必填项',
    email: '请输入有效的邮箱地址',
    minLength: '最少输入 {{min}} 个字符',
    maxLength: '最多输入 {{max}} 个字符'
  },

  date: {
    formats: {
      short: 'YYYY-MM-DD',
      long: 'YYYY年MM月DD日',
      dateTime: 'YYYY-MM-DD HH:mm:ss'
    },
    relative: {
      now: '刚刚',
      minuteAgo: '{{count}}分钟前',
      hourAgo: '{{count}}小时前',
      dayAgo: '{{count}}天前'
    }
  }
};

// locales/en.js
export default {
  common: {
    save: 'Save',
    cancel: 'Cancel',
    confirm: 'Confirm',
    delete: 'Delete',
    edit: 'Edit',
    loading: 'Loading...',
    error: 'Error',
    success: 'Success',
    warning: 'Warning',
    info: 'Information'
  },

  user: {
    profile: {
      name: 'Name',
      email: 'Email',
      phone: 'Phone',
      avatar: 'Avatar',
      settings: 'Settings'
    },
    auth: {
      login: 'Login',
      logout: 'Logout',
      register: 'Register',
      forgotPassword: 'Forgot Password?',
      resetPassword: 'Reset Password'
    }
  },

  message: {
    welcome: 'Welcome, {{name}}!',
    itemCount: '{{count}} item',
    itemCount_plural: '{{count}} items',
    lastLogin: 'Last login: {{time}}'
  },

  validation: {
    required: 'This field is required',
    email: 'Please enter a valid email address',
    minLength: 'Minimum length is {{min}} characters',
    maxLength: 'Maximum length is {{max}} characters'
  },

  date: {
    formats: {
      short: 'MM/DD/YYYY',
      long: 'MMMM DD, YYYY',
      dateTime: 'MM/DD/YYYY HH:mm:ss'
    },
    relative: {
      now: 'just now',
      minuteAgo: '{{count}} minute ago',
      minuteAgo_plural: '{{count}} minutes ago',
      hourAgo: '{{count}} hour ago',
      hourAgo_plural: '{{count}} hours ago',
      dayAgo: '{{count}} day ago',
      dayAgo_plural: '{{count}} days ago'
    }
  }
};

```

## 面试常见问题

### 1. 如何实现前端国际化？

**答**：
前端国际化的实现主要包含以下几个方面：

```javascript
// 1. 基础国际化架构
class SimpleI18n {
  constructor() {
    this.locale = 'zh-CN';
    this.messages = new Map();
    this.fallbackLocale = 'en';
  }

  // 加载语言包
  async loadLocale(locale) {
    const messages = await import(`./locales/${locale}.js`);
    this.messages.set(locale, messages.default);
  }

  // 翻译函数
  t(key, params = {}) {
    const message = this.getMessage(key, this.locale) ||
                   this.getMessage(key, this.fallbackLocale) ||
                   key;

    // 参数插值
    return message.replace(/\{\{(\w+)\}\}/g, (match, paramKey) => {
      return params[paramKey] !== undefined ? params[paramKey] : match;
    });
  }

  getMessage(key, locale) {
    const messages = this.messages.get(locale);
    return key.split('.').reduce((obj, k) => obj && obj[k], messages);
  }

  // 切换语言
  async changeLocale(locale) {
    await this.loadLocale(locale);
    this.locale = locale;
    document.documentElement.lang = locale;
    this.emit('localeChanged', locale);
  }
}

// 2. 使用示例
const i18n = new SimpleI18n();

// 翻译
console.log(i18n.t('common.save')); // "保存"
console.log(i18n.t('message.welcome', { name: '张三' })); // "欢迎，张三！"

// 切换语言
await i18n.changeLocale('en');
console.log(i18n.t('common.save')); // "Save"
```

**实现要点**：
- **语言包管理**：按模块组织，支持动态加载
- **翻译函数**：支持嵌套键、参数插值、回退机制
- **格式化**：日期、数字、货币的本地化格式
- **复数处理**：不同语言的复数规则
- **性能优化**：缓存、懒加载、预加载

### 2. 如何处理不同语言的文本长度变化？

**答**：
不同语言的文本长度差异很大，需要在设计和开发中考虑：

```css
/* 1. 弹性布局设计 */
.button {
  padding: 8px 16px;
  min-width: 80px; /* 设置最小宽度 */
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* 2. 响应式文本处理 */
.text-container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

/* 3. 不同语言的特殊处理 */
[lang="de"] .button {
  min-width: 120px; /* 德语通常更长 */
}

[lang="zh"] .button {
  min-width: 60px; /* 中文通常更短 */
}

/* 4. 多行文本处理 */
.description {
  line-height: 1.5;
  max-height: 4.5em; /* 3行文本 */
  overflow: hidden;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
}
```

```javascript
// 动态调整文本显示
class ResponsiveText {
  constructor(element) {
    this.element = element;
    this.originalText = element.textContent;
  }

  adjustForLocale(locale) {
    const textLengthFactors = {
      'de': 1.3,  // 德语通常比英语长30%
      'fr': 1.2,  // 法语长20%
      'zh': 0.7,  // 中文短30%
      'ja': 0.8   // 日语短20%
    };

    const factor = textLengthFactors[locale] || 1;
    const containerWidth = this.element.offsetWidth;

    if (factor > 1) {
      // 为较长的语言增加宽度或启用换行
      this.element.style.minWidth = `${containerWidth * factor}px`;
    } else {
      // 为较短的语言优化间距
      this.element.style.letterSpacing = '0.5px';
    }
  }

  truncateText(maxLength) {
    const text = this.originalText;
    if (text.length > maxLength) {
      this.element.textContent = text.substring(0, maxLength - 3) + '...';
      this.element.title = text; // 完整文本作为提示
    }
  }
}
```

**处理策略**：
- **预留空间**：UI设计时为最长语言预留足够空间
- **弹性布局**：使用flexbox、grid等自适应布局
- **文本截断**：长文本使用省略号或多行处理
- **响应式字体**：根据语言调整字体大小和间距

### 3. 如何实现右到左(RTL)语言支持？

**答**：
RTL语言（如阿拉伯语、希伯来语）需要特殊的布局处理：

```css
/* 1. 基础RTL支持 */
[dir="rtl"] {
  direction: rtl;
  text-align: right;
}

/* 2. 布局镜像 */
.container {
  display: flex;
  justify-content: flex-start;
}

[dir="rtl"] .container {
  justify-content: flex-end;
}

/* 3. 边距和内边距镜像 */
.sidebar {
  margin-left: 20px;
  padding-left: 15px;
  border-left: 2px solid #ccc;
}

[dir="rtl"] .sidebar {
  margin-left: 0;
  margin-right: 20px;
  padding-left: 0;
  padding-right: 15px;
  border-left: none;
  border-right: 2px solid #ccc;
}

/* 4. 使用逻辑属性（现代方案） */
.modern-sidebar {
  margin-inline-start: 20px;
  padding-inline-start: 15px;
  border-inline-start: 2px solid #ccc;
}

/* 5. 图标和箭头处理 */
.arrow-right {
  transform: rotate(0deg);
}

[dir="rtl"] .arrow-right {
  transform: rotate(180deg);
}
```

```javascript
// RTL语言检测和处理
class RTLManager {
  constructor() {
    this.rtlLanguages = ['ar', 'he', 'fa', 'ur'];
  }

  isRTL(locale) {
    const lang = locale.split('-')[0];
    return this.rtlLanguages.includes(lang);
  }

  applyRTL(locale) {
    const isRTL = this.isRTL(locale);

    document.documentElement.dir = isRTL ? 'rtl' : 'ltr';
    document.documentElement.lang = locale;

    // 添加RTL样式类
    document.body.classList.toggle('rtl', isRTL);
    document.body.classList.toggle('ltr', !isRTL);

    // 处理特殊元素
    this.handleRTLElements(isRTL);
  }

  handleRTLElements(isRTL) {
    // 处理图表方向
    const charts = document.querySelectorAll('.chart');
    charts.forEach(chart => {
      if (isRTL) {
        chart.style.transform = 'scaleX(-1)';
      } else {
        chart.style.transform = 'none';
      }
    });

    // 处理滚动条
    const scrollableElements = document.querySelectorAll('.scrollable');
    scrollableElements.forEach(el => {
      if (isRTL) {
        el.scrollLeft = el.scrollWidth - el.clientWidth;
      } else {
        el.scrollLeft = 0;
      }
    });
  }

  // 镜像CSS值
  mirrorValue(property, value, isRTL) {
    if (!isRTL) return value;

    const mirrorMap = {
      'left': 'right',
      'right': 'left',
      'margin-left': 'margin-right',
      'margin-right': 'margin-left',
      'padding-left': 'padding-right',
      'padding-right': 'padding-left'
    };

    return mirrorMap[property] || value;
  }
}

// 使用示例
const rtlManager = new RTLManager();

// 检测并应用RTL
window.i18n.on('localeChanged', (locale) => {
  rtlManager.applyRTL(locale);
});
```

**RTL处理要点**：
- **方向设置**：`dir="rtl"` 和 CSS `direction: rtl`
- **布局镜像**：margin、padding、border、定位等属性
- **逻辑属性**：使用 `margin-inline-start` 等逻辑属性
- **图标旋转**：箭头、图标需要水平翻转
- **滚动条处理**：默认滚动位置调整

### 4. 如何优化国际化的性能？

**答**：
国际化性能优化主要从以下几个方面着手：

```javascript
// 1. 语言包分割和懒加载
class PerformantI18n {
  constructor() {
    this.loadedChunks = new Set();
    this.cache = new Map();
  }

  // 按路由分割语言包
  async loadRouteLocale(route, locale) {
    const chunkKey = `${route}-${locale}`;

    if (this.loadedChunks.has(chunkKey)) {
      return;
    }

    const messages = await import(`./locales/${locale}/${route}.js`);
    this.mergeMessages(locale, messages.default);
    this.loadedChunks.add(chunkKey);
  }

  // 预加载策略
  async preloadCommonLocales() {
    const commonChunks = ['common', 'navigation', 'errors'];
    const promises = commonChunks.map(chunk =>
      this.loadRouteLocale(chunk, this.locale)
    );

    await Promise.all(promises);
  }

  // 智能缓存
  getCachedTranslation(key, params, locale) {
    const cacheKey = `${locale}:${key}:${JSON.stringify(params)}`;
    return this.cache.get(cacheKey);
  }

  setCachedTranslation(key, params, locale, translation) {
    const cacheKey = `${locale}:${key}:${JSON.stringify(params)}`;

    // LRU缓存策略
    if (this.cache.size >= 1000) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }

    this.cache.set(cacheKey, translation);
  }
}

// 2. 批量翻译优化
class BatchTranslator {
  constructor(i18n) {
    this.i18n = i18n;
    this.batchQueue = [];
    this.batchTimeout = null;
  }

  // 批量翻译请求
  translateBatch(keys) {
    return new Promise((resolve) => {
      this.batchQueue.push({ keys, resolve });

      if (!this.batchTimeout) {
        this.batchTimeout = setTimeout(() => {
          this.processBatch();
        }, 10); // 10ms内的请求批量处理
      }
    });
  }

  processBatch() {
    const currentBatch = this.batchQueue.splice(0);
    this.batchTimeout = null;

    // 去重所有keys
    const allKeys = [...new Set(
      currentBatch.flatMap(item => item.keys)
    )];

    // 批量翻译
    const translations = {};
    allKeys.forEach(key => {
      translations[key] = this.i18n.t(key);
    });

    // 返回结果给各个请求者
    currentBatch.forEach(({ keys, resolve }) => {
      const result = {};
      keys.forEach(key => {
        result[key] = translations[key];
      });
      resolve(result);
    });
  }
}

// 3. 虚拟滚动中的国际化
class VirtualizedI18nList {
  constructor(container, items, i18n) {
    this.container = container;
    this.items = items;
    this.i18n = i18n;
    this.translationCache = new Map();
    this.visibleRange = { start: 0, end: 10 };
  }

  // 只翻译可见项目
  async renderVisibleItems() {
    const visibleItems = this.items.slice(
      this.visibleRange.start,
      this.visibleRange.end
    );

    // 批量获取需要的翻译
    const translationKeys = visibleItems.flatMap(item => [
      item.titleKey,
      item.descriptionKey
    ]);

    const translations = await this.batchTranslate(translationKeys);

    // 渲染
    visibleItems.forEach((item, index) => {
      const element = this.getOrCreateElement(index);
      element.querySelector('.title').textContent =
        translations[item.titleKey];
      element.querySelector('.description').textContent =
        translations[item.descriptionKey];
    });
  }

  async batchTranslate(keys) {
    const uncachedKeys = keys.filter(key =>
      !this.translationCache.has(key)
    );

    if (uncachedKeys.length > 0) {
      const newTranslations = {};
      uncachedKeys.forEach(key => {
        newTranslations[key] = this.i18n.t(key);
        this.translationCache.set(key, newTranslations[key]);
      });
    }

    const result = {};
    keys.forEach(key => {
      result[key] = this.translationCache.get(key);
    });

    return result;
  }
}

// 4. Service Worker缓存语言包
// sw.js
self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);

  // 缓存语言包请求
  if (url.pathname.includes('/locales/')) {
    event.respondWith(
      caches.open('i18n-cache-v1').then(cache => {
        return cache.match(event.request).then(response => {
          if (response) {
            return response;
          }

          return fetch(event.request).then(fetchResponse => {
            cache.put(event.request, fetchResponse.clone());
            return fetchResponse;
          });
        });
      })
    );
  }
});
```

**性能优化策略**：
- **分包加载**：按模块、路由分割语言包
- **缓存机制**：内存缓存、Service Worker缓存
- **批量处理**：合并翻译请求，减少计算开销
- **预加载**：提前加载常用语言包
- **虚拟化**：大列表只翻译可见项目

### 5. 如何设计可扩展的国际化架构？

**答**：
可扩展的国际化架构需要考虑模块化、插件化和可维护性：

```javascript
// 1. 插件化架构
class ExtensibleI18n {
  constructor() {
    this.plugins = new Map();
    this.hooks = {
      beforeTranslate: [],
      afterTranslate: [],
      beforeLocaleChange: [],
      afterLocaleChange: []
    };
  }

  // 注册插件
  use(plugin) {
    if (typeof plugin.install === 'function') {
      plugin.install(this);
      this.plugins.set(plugin.name, plugin);
    }
  }

  // 钩子系统
  addHook(hookName, callback) {
    if (this.hooks[hookName]) {
      this.hooks[hookName].push(callback);
    }
  }

  executeHooks(hookName, context) {
    if (this.hooks[hookName]) {
      this.hooks[hookName].forEach(callback => {
        callback(context);
      });
    }
  }

  // 增强的翻译方法
  t(key, params = {}) {
    const context = { key, params, locale: this.locale };

    // 翻译前钩子
    this.executeHooks('beforeTranslate', context);

    const translation = this.performTranslation(context);

    // 翻译后钩子
    this.executeHooks('afterTranslate', { ...context, translation });

    return translation;
  }
}

// 2. 翻译插件示例
class PluralizationPlugin {
  constructor() {
    this.name = 'pluralization';
  }

  install(i18n) {
    // 添加复数翻译方法
    i18n.tc = (key, count, params = {}) => {
      const pluralKey = this.getPluralKey(key, count, i18n.locale);
      return i18n.t(pluralKey, { ...params, count });
    };

    // 注册复数规则
    i18n.pluralRules = new Map();
    this.registerCommonRules(i18n);
  }

  getPluralKey(key, count, locale) {
    const rule = this.getRule(locale);
    const suffix = rule(count);
    return suffix ? `${key}_${suffix}` : key;
  }

  registerCommonRules(i18n) {
    // 英语复数规则
    i18n.pluralRules.set('en', (n) => n === 1 ? '' : 'other');

    // 中文无复数
    i18n.pluralRules.set('zh', () => '');

    // 俄语复数规则
    i18n.pluralRules.set('ru', (n) => {
      if (n % 10 === 1 && n % 100 !== 11) return 'one';
      if (n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20)) return 'few';
      return 'many';
    });
  }
}

// 3. 格式化插件
class FormattingPlugin {
  constructor() {
    this.name = 'formatting';
  }

  install(i18n) {
    // 添加格式化方法
    i18n.formatters = {
      date: this.createDateFormatter(i18n),
      number: this.createNumberFormatter(i18n),
      currency: this.createCurrencyFormatter(i18n),
      relative: this.createRelativeTimeFormatter(i18n)
    };

    // 添加格式化翻译
    i18n.tf = (key, value, formatter, options = {}) => {
      const formatted = i18n.formatters[formatter](value, options);
      return i18n.t(key, { value: formatted });
    };
  }

  createDateFormatter(i18n) {
    return (date, options = {}) => {
      const formatter = new Intl.DateTimeFormat(i18n.locale, options);
      return formatter.format(new Date(date));
    };
  }

  createNumberFormatter(i18n) {
    return (number, options = {}) => {
      const formatter = new Intl.NumberFormat(i18n.locale, options);
      return formatter.format(number);
    };
  }

  createCurrencyFormatter(i18n) {
    return (amount, currency = 'USD', options = {}) => {
      const formatter = new Intl.NumberFormat(i18n.locale, {
        style: 'currency',
        currency,
        ...options
      });
      return formatter.format(amount);
    };
  }

  createRelativeTimeFormatter(i18n) {
    return (date, options = {}) => {
      const rtf = new Intl.RelativeTimeFormat(i18n.locale, options);
      const diffInDays = Math.floor((new Date(date) - new Date()) / (1000 * 60 * 60 * 24));
      return rtf.format(diffInDays, 'day');
    };
  }
}

// 4. 验证插件
class ValidationPlugin {
  constructor() {
    this.name = 'validation';
  }

  install(i18n) {
    // 翻译键验证
    i18n.addHook('beforeTranslate', (context) => {
      this.validateKey(context.key);
    });

    // 缺失翻译报告
    i18n.missingTranslations = new Set();

    i18n.addHook('afterTranslate', (context) => {
      if (context.translation === context.key) {
        i18n.missingTranslations.add(`${context.locale}:${context.key}`);
      }
    });
  }

  validateKey(key) {
    // 检查键格式
    if (!/^[a-zA-Z][a-zA-Z0-9._]*$/.test(key)) {
      console.warn(`Invalid translation key format: ${key}`);
    }

    // 检查嵌套深度
    const depth = key.split('.').length;
    if (depth > 5) {
      console.warn(`Translation key too deep: ${key}`);
    }
  }
}

// 5. 使用示例
const i18n = new ExtensibleI18n();

// 安装插件
i18n.use(new PluralizationPlugin());
i18n.use(new FormattingPlugin());
i18n.use(new ValidationPlugin());

// 使用增强功能
console.log(i18n.tc('message.itemCount', 5)); // "5 items"
console.log(i18n.tf('order.total', 1234.56, 'currency', { currency: 'USD' })); // "Total: $1,234.56"
```

**架构设计原则**：
- **插件化**：核心功能最小化，通过插件扩展
- **钩子系统**：在关键节点提供扩展点
- **配置驱动**：通过配置控制行为
- **类型安全**：TypeScript支持，编译时检查
- **测试友好**：便于单元测试和集成测试
- **向后兼容**：API变更向后兼容
</rewritten_file>
}