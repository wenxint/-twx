# 一键换肤

> 一键换肤是现代Web应用中常见的功能，能够提升用户体验，满足不同用户的视觉偏好。本文详细介绍主流的换肤实现方案，并提供完整的代码示例。

## 基本概念

一键换肤功能允许用户在预设的多套UI主题之间快速切换，通常包括：
- **明暗主题切换**：Light/Dark模式
- **多色彩主题**：不同的配色方案
- **字体大小调整**：适应不同用户需求
- **布局风格变化**：紧凑/宽松布局

## 核心实现方案

### 1. CSS变量方案（推荐）

CSS变量是最现代化的换肤解决方案，具有良好的浏览器支持和灵活性。

```css
/* 主题变量定义 */
:root {
  /* 默认浅色主题 */
  --primary-color: #1976d2;
  --secondary-color: #dc004e;
  --bg-color: #ffffff;
  --text-color: #333333;
  --border-color: #e0e0e0;
  --shadow-color: rgba(0, 0, 0, 0.1);
}

/* 深色主题 */
[data-theme="dark"] {
  --primary-color: #90caf9;
  --secondary-color: #f48fb1;
  --bg-color: #121212;
  --text-color: #ffffff;
  --border-color: #333333;
  --shadow-color: rgba(255, 255, 255, 0.1);
}

/* 蓝色主题 */
[data-theme="blue"] {
  --primary-color: #2196f3;
  --secondary-color: #ff9800;
  --bg-color: #f3f8ff;
  --text-color: #1a1a1a;
  --border-color: #b3d9ff;
  --shadow-color: rgba(33, 150, 243, 0.2);
}

/* 应用变量到组件 */
.app {
  background-color: var(--bg-color);
  color: var(--text-color);
  border: 1px solid var(--border-color);
  box-shadow: 0 2px 8px var(--shadow-color);
  transition: all 0.3s ease;
}

.button {
  background-color: var(--primary-color);
  color: var(--bg-color);
  border: none;
  padding: 8px 16px;
  border-radius: 4px;
  transition: all 0.3s ease;
}

.button:hover {
  opacity: 0.8;
}
```

### 2. 主题切换逻辑实现

```javascript
/**
 * @description 主题管理器类
 * @class ThemeManager
 */
class ThemeManager {
  constructor() {
    this.themes = ['light', 'dark', 'blue'];
    this.currentTheme = 'light';
    this.storageKey = 'user-theme';

    // 初始化主题
    this.init();
  }

  /**
   * @description 初始化主题，从localStorage读取用户偏好
   */
  init() {
    // 1. 优先读取本地存储的主题
    const savedTheme = localStorage.getItem(this.storageKey);

    // 2. 检测系统主题偏好
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

    // 3. 确定初始主题
    this.currentTheme = savedTheme || (prefersDark ? 'dark' : 'light');

    // 4. 应用主题
    this.applyTheme(this.currentTheme);

    // 5. 监听系统主题变化
    this.watchSystemTheme();
  }

  /**
   * @description 应用指定主题
   * @param {string} theme - 主题名称
   */
  applyTheme(theme) {
    if (!this.themes.includes(theme)) {
      console.warn(`Unknown theme: ${theme}`);
      return;
    }

    // 移除之前的主题类
    document.documentElement.removeAttribute('data-theme');

    // 应用新主题
    if (theme !== 'light') {
      document.documentElement.setAttribute('data-theme', theme);
    }

    this.currentTheme = theme;

    // 保存到本地存储
    localStorage.setItem(this.storageKey, theme);

    // 触发主题变化事件
    this.dispatchThemeChange(theme);
  }

  /**
   * @description 切换到下一个主题
   */
  toggleTheme() {
    const currentIndex = this.themes.indexOf(this.currentTheme);
    const nextIndex = (currentIndex + 1) % this.themes.length;
    const nextTheme = this.themes[nextIndex];

    this.applyTheme(nextTheme);
  }

  /**
   * @description 获取当前主题
   * @returns {string} 当前主题名称
   */
  getCurrentTheme() {
    return this.currentTheme;
  }

  /**
   * @description 监听系统主题变化
   */
  watchSystemTheme() {
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');

    mediaQuery.addEventListener('change', (e) => {
      // 只有在用户没有手动设置主题时才自动切换
      if (!localStorage.getItem(this.storageKey)) {
        this.applyTheme(e.matches ? 'dark' : 'light');
      }
    });
  }

  /**
   * @description 派发主题变化事件
   * @param {string} theme - 新主题名称
   */
  dispatchThemeChange(theme) {
    const event = new CustomEvent('themechange', {
      detail: { theme, previousTheme: this.currentTheme }
    });

    window.dispatchEvent(event);
  }

  /**
   * @description 重置为系统主题
   */
  resetToSystemTheme() {
    localStorage.removeItem(this.storageKey);
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    this.applyTheme(prefersDark ? 'dark' : 'light');
  }
}

// 创建全局主题管理器实例
const themeManager = new ThemeManager();

// 导出供其他模块使用
window.themeManager = themeManager;
```

### 3. React Hook实现

```javascript
import { useState, useEffect, useCallback } from 'react';

/**
 * @description React主题管理Hook
 * @returns {Object} 主题状态和控制方法
 */
export function useTheme() {
  const [theme, setTheme] = useState('light');
  const [themes] = useState(['light', 'dark', 'blue']);

  /**
   * @description 应用主题到DOM
   */
  const applyTheme = useCallback((themeName) => {
    document.documentElement.removeAttribute('data-theme');

    if (themeName !== 'light') {
      document.documentElement.setAttribute('data-theme', themeName);
    }

    localStorage.setItem('user-theme', themeName);
    setTheme(themeName);
  }, []);

  /**
   * @description 切换主题
   */
  const toggleTheme = useCallback(() => {
    const currentIndex = themes.indexOf(theme);
    const nextIndex = (currentIndex + 1) % themes.length;
    applyTheme(themes[nextIndex]);
  }, [theme, themes, applyTheme]);

  /**
   * @description 设置指定主题
   */
  const changeTheme = useCallback((themeName) => {
    if (themes.includes(themeName)) {
      applyTheme(themeName);
    }
  }, [themes, applyTheme]);

  // 初始化主题
  useEffect(() => {
    const savedTheme = localStorage.getItem('user-theme');
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const initialTheme = savedTheme || (prefersDark ? 'dark' : 'light');

    applyTheme(initialTheme);
  }, [applyTheme]);

  // 监听系统主题变化
  useEffect(() => {
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');

    const handleChange = (e) => {
      if (!localStorage.getItem('user-theme')) {
        applyTheme(e.matches ? 'dark' : 'light');
      }
    };

    mediaQuery.addEventListener('change', handleChange);

    return () => {
      mediaQuery.removeEventListener('change', handleChange);
    };
  }, [applyTheme]);

  return {
    theme,
    themes,
    toggleTheme,
    changeTheme,
    isDark: theme === 'dark',
    isLight: theme === 'light'
  };
}
```

### 4. Vue Composition API实现

```javascript
import { ref, computed, onMounted, watch } from 'vue';

/**
 * @description Vue主题管理组合式函数
 * @returns {Object} 主题状态和控制方法
 */
export function useTheme() {
  const theme = ref('light');
  const themes = ref(['light', 'dark', 'blue']);

  // 计算属性
  const isDark = computed(() => theme.value === 'dark');
  const isLight = computed(() => theme.value === 'light');

  /**
   * @description 应用主题
   */
  const applyTheme = (themeName) => {
    if (!themes.value.includes(themeName)) return;

    document.documentElement.removeAttribute('data-theme');

    if (themeName !== 'light') {
      document.documentElement.setAttribute('data-theme', themeName);
    }

    localStorage.setItem('user-theme', themeName);
    theme.value = themeName;
  };

  /**
   * @description 切换主题
   */
  const toggleTheme = () => {
    const currentIndex = themes.value.indexOf(theme.value);
    const nextIndex = (currentIndex + 1) % themes.value.length;
    applyTheme(themes.value[nextIndex]);
  };

  /**
   * @description 设置指定主题
   */
  const changeTheme = (themeName) => {
    applyTheme(themeName);
  };

  // 初始化
  onMounted(() => {
    const savedTheme = localStorage.getItem('user-theme');
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const initialTheme = savedTheme || (prefersDark ? 'dark' : 'light');

    applyTheme(initialTheme);

    // 监听系统主题变化
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    const handleChange = (e) => {
      if (!localStorage.getItem('user-theme')) {
        applyTheme(e.matches ? 'dark' : 'light');
      }
    };

    mediaQuery.addEventListener('change', handleChange);

    // 清理函数
    return () => {
      mediaQuery.removeEventListener('change', handleChange);
    };
  });

  return {
    theme,
    themes,
    isDark,
    isLight,
    toggleTheme,
    changeTheme
  };
}
```

## 实战案例

### 1. 完整的主题切换组件

```javascript
/**
 * @description 主题切换器组件
 */
class ThemeSwitcher {
  constructor(container) {
    this.container = container;
    this.render();
    this.bindEvents();
  }

  /**
   * @description 渲染组件HTML
   */
  render() {
    this.container.innerHTML = `
      <div class="theme-switcher">
        <button class="theme-btn" data-theme="light">
          <span class="theme-icon">☀️</span>
          <span class="theme-label">浅色</span>
        </button>
        <button class="theme-btn" data-theme="dark">
          <span class="theme-icon">🌙</span>
          <span class="theme-label">深色</span>
        </button>
        <button class="theme-btn" data-theme="blue">
          <span class="theme-icon">💙</span>
          <span class="theme-label">蓝色</span>
        </button>
      </div>
    `;

    // 添加样式
    this.addStyles();
    this.updateActiveState();
  }

  /**
   * @description 添加组件样式
   */
  addStyles() {
    const style = document.createElement('style');
    style.textContent = `
      .theme-switcher {
        display: flex;
        gap: 8px;
        padding: 8px;
        background: var(--bg-color);
        border-radius: 8px;
        border: 1px solid var(--border-color);
      }

      .theme-btn {
        display: flex;
        align-items: center;
        gap: 4px;
        padding: 8px 12px;
        border: none;
        border-radius: 6px;
        background: transparent;
        color: var(--text-color);
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 14px;
      }

      .theme-btn:hover {
        background: var(--primary-color);
        color: var(--bg-color);
      }

      .theme-btn.active {
        background: var(--primary-color);
        color: var(--bg-color);
      }

      .theme-icon {
        font-size: 16px;
      }
    `;

    if (!document.querySelector('#theme-switcher-styles')) {
      style.id = 'theme-switcher-styles';
      document.head.appendChild(style);
    }
  }

  /**
   * @description 绑定事件监听
   */
  bindEvents() {
    this.container.addEventListener('click', (e) => {
      const button = e.target.closest('.theme-btn');
      if (button) {
        const theme = button.dataset.theme;
        window.themeManager.applyTheme(theme);
        this.updateActiveState();
      }
    });

    // 监听主题变化事件
    window.addEventListener('themechange', () => {
      this.updateActiveState();
    });
  }

  /**
   * @description 更新按钮激活状态
   */
  updateActiveState() {
    const currentTheme = window.themeManager.getCurrentTheme();
    const buttons = this.container.querySelectorAll('.theme-btn');

    buttons.forEach(btn => {
      btn.classList.toggle('active', btn.dataset.theme === currentTheme);
    });
  }
}

// 使用示例
document.addEventListener('DOMContentLoaded', () => {
  const switcherContainer = document.querySelector('#theme-switcher');
  if (switcherContainer) {
    new ThemeSwitcher(switcherContainer);
  }
});
```

### 2. 主题配置管理

```javascript
/**
 * @description 主题配置管理器
 */
class ThemeConfig {
  constructor() {
    this.themes = {
      light: {
        name: '浅色主题',
        colors: {
          primary: '#1976d2',
          secondary: '#dc004e',
          background: '#ffffff',
          text: '#333333',
          border: '#e0e0e0',
          shadow: 'rgba(0, 0, 0, 0.1)'
        }
      },
      dark: {
        name: '深色主题',
        colors: {
          primary: '#90caf9',
          secondary: '#f48fb1',
          background: '#121212',
          text: '#ffffff',
          border: '#333333',
          shadow: 'rgba(255, 255, 255, 0.1)'
        }
      },
      blue: {
        name: '蓝色主题',
        colors: {
          primary: '#2196f3',
          secondary: '#ff9800',
          background: '#f3f8ff',
          text: '#1a1a1a',
          border: '#b3d9ff',
          shadow: 'rgba(33, 150, 243, 0.2)'
        }
      }
    };
  }

  /**
   * @description 获取主题配置
   * @param {string} themeName - 主题名称
   * @returns {Object} 主题配置对象
   */
  getTheme(themeName) {
    return this.themes[themeName] || this.themes.light;
  }

  /**
   * @description 动态生成CSS变量
   * @param {string} themeName - 主题名称
   */
  generateCSSVariables(themeName) {
    const theme = this.getTheme(themeName);
    const cssVariables = [];

    Object.entries(theme.colors).forEach(([key, value]) => {
      const cssVarName = `--${key.replace(/([A-Z])/g, '-$1').toLowerCase()}-color`;
      cssVariables.push(`${cssVarName}: ${value};`);
    });

    return cssVariables.join('\n  ');
  }

  /**
   * @description 动态注入主题样式
   */
  injectThemeStyles() {
    let styleContent = ':root {\n';
    styleContent += '  ' + this.generateCSSVariables('light');
    styleContent += '\n}\n\n';

    Object.keys(this.themes).forEach(themeName => {
      if (themeName !== 'light') {
        styleContent += `[data-theme="${themeName}"] {\n`;
        styleContent += '  ' + this.generateCSSVariables(themeName);
        styleContent += '\n}\n\n';
      }
    });

    const styleEl = document.createElement('style');
    styleEl.id = 'dynamic-theme-styles';
    styleEl.textContent = styleContent;

    // 移除已存在的样式
    const existingStyle = document.querySelector('#dynamic-theme-styles');
    if (existingStyle) {
      existingStyle.remove();
    }

    document.head.appendChild(styleEl);
  }

  /**
   * @description 添加自定义主题
   * @param {string} name - 主题名称
   * @param {Object} config - 主题配置
   */
  addTheme(name, config) {
    this.themes[name] = config;
    this.injectThemeStyles();
  }
}

// 使用示例
const themeConfig = new ThemeConfig();
themeConfig.injectThemeStyles();

// 添加自定义主题
themeConfig.addTheme('green', {
  name: '绿色主题',
  colors: {
    primary: '#4caf50',
    secondary: '#ff5722',
    background: '#f1f8e9',
    text: '#2e7d32',
    border: '#c8e6c9',
    shadow: 'rgba(76, 175, 80, 0.2)'
  }
});
```

## 高级特性

### 1. 动画过渡效果

```css
/* 平滑的主题切换动画 */
* {
  transition: background-color 0.3s ease,
              color 0.3s ease,
              border-color 0.3s ease,
              box-shadow 0.3s ease;
}

/* 特殊元素的动画处理 */
.theme-transition {
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

/* 避免某些元素的动画干扰 */
.no-transition * {
  transition: none !important;
}
```

### 2. 主题预加载

```javascript
/**
 * @description 主题预加载器
 */
class ThemePreloader {
  constructor() {
    this.preloadedThemes = new Set();
  }

  /**
   * @description 预加载主题资源
   * @param {string} themeName - 主题名称
   */
  async preloadTheme(themeName) {
    if (this.preloadedThemes.has(themeName)) {
      return;
    }

    try {
      // 预加载主题相关的CSS文件
      if (themeName !== 'light') {
        await this.loadCSS(`/themes/${themeName}.css`);
      }

      // 预加载主题相关的图片资源
      await this.preloadImages(themeName);

      this.preloadedThemes.add(themeName);
      console.log(`Theme ${themeName} preloaded successfully`);
    } catch (error) {
      console.error(`Failed to preload theme ${themeName}:`, error);
    }
  }

  /**
   * @description 加载CSS文件
   * @param {string} url - CSS文件URL
   */
  loadCSS(url) {
    return new Promise((resolve, reject) => {
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = url;
      link.onload = resolve;
      link.onerror = reject;
      document.head.appendChild(link);
    });
  }

  /**
   * @description 预加载主题图片
   * @param {string} themeName - 主题名称
   */
  async preloadImages(themeName) {
    const imageUrls = this.getThemeImages(themeName);

    const promises = imageUrls.map(url => {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = resolve;
        img.onerror = reject;
        img.src = url;
      });
    });

    await Promise.all(promises);
  }

  /**
   * @description 获取主题相关的图片URL列表
   * @param {string} themeName - 主题名称
   * @returns {string[]} 图片URL数组
   */
  getThemeImages(themeName) {
    const imageMap = {
      dark: ['/images/dark-logo.png', '/images/dark-bg.jpg'],
      blue: ['/images/blue-logo.png', '/images/blue-bg.jpg'],
      light: ['/images/light-logo.png', '/images/light-bg.jpg']
    };

    return imageMap[themeName] || [];
  }

  /**
   * @description 预加载所有主题
   */
  async preloadAllThemes() {
    const themes = ['light', 'dark', 'blue'];
    await Promise.all(themes.map(theme => this.preloadTheme(theme)));
  }
}

// 使用示例
const preloader = new ThemePreloader();

// 在空闲时间预加载
if ('requestIdleCallback' in window) {
  requestIdleCallback(() => {
    preloader.preloadAllThemes();
  });
} else {
  setTimeout(() => {
    preloader.preloadAllThemes();
  }, 1000);
}
```

### 3. 自适应主题切换

```javascript
/**
 * @description 自适应主题管理器
 */
class AdaptiveThemeManager extends ThemeManager {
  constructor() {
    super();
    this.timeBasedSwitching = false;
    this.locationBasedSwitching = false;
  }

  /**
   * @description 启用基于时间的主题切换
   */
  enableTimeBasedSwitching() {
    this.timeBasedSwitching = true;
    this.checkTimeBasedTheme();

    // 每小时检查一次
    this.timeInterval = setInterval(() => {
      this.checkTimeBasedTheme();
    }, 60 * 60 * 1000);
  }

  /**
   * @description 检查基于时间的主题
   */
  checkTimeBasedTheme() {
    if (!this.timeBasedSwitching) return;

    const hour = new Date().getHours();
    let suggestedTheme;

    if (hour >= 6 && hour < 18) {
      suggestedTheme = 'light'; // 白天使用浅色主题
    } else {
      suggestedTheme = 'dark';  // 夜晚使用深色主题
    }

    // 只在用户没有手动设置时才自动切换
    if (!localStorage.getItem(this.storageKey)) {
      this.applyTheme(suggestedTheme);
    }
  }

  /**
   * @description 启用基于地理位置的主题切换
   */
  async enableLocationBasedSwitching() {
    this.locationBasedSwitching = true;

    try {
      const position = await this.getCurrentPosition();
      const { latitude, longitude } = position.coords;

      // 根据地理位置获取日出日落时间
      const sunTimes = await this.getSunTimes(latitude, longitude);
      this.scheduleThemeByLocation(sunTimes);
    } catch (error) {
      console.warn('无法获取地理位置信息，回退到时间基准切换', error);
      this.enableTimeBasedSwitching();
    }
  }

  /**
   * @description 获取当前位置
   */
  getCurrentPosition() {
    return new Promise((resolve, reject) => {
      if (!navigator.geolocation) {
        reject(new Error('Geolocation is not supported'));
        return;
      }

      navigator.geolocation.getCurrentPosition(resolve, reject, {
        timeout: 10000,
        maximumAge: 24 * 60 * 60 * 1000 // 24小时缓存
      });
    });
  }

  /**
   * @description 获取日出日落时间
   * @param {number} latitude - 纬度
   * @param {number} longitude - 经度
   */
  async getSunTimes(latitude, longitude) {
    // 这里可以调用第三方API获取精确的日出日落时间
    // 示例使用简化计算
    const today = new Date();
    return {
      sunrise: new Date(today.setHours(6, 0, 0, 0)),
      sunset: new Date(today.setHours(18, 0, 0, 0))
    };
  }

  /**
   * @description 根据地理位置安排主题切换
   */
  scheduleThemeByLocation(sunTimes) {
    const now = new Date();
    const { sunrise, sunset } = sunTimes;

    if (now >= sunrise && now < sunset) {
      this.applyTheme('light');
    } else {
      this.applyTheme('dark');
    }

    // 设置下次切换的定时器
    const nextSwitch = now < sunrise ? sunrise :
                      now < sunset ? sunset :
                      new Date(sunrise.getTime() + 24 * 60 * 60 * 1000);

    const timeUntilSwitch = nextSwitch.getTime() - now.getTime();

    setTimeout(() => {
      this.scheduleThemeByLocation(sunTimes);
    }, timeUntilSwitch);
  }

  /**
   * @description 清理自适应功能
   */
  destroy() {
    if (this.timeInterval) {
      clearInterval(this.timeInterval);
    }
    this.timeBasedSwitching = false;
    this.locationBasedSwitching = false;
  }
}
```

## 兼容性处理

### 1. CSS变量降级方案

```css
/* 为不支持CSS变量的浏览器提供降级方案 */
.app {
  /* 降级颜色值 */
  background-color: #ffffff;
  color: #333333;

  /* CSS变量值（会覆盖上面的值，如果支持的话） */
  background-color: var(--bg-color, #ffffff);
  color: var(--text-color, #333333);
}

/* 使用PostCSS插件自动生成降级代码 */
```

### 2. JavaScript兼容性检测

```javascript
/**
 * @description 检测浏览器特性支持
 */
class CompatibilityChecker {
  static supportsCSSVariables() {
    return window.CSS && CSS.supports && CSS.supports('color', 'var(--test)');
  }

  static supportsLocalStorage() {
    try {
      const test = 'test';
      localStorage.setItem(test, test);
      localStorage.removeItem(test);
      return true;
    } catch (e) {
      return false;
    }
  }

  static supportsMediaQueries() {
    return window.matchMedia !== undefined;
  }

  static getCompatibilityInfo() {
    return {
      cssVariables: this.supportsCSSVariables(),
      localStorage: this.supportsLocalStorage(),
      mediaQueries: this.supportsMediaQueries(),
      customEvents: typeof CustomEvent === 'function'
    };
  }
}

/**
 * @description 兼容性主题管理器
 */
class CompatibleThemeManager {
  constructor() {
    this.compatibility = CompatibilityChecker.getCompatibilityInfo();
    this.fallbackThemes = {
      light: {
        backgroundColor: '#ffffff',
        color: '#333333',
        borderColor: '#e0e0e0'
      },
      dark: {
        backgroundColor: '#121212',
        color: '#ffffff',
        borderColor: '#333333'
      }
    };

    this.init();
  }

  init() {
    if (this.compatibility.cssVariables) {
      // 使用现代CSS变量方案
      this.modernThemeManager = new ThemeManager();
    } else {
      // 使用降级方案
      this.useFallbackApproach();
    }
  }

  /**
   * @description 降级方案实现
   */
  useFallbackApproach() {
    console.warn('CSS变量不被支持，使用降级方案');

    this.currentTheme = 'light';
    this.applyFallbackTheme(this.currentTheme);
  }

  /**
   * @description 应用降级主题
   */
  applyFallbackTheme(theme) {
    const theme = this.fallbackThemes[theme];
    if (!theme) return;

    // 直接修改样式
    document.body.style.backgroundColor = theme.backgroundColor;
    document.body.style.color = theme.color;

    // 为所有相关元素应用样式
    const elements = document.querySelectorAll('.theme-element');
    elements.forEach(el => {
      Object.assign(el.style, theme);
    });

    this.currentTheme = theme;

    // 保存到localStorage（如果支持）
    if (this.compatibility.localStorage) {
      localStorage.setItem('user-theme', theme);
    }
  }

  /**
   * @description 切换主题（兼容版本）
   */
  toggleTheme() {
    if (this.compatibility.cssVariables && this.modernThemeManager) {
      this.modernThemeManager.toggleTheme();
    } else {
      const newTheme = this.currentTheme === 'light' ? 'dark' : 'light';
      this.applyFallbackTheme(newTheme);
    }
  }
}
```

## 性能优化

### 1. 防抖优化

```javascript
/**
 * @description 防抖函数
 * @param {Function} func - 要执行的函数
 * @param {number} delay - 延迟时间
 */
function debounce(func, delay) {
  let timeoutId;
  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func.apply(this, args), delay);
  };
}

/**
 * @description 优化的主题管理器
 */
class OptimizedThemeManager extends ThemeManager {
  constructor() {
    super();

    // 防抖的主题应用函数
    this.debouncedApplyTheme = debounce(this.applyTheme.bind(this), 100);

    // 批处理样式更新
    this.pendingUpdates = new Set();
    this.updateScheduled = false;
  }

  /**
   * @description 批量更新样式
   */
  batchStyleUpdate(element, styles) {
    this.pendingUpdates.add({ element, styles });

    if (!this.updateScheduled) {
      this.updateScheduled = true;

      // 使用 requestAnimationFrame 批处理更新
      requestAnimationFrame(() => {
        this.flushStyleUpdates();
      });
    }
  }

  /**
   * @description 执行批量样式更新
   */
  flushStyleUpdates() {
    this.pendingUpdates.forEach(({ element, styles }) => {
      Object.assign(element.style, styles);
    });

    this.pendingUpdates.clear();
    this.updateScheduled = false;
  }

  /**
   * @description 优化的主题应用
   */
  applyTheme(theme) {
    // 使用 CSS 类切换而不是逐个修改样式
    document.documentElement.className =
      document.documentElement.className.replace(/theme-\w+/g, '');

    if (theme !== 'light') {
      document.documentElement.classList.add(`theme-${theme}`);
    }

    // 最小化 DOM 操作
    this.currentTheme = theme;

    // 异步保存到 localStorage
    setTimeout(() => {
      localStorage.setItem(this.storageKey, theme);
    }, 0);

    // 异步触发事件
    setTimeout(() => {
      this.dispatchThemeChange(theme);
    }, 0);
  }
}
```

### 2. 内存管理

```javascript
/**
 * @description 主题资源管理器
 */
class ThemeResourceManager {
  constructor() {
    this.styleSheets = new Map();
    this.eventListeners = new WeakMap();
    this.observers = new Set();
  }

  /**
   * @description 添加主题样式表
   */
  addStyleSheet(themeName, url) {
    if (this.styleSheets.has(themeName)) {
      return this.styleSheets.get(themeName);
    }

    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = url;
    link.disabled = true; // 默认禁用

    document.head.appendChild(link);
    this.styleSheets.set(themeName, link);

    return link;
  }

  /**
   * @description 激活主题样式表
   */
  activateTheme(themeName) {
    // 禁用所有主题
    this.styleSheets.forEach(link => {
      link.disabled = true;
    });

    // 启用指定主题
    const targetSheet = this.styleSheets.get(themeName);
    if (targetSheet) {
      targetSheet.disabled = false;
    }
  }

  /**
   * @description 清理资源
   */
  destroy() {
    // 移除样式表
    this.styleSheets.forEach(link => {
      if (link.parentNode) {
        link.parentNode.removeChild(link);
      }
    });
    this.styleSheets.clear();

    // 清理观察者
    this.observers.forEach(observer => {
      if (observer.disconnect) {
        observer.disconnect();
      }
    });
    this.observers.clear();

    // 清理事件监听器
    this.eventListeners = new WeakMap();
  }
}
```

## 面试常见问题

### 1. 如何实现一键换肤功能？

**答**：
实现一键换肤功能主要有以下几种方案：

```javascript
// 1. CSS变量方案（推荐）
// 定义CSS变量
:root {
  --primary-color: #1976d2;
  --bg-color: #ffffff;
}

[data-theme="dark"] {
  --primary-color: #90caf9;
  --bg-color: #121212;
}

// JavaScript切换
function toggleTheme() {
  const currentTheme = document.documentElement.getAttribute('data-theme');
  const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

  if (newTheme === 'light') {
    document.documentElement.removeAttribute('data-theme');
  } else {
    document.documentElement.setAttribute('data-theme', newTheme);
  }

  localStorage.setItem('theme', newTheme);
}

// 2. CSS类切换方案
function switchThemeByClass(theme) {
  document.body.className = document.body.className.replace(/theme-\w+/g, '');
  document.body.classList.add(`theme-${theme}`);
}

// 3. 动态样式注入方案
function injectThemeStyles(theme) {
  const existingStyle = document.getElementById('dynamic-theme');
  if (existingStyle) {
    existingStyle.remove();
  }

  const style = document.createElement('style');
  style.id = 'dynamic-theme';
  style.textContent = getThemeCSS(theme);
  document.head.appendChild(style);
}
```

**方案对比**：

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| CSS变量 | 性能好、语法简洁、浏览器支持好 | IE不支持 | 现代浏览器项目 |
| CSS类切换 | 兼容性强、灵活度高 | CSS文件较大 | 需要兼容老浏览器 |
| 动态注入 | 最灵活、可动态生成 | 性能较差、调试困难 | 复杂自定义需求 |

### 2. 如何保持主题切换的性能？

**答**：
主题切换的性能优化主要从以下几个方面入手：

```javascript
// 1. 使用CSS变量避免大量DOM操作
// 不好的做法
function badThemeSwitch() {
  const elements = document.querySelectorAll('.theme-element');
  elements.forEach(el => {
    el.style.backgroundColor = newBgColor;
    el.style.color = newTextColor;
  });
}

// 好的做法
function goodThemeSwitch() {
  document.documentElement.style.setProperty('--bg-color', newBgColor);
  document.documentElement.style.setProperty('--text-color', newTextColor);
}

// 2. 使用防抖优化频繁切换
const debouncedThemeSwitch = debounce(applyTheme, 100);

// 3. 预加载主题资源
class ThemePreloader {
  async preloadTheme(themeName) {
    const cssUrl = `/themes/${themeName}.css`;
    const link = document.createElement('link');
    link.rel = 'preload';
    link.as = 'style';
    link.href = cssUrl;
    document.head.appendChild(link);
  }
}

// 4. 使用CSS transition优化视觉效果
.theme-transition {
  transition: background-color 0.3s ease, color 0.3s ease;
}

// 5. 批量处理样式更新
function batchStyleUpdate() {
  requestAnimationFrame(() => {
    // 在下一个动画帧中批量更新样式
    applyAllThemeStyles();
  });
}
```

**性能优化原则**：
- 减少DOM操作次数
- 使用CSS变量而非直接修改样式
- 预加载主题资源
- 使用适当的防抖策略
- 批处理样式更新

### 3. 如何处理主题切换的兼容性问题？

**答**：
主题切换的兼容性处理需要考虑多个方面：

```javascript
// 1. CSS变量兼容性检测
function supportsCSSVariables() {
  return window.CSS && CSS.supports && CSS.supports('color', 'var(--test)');
}

// 2. 降级方案实现
class CompatibleTheme {
  constructor() {
    this.useModernApproach = supportsCSSVariables();

    if (!this.useModernApproach) {
      this.fallbackThemes = {
        light: { backgroundColor: '#fff', color: '#333' },
        dark: { backgroundColor: '#333', color: '#fff' }
      };
    }
  }

  applyTheme(theme) {
    if (this.useModernApproach) {
      document.documentElement.setAttribute('data-theme', theme);
    } else {
      this.applyFallbackTheme(theme);
    }
  }

  applyFallbackTheme(theme) {
    const styles = this.fallbackThemes[theme];
    Object.assign(document.body.style, styles);

    // 为关键元素应用样式
    document.querySelectorAll('.theme-element').forEach(el => {
      Object.assign(el.style, styles);
    });
  }
}

// 3. 渐进增强策略
// 基础CSS（所有浏览器）
.app { background: #fff; color: #333; }

// 现代浏览器增强
@supports (color: var(--test)) {
  .app {
    background: var(--bg-color);
    color: var(--text-color);
  }
}

// 4. polyfill支持
if (!supportsCSSVariables()) {
  // 加载CSS变量polyfill
  loadScript('https://cdn.jsdelivr.net/npm/css-vars-ponyfill@2');
}
```

**兼容性处理策略**：
- 特性检测 + 渐进增强
- 提供降级方案
- 使用适当的polyfill
- 保证基础功能在所有浏览器中可用

### 4. 如何实现主题的持久化存储？

**答**：
主题持久化存储需要考虑多种存储方式和场景：

```javascript
// 1. localStorage存储（最常用）
class ThemeStorage {
  constructor() {
    this.storageKey = 'user-theme-preference';
    this.defaultTheme = 'light';
  }

  saveTheme(theme) {
    try {
      localStorage.setItem(this.storageKey, theme);
      return true;
    } catch (error) {
      console.warn('无法保存主题设置到localStorage:', error);
      return this.fallbackSave(theme);
    }
  }

  loadTheme() {
    try {
      return localStorage.getItem(this.storageKey) || this.getSystemPreference();
    } catch (error) {
      console.warn('无法从localStorage读取主题设置:', error);
      return this.fallbackLoad();
    }
  }

  // 2. Cookie降级方案
  fallbackSave(theme) {
    document.cookie = `${this.storageKey}=${theme}; max-age=31536000; path=/`;
  }

  fallbackLoad() {
    const match = document.cookie.match(new RegExp('(^| )' + this.storageKey + '=([^;]+)'));
    return match ? match[2] : this.getSystemPreference();
  }

  // 3. 检测系统偏好
  getSystemPreference() {
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      return 'dark';
    }
    return this.defaultTheme;
  }

  // 4. 监听系统主题变化
  watchSystemChanges(callback) {
    if (window.matchMedia) {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
      mediaQuery.addListener(callback);
      return () => mediaQuery.removeListener(callback);
    }
  }
}

// 使用示例
const themeStorage = new ThemeStorage();

// 保存主题
themeStorage.saveTheme('dark');

// 加载主题
const savedTheme = themeStorage.loadTheme();

// 监听系统变化
const unwatch = themeStorage.watchSystemChanges((e) => {
  if (!localStorage.getItem('user-theme-preference')) {
    // 只有用户没有手动设置时才跟随系统
    applyTheme(e.matches ? 'dark' : 'light');
  }
});
```

**存储策略优先级**：
1. 用户手动设置 > 系统偏好 > 默认主题
2. localStorage > Cookie > 内存存储
3. 支持系统主题变化监听
4. 提供清除设置回到默认的功能

### 5. 如何设计可扩展的主题系统？

**答**：
可扩展的主题系统需要良好的架构设计：

```javascript
// 1. 主题配置抽象
class ThemeConfig {
  constructor() {
    this.themes = new Map();
    this.variables = new Map();
  }

  // 注册主题
  registerTheme(name, config) {
    this.themes.set(name, {
      name: config.name,
      variables: config.variables,
      assets: config.assets || {},
      extends: config.extends // 支持主题继承
    });
  }

  // 注册变量
  registerVariable(name, defaultValue, description) {
    this.variables.set(name, {
      name,
      defaultValue,
      description,
      type: typeof defaultValue
    });
  }

  // 获取合并后的主题配置
  getThemeConfig(themeName) {
    const theme = this.themes.get(themeName);
    if (!theme) return null;

    let config = { ...theme };

    // 处理主题继承
    if (theme.extends) {
      const parentConfig = this.getThemeConfig(theme.extends);
      if (parentConfig) {
        config.variables = { ...parentConfig.variables, ...config.variables };
        config.assets = { ...parentConfig.assets, ...config.assets };
      }
    }

    return config;
  }
}

// 2. 插件系统
class ThemePlugin {
  constructor(name, options = {}) {
    this.name = name;
    this.options = options;
  }

  install(themeManager) {
    // 插件安装逻辑
  }

  uninstall(themeManager) {
    // 插件卸载逻辑
  }
}

// 动画插件示例
class ThemeAnimationPlugin extends ThemePlugin {
  install(themeManager) {
    themeManager.on('theme-change', (event) => {
      this.animateThemeChange(event.from, event.to);
    });
  }

  animateThemeChange(fromTheme, toTheme) {
    document.body.classList.add('theme-changing');

    setTimeout(() => {
      document.body.classList.remove('theme-changing');
    }, 300);
  }
}

// 3. 事件系统
class ThemeEventManager {
  constructor() {
    this.listeners = new Map();
  }

  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    this.listeners.get(event).add(callback);
  }

  off(event, callback) {
    if (this.listeners.has(event)) {
      this.listeners.get(event).delete(callback);
    }
  }

  emit(event, data) {
    if (this.listeners.has(event)) {
      this.listeners.get(event).forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in theme event listener:`, error);
        }
      });
    }
  }
}

// 4. 扩展的主题管理器
class ExtensibleThemeManager extends ThemeEventManager {
  constructor() {
    super();
    this.config = new ThemeConfig();
    this.plugins = new Map();
    this.currentTheme = 'light';
  }

  // 使用插件
  use(plugin) {
    if (this.plugins.has(plugin.name)) {
      console.warn(`Plugin ${plugin.name} already installed`);
      return;
    }

    plugin.install(this);
    this.plugins.set(plugin.name, plugin);
  }

  // 应用主题
  applyTheme(themeName) {
    const oldTheme = this.currentTheme;
    const themeConfig = this.config.getThemeConfig(themeName);

    if (!themeConfig) {
      console.error(`Theme ${themeName} not found`);
      return;
    }

    // 触发主题变化前事件
    this.emit('theme-change-before', {
      from: oldTheme,
      to: themeName,
      config: themeConfig
    });

    // 应用CSS变量
    Object.entries(themeConfig.variables).forEach(([key, value]) => {
      document.documentElement.style.setProperty(`--${key}`, value);
    });

    this.currentTheme = themeName;

    // 触发主题变化后事件
    this.emit('theme-change', {
      from: oldTheme,
      to: themeName,
      config: themeConfig
    });
  }

  // 创建主题
  createTheme(name, config) {
    this.config.registerTheme(name, config);
    this.emit('theme-created', { name, config });
  }
}

// 使用示例
const themeManager = new ExtensibleThemeManager();

// 注册主题
themeManager.createTheme('custom-blue', {
  name: '自定义蓝色主题',
  variables: {
    'primary-color': '#2196f3',
    'bg-color': '#f3f8ff',
    'text-color': '#1a1a1a'
  },
  extends: 'light' // 继承light主题
});

// 使用插件
themeManager.use(new ThemeAnimationPlugin());

// 监听主题变化
themeManager.on('theme-change', (event) => {
  console.log(`主题从 ${event.from} 切换到 ${event.to}`);
});
```

**可扩展设计原则**：
- 配置与实现分离
- 支持主题继承和组合
- 提供插件机制
- 事件驱动的架构
- 良好的错误处理和降级机制
