# 现代服务端渲染 (SSR)

## 基本概念

服务端渲染 (SSR) 是指在服务器上生成完整的 HTML 页面，然后将其发送到客户端的过程。现代服务端渲染通常指结合了客户端渲染和服务端渲染优点的方案，如 Next.js, Nuxt.js 等框架提供的同构渲染能力。

### 传统渲染方式对比

| 渲染方式 | 描述 | 优点 | 缺点 |
|---------|------|------|------|
| CSR (客户端渲染) | 服务器提供基础 HTML，由浏览器加载并执行 JS 渲染内容 | 交互体验好，减轻服务器压力 | 首屏加载慢，SEO 不友好 |
| SSR (服务端渲染) | 服务器生成完整 HTML 返回给浏览器 | 首屏加载快，SEO 友好 | 服务器压力大，交互体验差 |
| 同构渲染 | 结合 SSR 和 CSR，首屏服务端渲染，后续交互客户端渲染 | 兼顾首屏加载速度、SEO 和交互体验 | 开发复杂度高 |
| 静态站点生成 (SSG) | 构建时预渲染页面，生成静态 HTML | 性能最佳，可缓存，SEO 友好 | 不适合频繁更新的内容 |
| 增量静态再生成 (ISR) | SSG 的改进版，可设置内容过期和按需重新生成 | 同 SSG 优点，支持动态内容更新 | 实现复杂度较高 |

## 主流框架

### Next.js (React)

Next.js 是基于 React 的服务端渲染框架，提供了完整的开发体验。

#### 基本特性

- 内置服务端渲染
- 自动代码分割
- 基于文件系统的路由
- API 路由
- 支持静态站点生成 (SSG)
- 支持增量静态再生成 (ISR)

#### 基本用法

```jsx
// pages/index.js
import { useState } from 'react'

// 这个函数在服务端执行
export async function getServerSideProps() {
  const res = await fetch('https://api.example.com/data')
  const data = await res.json()

  return { props: { data } }
}

// 组件在服务端渲染，然后在客户端激活（水合）
export default function Home({ data }) {
  const [count, setCount] = useState(0)

  return (
    <div>
      <h1>服务端数据: {data.title}</h1>
      <button onClick={() => setCount(count + 1)}>
        点击次数: {count}
      </button>
    </div>
  )
}
```

### Nuxt.js (Vue)

Nuxt.js 是基于 Vue.js 的服务端渲染框架。

#### 基本特性

- 服务端渲染
- 自动代码分割
- 基于文件系统的路由
- 静态站点生成
- 模块化架构

#### 基本用法

```vue
<!-- pages/index.vue -->
<template>
  <div>
    <h1>{{ title }}</h1>
    <button @click="increment">点击次数: {{ count }}</button>
  </div>
</template>

<script setup>
// 服务端获取数据
const { data } = await useFetch('/api/data')
const title = data.value.title

// 客户端状态
const count = ref(0)
const increment = () => count.value++
</script>
```

### SvelteKit

SvelteKit 是基于 Svelte 的现代 Web 应用框架。

#### 基本特性

- 服务端渲染
- 静态站点生成
- 基于文件系统的路由
- 强大的适配器系统

#### 基本用法

```svelte
<!-- src/routes/index.svelte -->
<script context="module">
  export async function load({ fetch }) {
    const res = await fetch('/api/data');
    const data = await res.json();

    return {
      props: { data }
    };
  }
</script>

<script>
  export let data;
  let count = 0;
</script>

<h1>{data.title}</h1>
<button on:click={() => count++}>点击次数: {count}</button>
```

## 水合 (Hydration) 过程

水合是指在客户端接管由服务端渲染的 HTML 的过程：

1. 服务器生成 HTML 并发送到客户端
2. 浏览器解析和显示 HTML
3. 加载 JavaScript
4. JavaScript 框架"激活"DOM，使静态 HTML 变为动态、可交互的应用

## 现代 SSR 的优化技术

### 流式 SSR (Streaming SSR)

流式 SSR 允许服务器逐步将 HTML 发送给客户端，不必等待整个页面渲染完成。

```jsx
// Next.js 13+ App Router 示例
export default function Page() {
  return (
    <main>
      <h1>欢迎</h1>
      {/* 使用 Suspense 实现流式渲染 */}
      <Suspense fallback={<p>加载中...</p>}>
        <SlowComponent />
      </Suspense>
    </main>
  );
}
```

### 选择性水合 (Selective Hydration)

允许页面的不同部分按优先级水合，提升交互性能。

```jsx
// React 18+ 示例
import { startTransition } from 'react';

// 低优先级水合
startTransition(() => {
  hydrateRoot(container, <App />);
});
```

### 岛屿架构 (Islands Architecture)

只水合页面中需要交互的部分，静态内容保持不变，代表框架有 Astro。

```astro
---
// Astro 组件
import InteractiveCounter from '../components/Counter.jsx';
---

<h1>静态内容</h1>
<p>这部分不会被水合</p>

<!-- 只有这个组件会被水合 -->
<InteractiveCounter client:visible />
```

### 渐进式水合

根据用户交互逐步水合组件，代表框架有 Qwik。

```jsx
// Qwik 示例
export const Counter = component$(() => {
  const count = useSignal(0);

  return (
    <button onClick$={() => count.value++}>
      Count: {count.value}
    </button>
  );
});
```

## React 服务端组件

React 18 引入的服务端组件允许组件专门在服务器上渲染且不需水合。

```jsx
// server-component.js
'use server';

// 这个组件不会被发送到客户端，也不需要水合
export default async function ServerComponent() {
  const data = await db.query('SELECT * FROM items');

  return (
    <ul>
      {data.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}
```

## 面试常见问题

### 1. SSR、CSR、SSG 的区别是什么？

**答**：
- **CSR**：客户端渲染，服务器提供基础 HTML 和 JS，浏览器执行 JS 渲染页面内容。优点是交互体验好，缺点是首屏加载慢、SEO 不友好。
- **SSR**：服务端渲染，服务器生成完整 HTML 返回给浏览器。优点是首屏加载快、SEO 友好，缺点是服务器压力大。
- **SSG**：静态站点生成，在构建时预渲染页面生成静态 HTML。优点是性能最佳，可缓存，缺点是不适合频繁更新的内容。

### 2. SSR 的优缺点是什么？

**答**：
优点：
- 提升首屏加载速度
- 利于搜索引擎优化 (SEO)
- 更好的社交媒体分享体验
- 在低性能设备上有更好的体验

缺点：
- 增加服务器负载
- 开发复杂度提高
- 服务器渲染和客户端水合带来的性能损耗
- 需要 Node.js 环境部署

### 3. 如何处理 SSR 中的全局状态管理？

**答**：在 SSR 中处理全局状态需要特别注意服务端和客户端状态同步问题：

1. **创建新的存储实例**：每个请求应创建新的状态存储实例，避免跨请求状态污染
2. **数据预取**：在服务端预取数据并填充到状态中
3. **状态序列化**：将服务端状态序列化后发送到客户端
4. **客户端复用**：客户端使用初始状态恢复，避免重复请求

示例 (使用 Redux)：
```js
// 服务端
function handleRequest(req, res) {
  const store = createStore();
  await store.dispatch(fetchData());

  const html = renderToString(
    <Provider store={store}>
      <App />
    </Provider>
  );

  const initialState = store.getState();

  res.send(`
    <html>
      <body>
        <div id="root">${html}</div>
        <script>
          window.__INITIAL_STATE__ = ${JSON.stringify(initialState)}
        </script>
        <script src="/client.js"></script>
      </body>
    </html>
  `);
}

// 客户端
const store = createStore(
  reducer,
  window.__INITIAL_STATE__ // 使用服务端传来的状态
);

hydrate(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
);
```

### 4. 如何在 SSR 应用中处理路由？

**答**：SSR 应用中的路由需要同时适配服务端和客户端：

1. **服务端**：需要根据请求 URL 匹配对应的路由组件
2. **客户端**：需要使用前端路由库 (React Router, Vue Router) 接管页面导航

示例 (React)：
```jsx
// 服务端
import { StaticRouter } from 'react-router-dom/server';

function handleRequest(req, res) {
  const html = renderToString(
    <StaticRouter location={req.url}>
      <App />
    </StaticRouter>
  );

  res.send(`
    <html><body>
      <div id="root">${html}</div>
      <script src="/client.js"></script>
    </body></html>
  `);
}

// 客户端
import { BrowserRouter } from 'react-router-dom';

hydrate(
  <BrowserRouter>
    <App />
  </BrowserRouter>,
  document.getElementById('root')
);
```

### 5. 如何优化 SSR 应用的性能？

**答**：优化 SSR 应用性能的关键方法有：

1. **组件缓存**：缓存重复渲染的组件结果
2. **流式渲染**：使用流式 API 逐步发送 HTML
3. **数据预取优化**：并行获取数据，减少等待时间
4. **代码分割**：减少初始 JavaScript 体积
5. **服务端组件**：使用 React Server Components 等技术
6. **选择性水合**：优先水合可见区域和交互组件
7. **资源优先级提示**：使用 `<link rel="preload">` 提前加载关键资源
8. **服务器性能优化**：使用集群、负载均衡、CDN

### 6. SSR 和微前端架构如何结合？

**答**：SSR 与微前端结合主要有以下方案：

1. **基座应用 SSR + 子应用 CSR**：
   - 基座应用使用 SSR 提供框架和初始内容
   - 子应用使用 CSR 动态加载

2. **应用预渲染 + 组合**：
   - 各微应用单独 SSR 渲染
   - 服务端组合各应用 HTML 结果

3. **ESI/Edge Side Includes**：
   - 使用 ESI 标签在边缘服务器组合内容

4. **服务网格**：
   - 使用 Istio 等服务网格技术路由和组合 SSR 应用

实现挑战：
- 样式和 JavaScript 隔离
- 统一的水合策略
- 微应用间状态共享

### 7. 如何处理 SSR 中的 CSS？

**答**：SSR 中处理 CSS 的主要方法：

1. **CSS-in-JS 方案**：
   - 服务端提取样式并注入 HTML
   - 客户端接管样式处理

```jsx
// 服务端 (使用 styled-components)
import { ServerStyleSheet } from 'styled-components';

const sheet = new ServerStyleSheet();
const html = renderToString(sheet.collectStyles(<App />));
const styleTags = sheet.getStyleTags();

res.send(`
  <html>
    <head>${styleTags}</head>
    <body>
      <div id="root">${html}</div>
      <script src="/client.js"></script>
    </body>
  </html>
`);
```

2. **CSS 模块**：
   - 构建时将 CSS 模块转换为普通 CSS
   - 服务端和客户端使用相同的类名映射

3. **提取 CSS 到单独文件**：
   - 使用 mini-css-extract-plugin 等打包工具提取 CSS
   - 在 HTML 头部引入 CSS 文件

### 8. 现代 SSR 框架与传统 SSR (如 PHP、JSP) 的区别？

**答**：
1. **同构渲染**：现代 SSR 框架支持同构渲染，而传统 SSR 通常只在服务端渲染
2. **组件化**：现代 SSR 基于组件化开发，传统 SSR 多是模板拼接
3. **水合机制**：现代 SSR 有客户端水合过程，传统 SSR 需要额外的前端逻辑
4. **开发体验**：现代 SSR 提供统一的开发模型，传统 SSR 前后端分离度高
5. **性能优化**：现代 SSR 有选择性水合、流式渲染等高级优化
6. **部署要求**：现代 SSR 通常需要 Node.js 环境，传统 SSR 依赖各自的环境

### 9. React 服务端组件与传统 SSR 组件的区别？

**答**：
1. **水合过程**：服务端组件不需要水合，传统 SSR 组件需要水合
2. **客户端 JavaScript**：服务端组件不会将组件代码发送到客户端，传统 SSR 会
3. **数据获取**：服务端组件可以直接访问服务端资源，传统 SSR 通常通过 API
4. **可组合性**：服务端组件可与客户端组件混合使用
5. **更新机制**：服务端组件更新需要服务端重新渲染，而非客户端状态更新

### 10. 什么情况下应该选择 SSG 而非 SSR？

**答**：应该选择 SSG 而非 SSR 的情况：

1. **内容变化频率低**：博客、文档、产品介绍等内容不常更新
2. **用户体验至关重要**：追求最佳性能和最快加载速度
3. **高流量网站**：需要承受大量并发访问
4. **无个性化内容**：页面内容对所有用户一致
5. **部署约束**：无法提供完整的 Node.js 运行环境
6. **成本敏感**：希望通过静态托管降低服务器成本

对于需要实时数据或高度个性化的内容，SSR 或 ISR 可能是更好的选择。