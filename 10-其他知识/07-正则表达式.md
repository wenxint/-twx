# 正则表达式

> 正则表达式是一种用于匹配字符串中字符组合的模式，是前端开发中常用的文本处理工具。

## 基本概念

正则表达式(Regular Expression，简称RegExp)是用于匹配字符串中字符组合的模式。在JavaScript中，正则表达式也是对象。正则表达式通过将文本与一个模式匹配来发挥作用，在文本搜索、验证、提取和替换等场景有广泛应用。

### 创建正则表达式

JavaScript中创建正则表达式有两种方式：

```javascript
/**
 * @description 使用正则表达式字面量创建正则表达式
 * @example
 */
const regex1 = /pattern/flags;

/**
 * @description 使用RegExp构造函数创建正则表达式
 * @example
 */
const regex2 = new RegExp('pattern', 'flags');

// 使用示例
const patternLiteral = /hello/i;
const patternConstructor = new RegExp('hello', 'i');

// 测试两种方式
console.log(patternLiteral.test('Hello World'));     // true
console.log(patternConstructor.test('Hello World')); // true

// 两种方式的区别演示
const searchTerm = 'user\\w+';  // 假设这是动态获取的搜索词

// 字面量方式需要额外处理转义
const badRegex = /searchTerm/;  // 这会匹配字符串 "searchTerm"
console.log(badRegex.test('searchTerm'));      // true
console.log(badRegex.test('user123'));         // false

// 构造函数方式可以直接使用变量
const dynamicRegex = new RegExp(searchTerm);
console.log(dynamicRegex.test('searchTerm'));  // false
console.log(dynamicRegex.test('user123'));     // true

// 执行结果分析:
// 字面量方式在代码编译时就已确定，适合固定模式
// 构造函数方式在运行时构建，适合动态生成的模式
```

### 正则表达式标志(flags)

标志用于控制正则表达式的匹配行为。常用的标志包括：

```javascript
/**
 * @description 正则表达式常用标志示例
 */

// g (global): 全局匹配，查找所有匹配项
const globalRegex = /test/g;
console.log('test1 test2 test3'.match(globalRegex));
// 输出: ["test", "test", "test"]

// i (ignoreCase): 忽略大小写
const ignoreCaseRegex = /test/i;
console.log('Test'.match(ignoreCaseRegex));
// 输出: ["Test"]

// m (multiline): 多行匹配，影响 ^ 和 $
const multilineRegex = /^test/m;
console.log('line1\ntest line2'.match(multilineRegex));
// 输出: ["test"]

// s (dotAll): 允许 . 匹配换行符
const dotAllRegex = /hello.world/s;
console.log('hello\nworld'.match(dotAllRegex));
// 输出: ["hello\nworld"]

// u (unicode): 使用Unicode码点匹配
const unicodeRegex = /\u{1F60D}/u;
console.log('😍'.match(unicodeRegex));
// 输出: ["😍"]

// y (sticky): 粘性匹配，从lastIndex开始匹配
const stickyRegex = /test/y;
stickyRegex.lastIndex = 5;
console.log('0123 test'.match(stickyRegex));
// 输出: ["test"]

// 组合使用多个标志
const combinedRegex = /test/gi;
console.log('Test test TEST'.match(combinedRegex));
// 输出: ["Test", "test", "TEST"]
```

## 正则表达式语法

### 字符类

字符类用于匹配一组字符中的任意一个。

```javascript
/**
 * @description 正则表达式字符类示例
 */

// . 匹配除换行符外的任意单个字符
console.log('a1@'.match(/./g));  // ["a", "1", "@"]

// \d 匹配任意数字，等价于[0-9]
console.log('abc123xyz'.match(/\d/g));  // ["1", "2", "3"]

// \D 匹配任意非数字，等价于[^0-9]
console.log('abc123xyz'.match(/\D/g));  // ["a", "b", "c", "x", "y", "z"]

// \w 匹配任意字母、数字或下划线，等价于[A-Za-z0-9_]
console.log('abc_123$xyz'.match(/\w/g));  // ["a", "b", "c", "_", "1", "2", "3", "x", "y", "z"]

// \W 匹配任意非字母、数字或下划线，等价于[^A-Za-z0-9_]
console.log('abc_123$xyz'.match(/\W/g));  // ["$"]

// \s 匹配任意空白字符
console.log('a b\tc\nd'.match(/\s/g));  // [" ", "\t", "\n"]

// \S 匹配任意非空白字符
console.log('a b\tc'.match(/\S/g));  // ["a", "b", "c"]

// \b 匹配单词边界
console.log('word boundary'.match(/\bword\b/g));  // ["word"]

// \B 匹配非单词边界
console.log('wording'.match(/\Bord\B/g));  // ["ord"]

// 性能比较
console.time('字符类');
for (let i = 0; i < 1000000; i++) {
  /\d/.test('123');
}
console.timeEnd('字符类');

console.time('等价字符集');
for (let i = 0; i < 1000000; i++) {
  /[0-9]/.test('123');
}
console.timeEnd('等价字符集');
// 通常字符类(\d)比等价字符集([0-9])性能略好
```

| 表达式 | 描述 |
|-------|------|
| `.` | 匹配除换行符外的任意单个字符 |
| `\d` | 匹配任意数字，等价于`[0-9]` |
| `\D` | 匹配任意非数字，等价于`[^0-9]` |
| `\w` | 匹配任意字母、数字或下划线，等价于`[A-Za-z0-9_]` |
| `\W` | 匹配任意非字母、数字或下划线，等价于`[^A-Za-z0-9_]` |
| `\s` | 匹配任意空白字符，包括空格、制表符、换页符等 |
| `\S` | 匹配任意非空白字符 |
| `\b` | 匹配单词边界 |
| `\B` | 匹配非单词边界 |

### 字符集合

字符集合提供了更灵活的字符匹配方式。

```javascript
/**
 * @description 正则表达式字符集合示例
 */

// [abc] 匹配方括号中的任意字符
console.log('apple banana cherry'.match(/[abc]/g));
// ["a", "a", "a", "a", "c"]

// [^abc] 匹配除了方括号中字符的任意字符
console.log('apple banana cherry'.match(/[^abc]/g));
// ["p", "p", "l", "e", " ", "b", "n", "n", " ", "h", "e", "r", "r", "y"]

// [a-z] 匹配指定范围内的任意字符
console.log('a1B2c3'.match(/[a-z]/g));
// ["a", "c"]

// [a-zA-Z0-9] 匹配多个范围的任意字符
console.log('a1B2c3!@#'.match(/[a-zA-Z0-9]/g));
// ["a", "1", "B", "2", "c", "3"]

// 字符集合与字符类组合使用
console.log('test123'.match(/[a-z\d]/g));
// ["t", "e", "s", "t", "1", "2", "3"]

// 实际应用：验证密码是否包含特殊字符
function hasSpecialChar(password) {
  return /[^A-Za-z0-9]/.test(password);
}

console.log(hasSpecialChar('abc123'));  // false
console.log(hasSpecialChar('abc123!'));  // true

// 使用字符集合提取文本中的所有元音字母
const text = 'JavaScript is awesome!';
const vowels = text.match(/[aeiou]/gi);
console.log(vowels);  // ["a", "a", "i", "i", "a", "e", "o", "e"]
```

| 表达式 | 描述 |
|-------|------|
| `[abc]` | 匹配方括号中的任意字符 |
| `[^abc]` | 匹配除了方括号中字符的任意字符 |
| `[a-z]` | 匹配指定范围内的任意字符 |
| `[a-zA-Z0-9]` | 匹配多个范围的任意字符 |

### 量词

量词用于指定表达式匹配的次数。

```javascript
/**
 * @description 正则表达式量词示例
 */

// * 匹配前一个表达式0次或多次
console.log('aaa'.match(/a*/g));
// ["aaa", "", "", ""]

// + 匹配前一个表达式1次或多次
console.log('aaa'.match(/a+/g));
// ["aaa"]

// ? 匹配前一个表达式0次或1次
console.log('color colour'.match(/colou?r/g));
// ["color", "colour"]

// {n} 精确匹配前一个表达式n次
console.log('aaa'.match(/a{2}/g));
// ["aa"]

// {n,} 匹配前一个表达式至少n次
console.log('aaa'.match(/a{2,}/g));
// ["aaa"]

// {n,m} 匹配前一个表达式n到m次
console.log('aaa'.match(/a{1,2}/g));
// ["aa", "a"]

// 量词与字符类组合使用
const numbers = '42 555 1234 123456';

// 匹配2-3位数字
console.log(numbers.match(/\b\d{2,3}\b/g));
// ["42", "555"]

// 匹配4位及以上数字
console.log(numbers.match(/\b\d{4,}\b/g));
// ["1234", "123456"]

// 实际应用：验证手机号码（中国大陆，11位）
function isValidChinesePhone(phone) {
  return /^1[3-9]\d{9}$/.test(phone);
}

console.log(isValidChinesePhone('13812345678'));  // true
console.log(isValidChinesePhone('138123456'));    // false (位数不够)
console.log(isValidChinesePhone('23812345678'));  // false (不是1开头)

// 量词性能比较
const text = 'a'.repeat(100) + 'b';

console.time('贪婪匹配');
/a+b/.test(text);
console.timeEnd('贪婪匹配');

console.time('惰性匹配');
/a+?b/.test(text);
console.timeEnd('惰性匹配');
// 在这种情况下，贪婪匹配通常比惰性匹配更快
```

| 表达式 | 描述 |
|-------|------|
| `*` | 匹配前一个表达式0次或多次 |
| `+` | 匹配前一个表达式1次或多次 |
| `?` | 匹配前一个表达式0次或1次，即可选 |
| `{n}` | 精确匹配前一个表达式n次 |
| `{n,}` | 匹配前一个表达式至少n次 |
| `{n,m}` | 匹配前一个表达式n到m次 |

### 边界匹配

边界匹配用于指定匹配发生的位置，而不是匹配具体的字符。

```javascript
/**
 * @description 正则表达式边界匹配示例
 */

// ^ 匹配输入的开始
console.log('hello world'.match(/^hello/g));  // ["hello"]
console.log('say hello'.match(/^hello/g));    // null

// $ 匹配输入的结束
console.log('world hello'.match(/hello$/g));  // ["hello"]
console.log('hello world'.match(/hello$/g));  // null

// \b 匹配单词边界
console.log('hello world'.match(/\bhello\b/g));  // ["hello"]
console.log('helloworld'.match(/\bhello\b/g));   // null

// \B 匹配非单词边界
console.log('helloworld'.match(/\Bworld\b/g));   // ["world"]
console.log('hello world'.match(/\Bworld\b/g));  // null

// 多行模式中的边界匹配
const multilineText = `First line
Second line
Third line`;

// 不使用多行模式，只匹配整个字符串的开始
console.log(multilineText.match(/^First/g));  // ["First"]
console.log(multilineText.match(/^Second/g)); // null

// 使用多行模式，匹配每一行的开始
console.log(multilineText.match(/^First/gm));  // ["First"]
console.log(multilineText.match(/^Second/gm)); // ["Second"]

// 实际应用：提取以特定单词开头的行
function getLinesStartingWith(text, word) {
  const regex = new RegExp(`^${word}.*$`, 'gm');
  return text.match(regex) || [];
}

const logs = `Error: File not found
Info: Process started
Warning: Low memory
Error: Connection timeout`;

console.log(getLinesStartingWith(logs, 'Error'));
// ["Error: File not found", "Error: Connection timeout"]

// 边界匹配的性能优化
const longText = 'prefix' + 'a'.repeat(10000) + 'suffix';

console.time('无边界匹配');
/prefix.*suffix/.test(longText);
console.timeEnd('无边界匹配');

console.time('有边界匹配');
/^prefix.*suffix$/.test(longText);
console.timeEnd('有边界匹配');
// 使用边界匹配通常能提高性能，因为引擎可以更快确定匹配位置
```

| 表达式 | 描述 |
|-------|------|
| `^` | 匹配输入的开始 |
| `$` | 匹配输入的结束 |
| `\b` | 匹配单词边界 |
| `\B` | 匹配非单词边界 |

### 分组与引用

分组允许将正则表达式的一部分视为单个单元，便于应用量词或提取匹配内容。

```javascript
/**
 * @description 正则表达式分组与引用示例
 */

// (pattern) 捕获组
const captureRegex = /(\d{4})-(\d{2})-(\d{2})/;
const dateStr = '2023-05-15';
const dateMatch = dateStr.match(captureRegex);

console.log(dateMatch);
// ["2023-05-15", "2023", "05", "15", index: 0, input: "2023-05-15", groups: undefined]

// 通过索引访问捕获组
console.log('年份:', dateMatch[1]);  // 年份: 2023
console.log('月份:', dateMatch[2]);  // 月份: 05
console.log('日期:', dateMatch[3]);  // 日期: 15

// (?:pattern) 非捕获组
const nonCaptureRegex = /(?:\d{4})-(\d{2})-(\d{2})/;
const dateMatch2 = dateStr.match(nonCaptureRegex);

console.log(dateMatch2);
// ["2023-05-15", "05", "15", index: 0, input: "2023-05-15", groups: undefined]
// 注意第一个\d{4}不会被捕获

// \n 在正则表达式中引用前面的捕获组
const repeatWord = /(\w+)\s+\1/;
console.log('hello hello world'.match(repeatWord));
// ["hello hello", "hello", index: 0, input: "hello hello world", groups: undefined]

// 在替换字符串中引用捕获组
const swapNames = 'John Smith';
const swapped = swapNames.replace(/(\w+)\s+(\w+)/, "$2, $1");
console.log(swapped);  // Smith, John

// (?<name>pattern) 命名捕获组 (ES2018+)
const namedGroupRegex = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
const namedMatch = dateStr.match(namedGroupRegex);

console.log(namedMatch.groups);
// { year: "2023", month: "05", day: "15" }

console.log('年份:', namedMatch.groups.year);   // 年份: 2023
console.log('月份:', namedMatch.groups.month);  // 月份: 05
console.log('日期:', namedMatch.groups.day);    // 日期: 15

// 在替换字符串中引用命名捕获组
const namedSwapped = swapNames.replace(/(?<firstName>\w+)\s+(?<lastName>\w+)/, "$<lastName>, $<firstName>");
console.log(namedSwapped);  // Smith, John

// 实际应用：解析URL
function parseURL(url) {
  const urlRegex = /^(?:(?<protocol>\w+):\/\/)?(?<domain>[^\/\s]+)(?<path>\/[^\s]*)?$/;
  const match = url.match(urlRegex);

  if (match && match.groups) {
    return {
      protocol: match.groups.protocol || '',
      domain: match.groups.domain || '',
      path: match.groups.path || ''
    };
  }

  return null;
}

console.log(parseURL('https://www.example.com/path/page.html'));
// { protocol: "https", domain: "www.example.com", path: "/path/page.html" }

// 性能比较：命名捕获组 vs 索引捕获组
const url = 'https://www.example.com/path/page.html';

console.time('索引捕获组');
for (let i = 0; i < 100000; i++) {
  /^(?:(\w+):\/\/)?([^\/\s]+)(\/[^\s]*)?$/.exec(url);
}
console.timeEnd('索引捕获组');

console.time('命名捕获组');
for (let i = 0; i < 100000; i++) {
  /^(?:(?<protocol>\w+):\/\/)?(?<domain>[^\/\s]+)(?<path>\/[^\s]*)?$/.exec(url);
}
console.timeEnd('命名捕获组');
// 索引捕获组通常比命名捕获组性能略好，但命名捕获组可读性更强
```

| 表达式 | 描述 |
|-------|------|
| `(pattern)` | 捕获组，匹配括号内的表达式并将其作为一个组 |
| `(?:pattern)` | 非捕获组，匹配括号内的表达式但不记住匹配项 |
| `\n` | 在正则表达式或替换字符串中，表示第n个捕获组 |
| `(?<name>pattern)` | 命名捕获组，匹配括号内的表达式并将其作为一个具名组 |

### 贪婪与惰性匹配

默认情况下，量词是贪婪的，即尽可能多地匹配字符。惰性匹配则尽可能少地匹配字符。

```javascript
/**
 * @description 正则表达式贪婪与惰性匹配示例
 */

// 贪婪匹配示例
const greedyRegex = /<.+>/;
const htmlStr = '<div>Hello</div>';
console.log(htmlStr.match(greedyRegex));
// ["<div>Hello</div>", index: 0, input: "<div>Hello</div>", groups: undefined]
// 贪婪匹配会匹配整个字符串中的所有内容，直到最后一个>

// 惰性匹配示例
const lazyRegex = /<.+?>/;
console.log(htmlStr.match(lazyRegex));
// ["<div>", index: 0, input: "<div>Hello</div>", groups: undefined]
// 惰性匹配会在遇到第一个>时停止

// 不同量词的贪婪与惰性对比
const text = 'aaa';

console.log('* 贪婪:', text.match(/a*/));    // ["aaa", index: 0, input: "aaa", groups: undefined]
console.log('* 惰性:', text.match(/a*?/));    // ["", index: 0, input: "aaa", groups: undefined]

console.log('+ 贪婪:', text.match(/a+/));    // ["aaa", index: 0, input: "aaa", groups: undefined]
console.log('+ 惰性:', text.match(/a+?/));    // ["a", index: 0, input: "aaa", groups: undefined]

console.log('? 贪婪:', text.match(/a?/));    // ["a", index: 0, input: "aaa", groups: undefined]
console.log('? 惰性:', text.match(/a??/));    // ["", index: 0, input: "aaa", groups: undefined]

// 贪婪匹配全局模式
console.log('全局贪婪:', text.match(/a*/g));  // ["aaa", "", ""]
console.log('全局惰性:', text.match(/a*?/g)); // ["", "", "", ""]

// 实际应用：提取HTML标签
function extractHtmlTags(html) {
  // 贪婪匹配会导致错误的结果
  const greedyTags = html.match(/<.+>/g);

  // 惰性匹配能够正确提取每个标签
  const lazyTags = html.match(/<.+?>/g);

  return {
    greedy: greedyTags,
    lazy: lazyTags
  };
}

const complexHtml = '<div><p>Paragraph</p><span>Text</span></div>';
const extractedTags = extractHtmlTags(complexHtml);

console.log('贪婪匹配结果:', extractedTags.greedy);
// ["<div><p>Paragraph</p><span>Text</span></div>"]

console.log('惰性匹配结果:', extractedTags.lazy);
// ["<div>", "<p>", "</p>", "<span>", "</span>", "</div>"]

// 性能比较
const longHtml = '<div>' + 'a'.repeat(10000) + '</div>';

console.time('贪婪匹配');
/<.+>/.test(longHtml);
console.timeEnd('贪婪匹配');

console.time('惰性匹配');
/<.+?>/.test(longHtml);
console.timeEnd('惰性匹配');
// 在某些情况下，惰性匹配可能比贪婪匹配性能更好，尤其是处理大文本时
```

### 前瞻与后顾

前瞻和后顾断言用于匹配满足特定条件但又不消耗字符的模式。

```javascript
/**
 * @description 正则表达式前瞻与后顾示例
 */

// X(?=Y) 前瞻(lookahead)，匹配X仅当X后面跟着Y
const positiveAhead = /\d+(?=px)/g;
console.log('10px 20em 30px'.match(positiveAhead));
// ["10", "30"]  匹配数字，但只有当后面跟着"px"时

// X(?!Y) 负前瞻(negative lookahead)，匹配X仅当X后面不跟Y
const negativeAhead = /\d+(?!px)/g;
console.log('10px 20em 30px'.match(negativeAhead));
// ["20"]  匹配数字，但只有当后面不跟着"px"时

// (?<=Y)X 后顾(lookbehind)，匹配X仅当X前面是Y (ES2018+)
const positiveBehind = /(?<=\$)\d+/g;
console.log('$10 €20 $30'.match(positiveBehind));
// ["10", "30"]  匹配数字，但只有当前面是"$"时

// (?<!Y)X 负后顾(negative lookbehind)，匹配X仅当X前面不是Y (ES2018+)
const negativeBehind = /(?<!\$)\d+/g;
console.log('$10 €20 $30'.match(negativeBehind));
// ["20"]  匹配数字，但只有当前面不是"$"时

// 组合使用前瞻和后顾
const combined = /(?<=\$)(\d+)(?=\.\d{2})/g;
console.log('$10.99 $20.50 €30.25'.match(combined));
// ["10", "20"]  匹配美元金额的整数部分

// 实际应用：密码强度检查
function checkPasswordStrength(password) {
  const hasLowerCase = /[a-z]/.test(password);
  const hasUpperCase = /[A-Z]/.test(password);
  const hasDigit = /\d/.test(password);
  const hasSpecialChar = /[^\w\s]/.test(password);

  // 使用前瞻断言检查是否包含至少一个数字后面不跟字母
  const hasDigitNotFollowedByLetter = /\d(?![a-zA-Z])/.test(password);

  // 使用后顾断言检查是否包含大写字母前面有小写字母
  const hasUpperAfterLower = /(?<=[a-z])[A-Z]/.test(password);

  return {
    hasLowerCase,
    hasUpperCase,
    hasDigit,
    hasSpecialChar,
    hasDigitNotFollowedByLetter,
    hasUpperAfterLower,
    strength: hasLowerCase + hasUpperCase + hasDigit + hasSpecialChar
  };
}

console.log(checkPasswordStrength('Passw0rd!'));
/* 输出:
{
  hasLowerCase: true,
  hasUpperCase: true,
  hasDigit: true,
  hasSpecialChar: true,
  hasDigitNotFollowedByLetter: false,
  hasUpperAfterLower: true,
  strength: 4
}
*/

// 性能考虑：断言通常比捕获组更高效
const text = 'abc123def';

console.time('使用捕获组');
for (let i = 0; i < 100000; i++) {
  const match = text.match(/([a-z]+)(\d+)/);
  const letters = match[1];
  const numbers = match[2];
}
console.timeEnd('使用捕获组');

console.time('使用前瞻断言');
for (let i = 0; i < 100000; i++) {
  const letters = text.match(/[a-z]+(?=\d+)/)[0];
  const numbers = text.match(/(?<=[a-z]+)\d+/)[0];
}
console.timeEnd('使用前瞻断言');
// 在某些场景下，使用断言可能会有性能优势
```

| 表达式 | 描述 |
|-------|------|
| `X(?=Y)` | 前瞻(lookahead)，匹配X仅当X后面跟着Y |
| `X(?!Y)` | 负前瞻(negative lookahead)，匹配X仅当X后面不跟Y |
| `(?<=Y)X` | 后顾(lookbehind)，匹配X仅当X前面是Y |
| `(?<!Y)X` | 负后顾(negative lookbehind)，匹配X仅当X前面不是Y |
```

## JavaScript中的正则表达式方法

JavaScript提供了两类方法来使用正则表达式：RegExp对象方法和String对象方法。

### RegExp对象方法

```javascript
/**
 * @description RegExp.prototype.test() - 测试正则表达式与字符串是否匹配
 * @param {string} str - 要测试的字符串
 * @return {boolean} 如果找到匹配则返回true，否则返回false
 */
function testMethod() {
  const regex = /hello/i;

  // 基本用法
  console.log(regex.test("Hello World"));  // true
  console.log(regex.test("Hi World"));     // false

  // 全局模式下的test方法会记住上次匹配位置
  const globalRegex = /a/g;
  const str = "ababa";

  console.log(globalRegex.test(str));  // true，匹配第1个'a'
  console.log(globalRegex.lastIndex);  // 1，下一次搜索的起始位置

  console.log(globalRegex.test(str));  // true，匹配第3个'a'
  console.log(globalRegex.lastIndex);  // 3

  console.log(globalRegex.test(str));  // true，匹配第5个'a'
  console.log(globalRegex.lastIndex);  // 5

  console.log(globalRegex.test(str));  // false，没有更多匹配
  console.log(globalRegex.lastIndex);  // 0，重置为0

  // 注意：连续调用test()可能会导致意外结果
  // 重置lastIndex
  globalRegex.lastIndex = 0;
}

testMethod();

/**
 * @description RegExp.prototype.exec() - 在字符串中执行匹配
 * @param {string} str - 要搜索的字符串
 * @return {Array|null} 返回匹配对象数组或null
 */
function execMethod() {
  // 基本用法 - 捕获组
  const regex = /(\w+)\s(\w+)/;
  const str = "John Doe";
  const match = regex.exec(str);

  console.log(match);
  // ["John Doe", "John", "Doe", index: 0, input: "John Doe", groups: undefined]

  console.log(match[0]);      // "John Doe" - 完整匹配
  console.log(match[1]);      // "John" - 第一个捕获组
  console.log(match[2]);      // "Doe" - 第二个捕获组
  console.log(match.index);   // 0 - 匹配开始的位置
  console.log(match.input);   // "John Doe" - 原始字符串

  // 全局模式下的exec也会记住上次匹配位置
  const globalRegex = /(\d+)/g;
  const numbers = "123 456 789";

  let result;
  while ((result = globalRegex.exec(numbers)) !== null) {
    console.log(`找到 ${result[0]} 在位置 ${result.index}`);
  }
  // 找到 123 在位置 0
  // 找到 456 在位置 4
  // 找到 789 在位置 8

  // 命名捕获组 (ES2018+)
  const namedRegex = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
  const date = "2023-05-15";
  const dateMatch = namedRegex.exec(date);

  console.log(dateMatch.groups);              // {year: "2023", month: "05", day: "15"}
  console.log(dateMatch.groups.year);         // "2023"
  console.log(dateMatch.groups.month);        // "05"
  console.log(dateMatch.groups.day);          // "15"

  // 性能比较：test vs exec
  const simpleRegex = /\d+/;
  const testStr = "abc123def";

  console.time('test方法');
  for (let i = 0; i < 1000000; i++) {
    simpleRegex.test(testStr);
  }
  console.timeEnd('test方法');

  console.time('exec方法');
  for (let i = 0; i < 1000000; i++) {
    simpleRegex.exec(testStr);
  }
  console.timeEnd('exec方法');
  // test方法通常比exec方法快，因为它只返回布尔值而不构建匹配数组
}

execMethod();
```

### String对象方法

```javascript
/**
 * @description String.prototype.match() - 返回正则表达式在字符串中的匹配项
 * @param {RegExp} regexp - 正则表达式对象
 * @return {Array|null} 匹配结果数组或null
 */
function matchMethod() {
  // 基本用法
  const str = "The rain in SPAIN stays mainly in the plain";

  // 不使用g标志，返回第一个匹配项及详细信息
  const match1 = str.match(/ain/);
  console.log(match1);
  // ["ain", index: 5, input: "The rain in SPAIN stays mainly in the plain", groups: undefined]

  // 使用g标志，返回所有匹配项的数组
  const match2 = str.match(/ain/g);
  console.log(match2);
  // ["ain", "ain", "ain", "ain"]

  // 使用i标志（忽略大小写）
  const match3 = str.match(/ain/gi);
  console.log(match3);
  // ["ain", "AIN", "ain", "ain"]

  // 没有匹配时返回null
  const noMatch = "hello".match(/world/);
  console.log(noMatch);  // null

  // 捕获组
  const sentence = "JavaScript is awesome";
  const wordMatch = sentence.match(/(\w+)\s(is)\s(\w+)/);

  console.log(wordMatch);
  // ["JavaScript is awesome", "JavaScript", "is", "awesome", index: 0, ...]

  // String.match与RegExp.exec对比
  const globalRegex = /a(b)/g;
  const text = "ab abc abcd";

  // match返回所有匹配的字符串，不包括捕获组信息
  console.log(text.match(globalRegex));
  // ["ab", "ab", "ab"]

  // 使用exec和循环来获取捕获组信息
  let execResult;
  const allMatches = [];
  while ((execResult = globalRegex.exec(text)) !== null) {
    allMatches.push({
      full: execResult[0],
      group: execResult[1],
      index: execResult.index
    });
  }

  console.log(allMatches);
  // [
  //   { full: "ab", group: "b", index: 0 },
  //   { full: "ab", group: "b", index: 3 },
  //   { full: "ab", group: "b", index: 7 }
  // ]
}

matchMethod();

/**
 * @description String.prototype.matchAll() - 返回包含所有匹配正则表达式的结果的迭代器
 * @param {RegExp} regexp - 必须是设置了g标志的正则表达式
 * @return {Iterator} 匹配结果的迭代器
 */
function matchAllMethod() {
  // matchAll必须使用带有g标志的正则表达式
  const regex = /t(e)(st(\d?))/g;
  const str = "test1test2";

  // 使用展开语法将迭代器转换为数组
  const matches = [...str.matchAll(regex)];

  console.log(matches);
  // [
  //   ["test1", "e", "st1", "1", index: 0, input: "test1test2", groups: undefined],
  //   ["test2", "e", "st2", "2", index: 5, input: "test1test2", groups: undefined]
  // ]

  // 使用for...of遍历匹配结果
  for (const match of str.matchAll(regex)) {
    console.log(`完整匹配: ${match[0]}`);
    console.log(`第1个捕获组: ${match[1]}`);
    console.log(`第2个捕获组: ${match[2]}`);
    console.log(`第3个捕获组: ${match[3]}`);
    console.log(`匹配位置: ${match.index}`);
    console.log('---');
  }

  // 命名捕获组与matchAll
  const dateRegex = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/g;
  const dates = "Meeting on 2023-05-15 and deadline on 2023-06-30";

  for (const match of dates.matchAll(dateRegex)) {
    const { year, month, day } = match.groups;
    console.log(`年: ${year}, 月: ${month}, 日: ${day}`);
  }
  // 年: 2023, 月: 05, 日: 15
  // 年: 2023, 月: 06, 日: 30

  // matchAll与exec循环的区别
  // matchAll创建一个迭代器，不修改正则表达式的lastIndex
  const globalRegex = /\b(\w+)\b/g;
  const text = "Hello world JavaScript";

  // 使用exec循环
  const execResults = [];
  let execMatch;
  while ((execMatch = globalRegex.exec(text)) !== null) {
    execResults.push(execMatch[0]);
  }

  // 重置lastIndex
  globalRegex.lastIndex = 0;

  // 使用matchAll
  const matchAllResults = [...text.matchAll(globalRegex)].map(m => m[0]);

  console.log('exec结果:', execResults);
  // exec结果: ["Hello", "world", "JavaScript"]
  console.log('matchAll结果:', matchAllResults);
  // matchAll结果: ["Hello", "world", "JavaScript"]
}

matchAllMethod();

/**
 * @description String.prototype.replace() - 替换匹配的子字符串
 * @param {RegExp|string} pattern - 正则表达式或字符串
 * @param {string|Function} replacement - 替换字符串或函数
 * @return {string} 替换后的新字符串
 */
function replaceMethod() {
  // 基本用法 - 替换第一个匹配
  const str = "Hello world!";
  const result = str.replace(/Hello/i, "Hi");
  console.log(result);  // "Hi world!"

  // 使用g标志替换所有匹配
  const str2 = "apple, orange, apple, banana";
  const result2 = str2.replace(/apple/g, "pear");
  console.log(result2);  // "pear, orange, pear, banana"

  // 使用捕获组引用
  const name = "John Smith";
  const swapped = name.replace(/(\w+)\s(\w+)/, "$2, $1");
  console.log(swapped);  // "Smith, John"

  // 使用命名捕获组引用
  const nameWithNamed = name.replace(/(?<first>\w+)\s(?<last>\w+)/, "$<last>, $<first>");
  console.log(nameWithNamed);  // "Smith, John"

  // 使用函数作为替换参数
  const fruits = "apple, orange, APPLE, banana";

  // 替换为大写
  const upperCaseFruits = fruits.replace(/\b[a-z]+\b/g, match => match.toUpperCase());
  console.log(upperCaseFruits);  // "APPLE, ORANGE, APPLE, BANANA"

  // 替换并添加索引
  const indexedFruits = fruits.replace(/\b[a-zA-Z]+\b/g, (match, offset) => {
    return `${match}(${offset})`;
  });
  console.log(indexedFruits);  // "apple(0), orange(7), APPLE(15), banana(22)"

  // 使用捕获组和替换函数
  const dates = "2023-05-15 and 2023-06-30";
  const formattedDates = dates.replace(/(\d{4})-(\d{2})-(\d{2})/g, (match, year, month, day) => {
    return `${day}/${month}/${year}`;
  });
  console.log(formattedDates);  // "15/05/2023 and 30/06/2023"

  // 使用命名捕获组和替换函数
  const namedFormattedDates = dates.replace(/(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/g,
    (match, _p1, _p2, _p3, _offset, _string, groups) => {
      return `${groups.day}/${groups.month}/${groups.year}`;
    }
  );
  console.log(namedFormattedDates);  // "15/05/2023 and 30/06/2023"
}

replaceMethod();

/**
 * @description String.prototype.replaceAll() - 替换所有匹配的子字符串
 * @param {RegExp|string} pattern - 正则表达式必须带有g标志
 * @param {string|Function} replacement - 替换字符串或函数
 * @return {string} 替换后的新字符串
 */
function replaceAllMethod() {
  // 使用字符串模式（不需要g标志）
  const str = "Hello World, hello people";
  const result = str.replaceAll("hello", "Hi");
  console.log(result);  // "Hello World, Hi people"

  // 使用正则表达式（必须有g标志）
  const regexResult = str.replaceAll(/hello/gi, "Hi");
  console.log(regexResult);  // "Hi World, Hi people"

  // 使用替换函数
  const numbers = "12px 16px 20px";
  const doubled = numbers.replaceAll(/(\d+)px/g, (match, p1) => `${p1 * 2}px`);
  console.log(doubled);  // "24px 32px 40px"

  // replaceAll vs replace+g的区别
  // 它们主要区别在于当使用字符串作为第一个参数时:
  const withReplace = "one-two-one".replace("one", "1");     // "1-two-one"
  const withReplaceG = "one-two-one".replace(/one/g, "1");   // "1-two-1"
  const withReplaceAll = "one-two-one".replaceAll("one", "1"); // "1-two-1"

  console.log(withReplace);
  console.log(withReplaceG);
  console.log(withReplaceAll);

  // 性能比较
  const longText = "test ".repeat(10000);

  console.time('replace+g');
  longText.replace(/test/g, "TEST");
  console.timeEnd('replace+g');

  console.time('replaceAll字符串');
  longText.replaceAll("test", "TEST");
  console.timeEnd('replaceAll字符串');

  console.time('replaceAll正则');
  longText.replaceAll(/test/g, "TEST");
  console.timeEnd('replaceAll正则');
  // replaceAll在处理大量文本时可能更高效，尤其是使用字符串模式时
}

replaceAllMethod();

/**
 * @description String.prototype.search() - 搜索匹配项，返回首次匹配位置的索引
 * @param {RegExp} regexp - 正则表达式对象
 * @return {number} 匹配的索引，如果未找到匹配则返回-1
 */
function searchMethod() {
  // 基本用法
  const str = "Hello world!";
  const index = str.search(/world/i);
  console.log(index);  // 6

  // 不匹配时返回-1
  const notFound = str.search(/universe/);
  console.log(notFound);  // -1

  // search忽略g标志，始终返回第一个匹配
  const multiStr = "apple banana apple";
  console.log(multiStr.search(/apple/));   // 0
  console.log(multiStr.search(/apple/g));  // 0 (与没有g标志相同)

  // search vs indexOf:
  // search可以使用正则表达式，indexOf只能使用字符串
  console.log(str.search(/wo.ld/));        // 6
  console.log(str.indexOf("wo.ld"));       // -1 (字面匹配)

  // 性能比较
  const longText = "This is a long text. " + "a".repeat(10000) + " target";
  const simplePattern = "target";
  const regexPattern = /target/;

  console.time('indexOf');
  longText.indexOf(simplePattern);
  console.timeEnd('indexOf');

  console.time('search');
  longText.search(regexPattern);
  console.timeEnd('search');
  // 对于简单字符串匹配，indexOf通常比search快
}

searchMethod();

/**
 * @description String.prototype.split() - 使用正则表达式分割字符串
 * @param {RegExp|string} separator - 分隔符
 * @param {number} limit - 限制结果数组的长度
 * @return {Array} 分割后的字符串数组
 */
function splitMethod() {
  // 基本用法 - 按空白字符分割
  const str = "The rain in SPAIN stays mainly in the plain";
  const words = str.split(/\s+/);
  console.log(words);
  // ["The", "rain", "in", "SPAIN", "stays", "mainly", "in", "the", "plain"]

  // 使用限制参数
  const limitedWords = str.split(/\s+/, 3);
  console.log(limitedWords);
  // ["The", "rain", "in"]

  // 捕获括号将包含在结果中
  const withGroups = str.split(/(\s+)/);
  console.log(withGroups);
  // ["The", " ", "rain", " ", "in", " ", "SPAIN", ...]

  // 常见用例 - 解析CSV
  const csvLine = "John,Doe,30,\"New York, NY\"";

  // 不正确的分割方式（不处理引号中的逗号）
  const badSplit = csvLine.split(',');
  console.log(badSplit);
  // ["John", "Doe", "30", "\"New York", " NY\""]

  // 正确的分割方式（处理引号中的逗号）
  function parseCSV(text) {
    // 匹配CSV字段：未引用字段或引用字段
    const regex = /(?:^|,)(?:"([^"]*(?:""[^"]*)*)"|([^,]*))/g;
    const result = [];
    let match;

    while ((match = regex.exec(text)) !== null) {
      // 捕获组1包含引用值，捕获组2包含非引用值
      const field = match[1] !== undefined
        ? match[1].replace(/""/g, '"')  // 处理双引号转义
        : match[2];
      result.push(field);
    }

    return result;
  }

  console.log(parseCSV(csvLine));
  // ["John", "Doe", "30", "New York, NY"]

  // 性能比较：split vs 手动处理
  const longText = "word1,word2,word3,".repeat(1000);

  console.time('split');
  longText.split(',');
  console.timeEnd('split');

  console.time('手动循环');
  const result = [];
  let current = '';
  for (let i = 0; i < longText.length; i++) {
    if (longText[i] === ',') {
      result.push(current);
      current = '';
    } else {
      current += longText[i];
    }
  }
  if (current) result.push(current);
  console.timeEnd('手动循环');
  // 内置的split方法通常比手动实现更高效
}

splitMethod();
```

## 常用正则表达式示例

下面介绍一些在前端开发中常见的正则表达式应用场景和实现方式。

### 1. 验证电子邮件地址

```javascript
/**
 * @description 电子邮件地址验证正则表达式
 * 匹配格式: username@domain.tld
 */
function validateEmail() {
  // 基本版邮箱正则 - 简单但覆盖大部分常见情况
  const simpleEmailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;

  // 更复杂的邮箱正则 - 符合RFC 5322标准
  const complexEmailRegex = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;

  // 测试用例
  const emails = [
    "user@example.com",         // 有效
    "user.name@example.co.uk",  // 有效
    "user+tag@example.com",     // 有效（+标签常用于Gmail）
    "user@localhost",           // 简单版无效，复杂版有效
    "user@example",             // 无效（缺少顶级域名）
    "user@.com",                // 无效
    "user@example..com",        // 无效（连续点）
    "@example.com",             // 无效（缺少用户名）
    "user@",                    // 无效
    "user.example.com",         // 无效（缺少@）
    "user name@example.com"     // 无效（包含空格）
  ];

  console.log("=== 简单版邮箱验证 ===");
  emails.forEach(email => {
    console.log(`${email}: ${simpleEmailRegex.test(email)}`);
  });

  console.log("\n=== 复杂版邮箱验证 ===");
  emails.forEach(email => {
    console.log(`${email}: ${complexEmailRegex.test(email)}`);
  });

  // 实际应用：表单验证
  function validateEmailField(email) {
    const isValid = simpleEmailRegex.test(email);

    if (!isValid) {
      return {
        valid: false,
        message: '请输入有效的电子邮件地址'
      };
    }

    return { valid: true };
  }

  // 测试表单验证
  console.log(validateEmailField("user@example.com"));
  console.log(validateEmailField("invalid-email"));
}

validateEmail();
```

### 2. 验证手机号码（中国大陆）

```javascript
/**
 * @description 中国大陆手机号码验证正则表达式
 * 匹配格式: 1开头的11位数字，第二位为3-9
 */
function validateChinesePhone() {
  // 基本验证 - 1开头的11位数字，第二位为3-9
  const phoneRegex = /^1[3-9]\d{9}$/;

  // 带分隔符的电话号码验证（支持空格、连字符或点作为分隔符）
  const phoneWithSeparatorRegex = /^1[3-9][\d\s.-]{0,}(\d[\d\s.-]{0,}){9}$/;

  // 测试用例
  const phoneNumbers = [
    "13812345678",     // 有效
    "19912345678",     // 有效
    "1381234567",      // 无效（不足11位）
    "138123456789",    // 无效（超过11位）
    "23812345678",     // 无效（不是1开头）
    "12812345678",     // 无效（第二位不是3-9）
    "138 1234 5678",   // 基本正则无效，带分隔符正则有效
    "138-1234-5678",   // 基本正则无效，带分隔符正则有效
    "138.1234.5678"    // 基本正则无效，带分隔符正则有效
  ];

  console.log("=== 基本手机号验证 ===");
  phoneNumbers.forEach(phone => {
    console.log(`${phone}: ${phoneRegex.test(phone)}`);
  });

  console.log("\n=== 带分隔符的手机号验证 ===");
  phoneNumbers.forEach(phone => {
    console.log(`${phone}: ${phoneWithSeparatorRegex.test(phone)}`);
  });

  // 格式化手机号码
  function formatPhoneNumber(phone) {
    // 移除所有非数字字符
    const cleaned = phone.replace(/\D/g, '');

    // 检查是否是有效的11位手机号
    if (phoneRegex.test(cleaned)) {
      // 格式化为 138 1234 5678
      return cleaned.replace(/(\d{3})(\d{4})(\d{4})/, '$1 $2 $3');
    }

    return phone; // 如果不是有效号码，返回原始输入
  }

  // 测试格式化
  console.log("\n=== 格式化手机号 ===");
  console.log(formatPhoneNumber("13812345678"));    // 138 1234 5678
  console.log(formatPhoneNumber("138-1234-5678"));  // 138 1234 5678
  console.log(formatPhoneNumber("invalid"));        // invalid
}

validateChinesePhone();
```

### 3. 验证URL地址

```javascript
/**
 * @description URL地址验证正则表达式
 * 匹配格式: 标准HTTP/HTTPS URL
 */
function validateURL() {
  // 基本URL验证
  const urlRegex = /^(https?:\/\/)?([a-zA-Z0-9.-]+)\.([a-zA-Z]{2,})(\/[^\s]*)?$/;

  // 更全面的URL验证（包含端口、查询参数和锚点）
  const complexUrlRegex = /^(https?:\/\/)?(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/;

  // 测试用例
  const urls = [
    "https://www.example.com",                    // 有效
    "http://example.com",                         // 有效
    "example.com",                                // 基本正则有效
    "https://example.com/path/page.html",         // 有效
    "https://example.com/path?query=param#hash",  // 基本正则可能无效，复杂正则有效
    "https://example.com:8080",                   // 基本正则可能无效，复杂正则有效
    "https://sub.example.co.uk",                  // 有效
    "ftp://example.com",                          // 无效（不是http/https）
    "https://example",                            // 无效（无有效TLD）
    "https://.com",                               // 无效（域名缺失）
    "https://example.123",                        // 基本正则无效（TLD不是字母）
    "invalid url"                                 // 无效
  ];

  console.log("=== 基本URL验证 ===");
  urls.forEach(url => {
    console.log(`${url}: ${urlRegex.test(url)}`);
  });

  console.log("\n=== 复杂URL验证 ===");
  urls.forEach(url => {
    console.log(`${url}: ${complexUrlRegex.test(url)}`);
  });

  // URL解析函数
  function parseURL(url) {
    // 使用命名捕获组解析URL各部分
    const regex = /^(?:(?<protocol>[a-z]+):\/\/)?(?<domain>[^\/\s]+)(?<path>\/[^\s?#]*)?(?<query>\?[^#\s]*)?(?<hash>#.*)?$/i;
    const match = url.match(regex);

    if (match && match.groups) {
      return {
        protocol: match.groups.protocol || '',
        domain: match.groups.domain || '',
        path: match.groups.path || '',
        query: match.groups.query || '',
        hash: match.groups.hash || ''
      };
    }

    return null;
  }

  // 测试URL解析
  console.log("\n=== URL解析 ===");
  console.log(parseURL('https://www.example.com/path/page.html?id=123#section2'));
  // {
  //   protocol: 'https',
  //   domain: 'www.example.com',
  //   path: '/path/page.html',
  //   query: '?id=123',
  //   hash: '#section2'
  // }
}

validateURL();
```

### 4. 验证身份证号码（中国大陆，18位）

```javascript
/**
 * @description 中国大陆身份证号码（18位）验证正则表达式
 * 匹配格式: 符合GB 11643-1999标准的18位身份证号
 */
function validateIDCard() {
  // 基本身份证号码格式验证
  const idCardRegex = /^[1-9]\d{5}(19|20)\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])\d{3}(\d|X)$/i;

  // 测试用例
  const idCards = [
    "440123199001011234",    // 有效
    "44012319900101123X",    // 有效
    "44012319900101123x",    // 有效（小写x）
    "140123199002310000",    // 格式有效，但可能是无效日期（2月31日）
    "440123900101123X",      // 无效（年份不符合19/20开头）
    "44012319901313123X",    // 无效（月份13）
    "440123199001320000",    // 无效（日期32）
    "44012319900101",        // 无效（长度不足）
    "4401231990010112345",   // 无效（长度超出）
    "invalid-id"             // 无效
  ];

  console.log("=== 身份证号码验证 ===");
  idCards.forEach(id => {
    console.log(`${id}: ${idCardRegex.test(id)}`);
  });

  // 完整的身份证号码验证（包含校验码和日期有效性检查）
  function validateChineseIDCard(id) {
    // 基本格式检查
    if (!idCardRegex.test(id)) {
      return false;
    }

    // 将小写x转为大写X
    id = id.toUpperCase();

    // 检查日期有效性
    const year = parseInt(id.substr(6, 4));
    const month = parseInt(id.substr(10, 2));
    const day = parseInt(id.substr(12, 2));

    const date = new Date(year, month - 1, day);
    if (
      date.getFullYear() !== year ||
      date.getMonth() !== month - 1 ||
      date.getDate() !== day
    ) {
      return false;
    }

    // 校验码验证
    const coefficients = [7, 9, 10, 5, 8, 4, 2];
    const checkCodeMap = ['1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'];

    let sum = 0;
    for (let i = 0; i < 17; i++) {
      sum += parseInt(id.charAt(i)) * coefficients[i];
    }

    const checkCode = checkCodeMap[sum % 11];
    return checkCode === id.charAt(17);
  }

  // 测试完整验证
  console.log("\n=== 完整身份证号码验证 ===");
  console.log("440123199001011234: " + validateChineseIDCard("440123199001011234"));
  console.log("44012319900229123X: " + validateChineseIDCard("44012319900229123X"));  // 1990年有2月29日
  console.log("44012319910229123X: " + validateChineseIDCard("44012319910229123X"));  // 1991年无2月29日，返回false
}

validateIDCard();
```

### 5. 验证强密码（至少8位，包含大小写字母、数字和特殊字符）

```javascript
/**
 * @description 强密码验证正则表达式
 * 要求：至少8位，包含大小写字母、数字和特殊字符
 */
function validateStrongPassword() {
  // 使用前瞻断言验证密码组合要求
  const strongPasswordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[^\da-zA-Z]).{8,}$/;

  // 不使用前瞻断言的简化版本（可能性能更好）
  const alternativePasswordRegex = /^[A-Za-z\d\W_]{8,}$/;

  // 测试用例
  const passwords = [
    "Passw0rd!",         // 有效
    "abcDEF123!",        // 有效
    "Aa1!abcde",         // 有效
    "password",          // 无效（缺少大写字母、数字和特殊字符）
    "Password",          // 无效（缺少数字和特殊字符）
    "Password1",         // 无效（缺少特殊字符）
    "password!",         // 无效（缺少大写字母和数字）
    "Pass1!",            // 无效（长度不足8位）
    "PASS1234!",         // 无效（缺少小写字母）
    "pass1234!"          // 无效（缺少大写字母）
  ];

  console.log("=== 强密码验证 ===");
  passwords.forEach(password => {
    console.log(`${password}: ${strongPasswordRegex.test(password)}`);
  });

  // 密码强度检查函数
  function checkPasswordStrength(password) {
    const rules = [
      { regex: /.{8,}/, description: "至少8个字符" },
      { regex: /[A-Z]/, description: "至少1个大写字母" },
      { regex: /[a-z]/, description: "至少1个小写字母" },
      { regex: /\d/, description: "至少1个数字" },
      { regex: /[^\da-zA-Z]/, description: "至少1个特殊字符" }
    ];

    // 检查每条规则
    const result = {
      valid: true,
      failedRules: [],
      strength: 0
    };

    rules.forEach(rule => {
      if (!rule.regex.test(password)) {
        result.valid = false;
        result.failedRules.push(rule.description);
      } else {
        result.strength++;
      }
    });

    // 添加强度评级
    if (result.strength <= 2) {
      result.rating = "弱";
    } else if (result.strength <= 4) {
      result.rating = "中";
    } else {
      result.rating = "强";
    }

    return result;
  }

  // 测试密码强度检查
  console.log("\n=== 密码强度检查 ===");
  console.log("Passw0rd!:", checkPasswordStrength("Passw0rd!"));
  console.log("password:", checkPasswordStrength("password"));
  console.log("Password1:", checkPasswordStrength("Password1"));
}

validateStrongPassword();
```

### 6. 提取HTML标签

```javascript
/**
 * @description HTML标签提取正则表达式
 * 匹配HTML标签及其属性和内容
 */
function extractHtmlTags() {
  const html = "<div class='container'><p>This is a paragraph.</p><span id='highlight'>Important text</span></div>";

  // 匹配HTML标签（不嵌套）
  const simpleTagRegex = /<([a-zA-Z0-9]+)([^>]*)>(.*?)<\/\1>/g;

  // 仅匹配开始标签和属性
  const openTagRegex = /<([a-zA-Z0-9]+)([^>]*)>/g;

  // 仅提取标签名
  const tagNameRegex = /<\/?([a-zA-Z0-9]+)[^>]*>/g;

  // 提取属性
  const attributeRegex = /([a-zA-Z0-9-]+)=['"]([^'"]*)['"]/g;

  // 使用matchAll获取所有匹配的标签
  console.log("=== 提取HTML标签（不嵌套） ===");
  const matches = [...html.matchAll(simpleTagRegex)];
  matches.forEach(match => {
    console.log("完整匹配:", match[0]);
    console.log("标签名:", match[1]);
    console.log("属性:", match[2]);
    console.log("内容:", match[3]);
    console.log("---");
  });

  // 提取所有开始标签
  console.log("\n=== 提取开始标签 ===");
  const openTags = [...html.matchAll(openTagRegex)];
  openTags.forEach(match => {
    console.log("标签:", match[1], "属性:", match[2]);
  });

  // 提取所有标签名
  console.log("\n=== 提取所有标签名 ===");
  const tagMatches = [...html.matchAll(tagNameRegex)];
  tagMatches.forEach(match => {
    console.log(match[0], "->", match[1]);
  });

  // 提取特定标签的属性
  function extractAttributes(tagString) {
    const attributes = {};
    let match;

    while ((match = attributeRegex.exec(tagString)) !== null) {
      attributes[match[1]] = match[2];
    }

    return attributes;
  }

  // 测试提取属性
  console.log("\n=== 提取属性 ===");
  const divTag = "<div class='container' id='main' data-value='123'>";
  console.log(extractAttributes(divTag));
  // { class: 'container', id: 'main', 'data-value': '123' }

  // 实际应用：简易HTML解析器
  function parseHTML(html) {
    const result = [];
    const tagStack = [];

    // 匹配开始标签、结束标签和文本内容
    const regex = /<([a-zA-Z0-9]+)([^>]*)>|<\/([a-zA-Z0-9]+)>|([^<]+)/g;

    let match;
    while ((match = regex.exec(html)) !== null) {
      if (match[1]) {
        // 开始标签
        const tag = {
          type: 'tag',
          name: match[1],
          attributes: extractAttributes(match[2]),
          children: []
        };

        if (tagStack.length > 0) {
          tagStack[tagStack.length - 1].children.push(tag);
        } else {
          result.push(tag);
        }

        tagStack.push(tag);
      } else if (match[3]) {
        // 结束标签
        if (tagStack.length > 0 && tagStack[tagStack.length - 1].name === match[3]) {
          tagStack.pop();
        }
      } else if (match[4]) {
        // 文本内容
        const text = match[4].trim();
        if (text && tagStack.length > 0) {
          tagStack[tagStack.length - 1].children.push({
            type: 'text',
            content: text
          });
        }
      }
    }

    return result;
  }

  // 测试HTML解析
  console.log("\n=== 简易HTML解析 ===");
  const simpleHtml = "<div><p>Hello</p><span>World</span></div>";
  console.log(JSON.stringify(parseHTML(simpleHtml), null, 2));
}

extractHtmlTags();
```

### 7. 解析URL查询参数

```javascript
/**
 * @description URL查询参数解析函数
 * @param {string} url - 要解析的URL字符串
 * @return {Object} 包含所有查询参数的对象
 */
function getQueryParams(url) {
  const queryString = url.split('?')[1] || '';
  const paramRegex = /([^&=]+)=?([^&]*)/g;
  const params = {};
  let match;

  while ((match = paramRegex.exec(queryString)) !== null) {
    const key = decodeURIComponent(match[1]);
    const value = decodeURIComponent(match[2]);

    // 处理数组参数 (例如: color=red&color=blue)
    if (params[key] !== undefined) {
      if (!Array.isArray(params[key])) {
        params[key] = [params[key]];
      }
      params[key].push(value);
    } else {
      params[key] = value;
    }
  }

  return params;
}

// 测试
const urls = [
  "https://example.com/search?q=test&page=1&filter=recent",
  "https://example.com/path?id=123&name=John+Doe&enabled=true",
  "https://example.com/products?category=books&sort=price&order=asc",
  "https://example.com/tags?tag=javascript&tag=regex&tag=tutorial",
  "https://example.com/search?q=特殊%20字符&lang=zh-CN"
];

console.log("=== URL查询参数解析 ===");
urls.forEach(url => {
  console.log(`URL: ${url}`);
  console.log("解析结果:", getQueryParams(url));
  console.log("---");
});

// 更完整的URL解析函数
function parseCompleteURL(url) {
  try {
    // 使用URL API进行解析（现代浏览器支持）
    const urlObj = new URL(url);
    const result = {
      protocol: urlObj.protocol.replace(':', ''),
      host: urlObj.host,
      hostname: urlObj.hostname,
      port: urlObj.port,
      pathname: urlObj.pathname,
      search: urlObj.search,
      hash: urlObj.hash,
      params: {}
    };

    // 解析查询参数
    for (const [key, value] of urlObj.searchParams) {
      if (result.params[key] !== undefined) {
        if (!Array.isArray(result.params[key])) {
          result.params[key] = [result.params[key]];
        }
        result.params[key].push(value);
      } else {
        result.params[key] = value;
      }
    }

    return result;
  } catch (e) {
    // 回退到正则表达式解析
    const regex = /^(?:([^:/?#]+):)?(?:\/\/([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/;
    const match = url.match(regex);

    if (!match) return null;

    const result = {
      protocol: match[1] || '',
      host: match[2] || '',
      pathname: match[3] || '',
      search: match[4] ? `?${match[4]}` : '',
      hash: match[5] ? `#${match[5]}` : '',
      params: getQueryParams(url)
    };

    // 解析主机部分
    const hostParts = result.host.split(':');
    result.hostname = hostParts[0];
    result.port = hostParts[1] || '';

    return result;
  }
}

// 测试完整URL解析
console.log("\n=== 完整URL解析 ===");
console.log(parseCompleteURL("https://user:pass@www.example.com:8080/path/to/page?id=123&q=test#section"));

// 性能比较：正则解析 vs URL API
const testUrl = "https://example.com/search?q=test&page=1&filter=recent&sort=date&order=desc";

console.time('正则解析');
for (let i = 0; i < 10000; i++) {
  getQueryParams(testUrl);
}
console.timeEnd('正则解析');

console.time('URL API');
for (let i = 0; i < 10000; i++) {
  try {
    const urlObj = new URL(testUrl);
    const params = {};
    for (const [key, value] of urlObj.searchParams) {
      params[key] = value;
    }
  } catch (e) {}
}
console.timeEnd('URL API');
// URL API通常比正则表达式解析更快，但可能不支持所有环境