# 正则表达式

## 基本概念

正则表达式(Regular Expression，简称RegExp)是用于匹配字符串中字符组合的模式。在JavaScript中，正则表达式也是对象。

### 创建正则表达式

JavaScript中创建正则表达式有两种方式：

```javascript
// 方式一：使用正则表达式字面量
const regex1 = /pattern/flags;

// 方式二：使用RegExp构造函数
const regex2 = new RegExp('pattern', 'flags');
```

### 正则表达式标志(flags)

常用的标志包括：

- `g` (global): 全局匹配，查找所有匹配项
- `i` (ignoreCase): 忽略大小写
- `m` (multiline): 多行匹配
- `s` (dotAll): 允许 `.` 匹配换行符
- `u` (unicode): 使用Unicode码点匹配
- `y` (sticky): 粘性匹配，从lastIndex开始匹配

```javascript
// 全局忽略大小写匹配
const regex = /pattern/gi;
```

## 正则表达式语法

### 字符类

| 表达式 | 描述 |
|-------|------|
| `.` | 匹配除换行符外的任意单个字符 |
| `\d` | 匹配任意数字，等价于`[0-9]` |
| `\D` | 匹配任意非数字，等价于`[^0-9]` |
| `\w` | 匹配任意字母、数字或下划线，等价于`[A-Za-z0-9_]` |
| `\W` | 匹配任意非字母、数字或下划线，等价于`[^A-Za-z0-9_]` |
| `\s` | 匹配任意空白字符，包括空格、制表符、换页符等 |
| `\S` | 匹配任意非空白字符 |
| `\b` | 匹配单词边界 |
| `\B` | 匹配非单词边界 |

### 字符集合

| 表达式 | 描述 |
|-------|------|
| `[abc]` | 匹配方括号中的任意字符 |
| `[^abc]` | 匹配除了方括号中字符的任意字符 |
| `[a-z]` | 匹配指定范围内的任意字符 |
| `[a-zA-Z0-9]` | 匹配多个范围的任意字符 |

### 量词

| 表达式 | 描述 |
|-------|------|
| `*` | 匹配前一个表达式0次或多次 |
| `+` | 匹配前一个表达式1次或多次 |
| `?` | 匹配前一个表达式0次或1次，即可选 |
| `{n}` | 精确匹配前一个表达式n次 |
| `{n,}` | 匹配前一个表达式至少n次 |
| `{n,m}` | 匹配前一个表达式n到m次 |

### 边界匹配

| 表达式 | 描述 |
|-------|------|
| `^` | 匹配输入的开始 |
| `$` | 匹配输入的结束 |
| `\b` | 匹配单词边界 |
| `\B` | 匹配非单词边界 |

### 分组与引用

| 表达式 | 描述 |
|-------|------|
| `(pattern)` | 捕获组，匹配括号内的表达式并将其作为一个组 |
| `(?:pattern)` | 非捕获组，匹配括号内的表达式但不记住匹配项 |
| `\n` | 在正则表达式或替换字符串中，表示第n个捕获组 |
| `(?<name>pattern)` | 命名捕获组，匹配括号内的表达式并将其作为一个具名组 |

### 贪婪与惰性匹配

默认情况下，量词是贪婪的，即尽可能多地匹配字符：

```javascript
// 贪婪匹配，将匹配 "aaa"
"aaa".match(/a+/);

// 惰性匹配，将匹配 "a"
"aaa".match(/a+?/);
```

在量词后面加上`?`表示惰性匹配，即尽可能少地匹配字符。

### 前瞻与后顾

| 表达式 | 描述 |
|-------|------|
| `X(?=Y)` | 前瞻(lookahead)，匹配X仅当X后面跟着Y |
| `X(?!Y)` | 负前瞻(negative lookahead)，匹配X仅当X后面不跟Y |
| `(?<=Y)X` | 后顾(lookbehind)，匹配X仅当X前面是Y |
| `(?<!Y)X` | 负后顾(negative lookbehind)，匹配X仅当X前面不是Y |

## JavaScript中的正则表达式方法

### RegExp对象方法

1. **test()**: 测试正则表达式与字符串是否匹配，返回布尔值

```javascript
const regex = /hello/i;
console.log(regex.test("Hello World")); // true
```

2. **exec()**: 在字符串中执行匹配，返回匹配对象数组或null

```javascript
const regex = /(\w+)\s(\w+)/;
const str = "John Doe";
const match = regex.exec(str);
console.log(match);
// ["John Doe", "John", "Doe", index: 0, input: "John Doe", groups: undefined]
```

### String对象方法

1. **match()**: 返回正则表达式在字符串中的匹配项

```javascript
const str = "The rain in SPAIN stays mainly in the plain";
const matches = str.match(/ain/gi);
console.log(matches); // ["ain", "AIN", "ain", "ain"]
```

2. **matchAll()**: 返回包含所有匹配正则表达式的结果的迭代器

```javascript
const regex = /t(e)(st(\d?))/g;
const str = "test1test2";
const matches = [...str.matchAll(regex)];
console.log(matches);
// [
//   ["test1", "e", "st1", "1", index: 0, input: "test1test2", groups: undefined],
//   ["test2", "e", "st2", "2", index: 5, input: "test1test2", groups: undefined]
// ]
```

3. **replace()**: 替换匹配的子字符串

```javascript
const str = "Hello world!";
const result = str.replace(/Hello/i, "Hi");
console.log(result); // "Hi world!"
```

4. **replaceAll()**: 替换所有匹配的子字符串

```javascript
const str = "Hello World, hello people";
const result = str.replaceAll(/hello/gi, "Hi");
console.log(result); // "Hi World, Hi people"
```

5. **search()**: 搜索匹配项，返回首次匹配位置的索引

```javascript
const str = "Hello world!";
const index = str.search(/world/i);
console.log(index); // 6
```

6. **split()**: 使用正则表达式分割字符串

```javascript
const str = "The rain in SPAIN stays mainly in the plain";
const words = str.split(/\s+/);
console.log(words);
// ["The", "rain", "in", "SPAIN", "stays", "mainly", "in", "the", "plain"]
```

## 常用正则表达式示例

### 1. 验证电子邮件地址

```javascript
const emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;

// 测试
console.log(emailRegex.test("user@example.com")); // true
console.log(emailRegex.test("invalid-email")); // false
```

### 2. 验证手机号码（中国大陆）

```javascript
const phoneRegex = /^1[3-9]\d{9}$/;

// 测试
console.log(phoneRegex.test("13812345678")); // true
console.log(phoneRegex.test("23812345678")); // false
```

### 3. 验证URL地址

```javascript
const urlRegex = /^(https?:\/\/)?([a-zA-Z0-9.-]+)\.([a-zA-Z]{2,})(\/[^\s]*)?$/;

// 测试
console.log(urlRegex.test("https://www.example.com")); // true
console.log(urlRegex.test("example.com")); // true
console.log(urlRegex.test("invalid url")); // false
```

### 4. 验证身份证号码（中国大陆，18位）

```javascript
const idCardRegex = /^[1-9]\d{5}(19|20)\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])\d{3}(\d|X)$/i;

// 测试
console.log(idCardRegex.test("440123199001011234")); // true
console.log(idCardRegex.test("44012319900101123X")); // true
console.log(idCardRegex.test("invalid-id")); // false
```

### 5. 验证强密码（至少8位，包含大小写字母、数字和特殊字符）

```javascript
const strongPasswordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[^\da-zA-Z]).{8,}$/;

// 测试
console.log(strongPasswordRegex.test("Passw0rd!")); // true
console.log(strongPasswordRegex.test("password")); // false
```

### 6. 提取HTML标签

```javascript
const html = "<div class='container'><p>This is a paragraph.</p></div>";
const tagRegex = /<([a-zA-Z0-9]+)([^>]*)>([\s\S]*?)<\/\1>/g;

const matches = [...html.matchAll(tagRegex)];
console.log(matches);
// 输出匹配到的标签、属性和内容
```

### 7. 解析URL查询参数

```javascript
function getQueryParams(url) {
  const queryString = url.split('?')[1] || '';
  const paramRegex = /([^&=]+)=?([^&]*)/g;
  const params = {};
  let match;

  while (match = paramRegex.exec(queryString)) {
    params[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);
  }

  return params;
}

// 测试
const url = "https://example.com/search?q=test&page=1&filter=recent";
console.log(getQueryParams(url));
// { q: "test", page: "1", filter: "recent" }
```

## 实际应用场景

### 1. 表单验证

```javascript
function validateForm() {
  const email = document.getElementById('email').value;
  const password = document.getElementById('password').value;

  const emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
  const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$/;

  if (!emailRegex.test(email)) {
    alert('请输入有效的电子邮件地址');
    return false;
  }

  if (!passwordRegex.test(password)) {
    alert('密码必须至少包含8个字符，包括大小写字母和数字');
    return false;
  }

  return true;
}
```

### 2. 数据格式化

```javascript
// 格式化电话号码：(123) 456-7890
function formatPhoneNumber(phoneNumber) {
  const cleaned = phoneNumber.replace(/\D/g, '');
  const match = cleaned.match(/^(\d{3})(\d{3})(\d{4})$/);

  if (match) {
    return `(${match[1]}) ${match[2]}-${match[3]}`;
  }

  return phoneNumber;
}

// 测试
console.log(formatPhoneNumber("1234567890")); // "(123) 456-7890"
```

### 3. 富文本编辑器语法高亮

```javascript
function highlightSyntax(code) {
  // 突出显示JavaScript关键字
  let highlighted = code.replace(
    /\b(const|let|var|function|return|if|else|for|while)\b/g,
    '<span class="keyword">$1</span>'
  );

  // 突出显示字符串
  highlighted = highlighted.replace(
    /(["'])(.*?)\1/g,
    '<span class="string">$1$2$1</span>'
  );

  // 突出显示注释
  highlighted = highlighted.replace(
    /(\/\/.*$|\/\*[\s\S]*?\*\/)/gm,
    '<span class="comment">$1</span>'
  );

  return highlighted;
}
```

### 4. 输入限制与自动格式化

```javascript
// 限制文本框只能输入数字
document.getElementById('number-only').addEventListener('input', function(e) {
  e.target.value = e.target.value.replace(/[^\d]/g, '');
});

// 自动格式化信用卡号码（分组为4位）
document.getElementById('credit-card').addEventListener('input', function(e) {
  let value = e.target.value.replace(/\D/g, '');
  // 保留最多16位数字
  value = value.substring(0, 16);
  // 分组为4位数字
  value = value.replace(/(\d{4})(?=\d)/g, '$1 ');
  e.target.value = value;
});
```

### 5. 字符串解析和替换

```javascript
// 将文本中的URL转换为可点击的链接
function linkify(text) {
  const urlRegex = /(https?:\/\/[^\s]+)/g;
  return text.replace(urlRegex, '<a href="$1" target="_blank">$1</a>');
}

// 测试
const text = "查看这个网站 https://example.com 获取更多信息。";
console.log(linkify(text));
// "查看这个网站 <a href="https://example.com" target="_blank">https://example.com</a> 获取更多信息。"
```

## 正则表达式性能优化

1. **避免回溯陷阱**：过度使用量词（如 `.*`）可能导致灾难性回溯
2. **使用非捕获组**：当不需要捕获结果时，使用 `(?:pattern)` 替代 `(pattern)`
3. **合理使用字符类**：比如用 `\d` 代替 `[0-9]`
4. **起始/结束锚点**：在适当情况下使用 `^` 和 `$` 限定匹配范围
5. **预编译正则**：避免在循环中重复创建相同的正则表达式对象

```javascript
// 避免在循环中创建正则
const emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;

function validateEmails(emails) {
  return emails.filter(email => emailRegex.test(email));
}
```

## 常见面试问题

### 1. 解释一下贪婪匹配和惰性匹配的区别？

**答案**：
贪婪匹配会尽可能多地匹配字符，而惰性匹配则尽可能少地匹配字符。

在正则表达式中，量词（如 `*`, `+`, `?`, `{n,m}`）默认采用贪婪模式。要使用惰性模式，需在量词后添加 `?`。

例如，对于字符串 `"<div>Hello</div><div>World</div>"`：
- 使用贪婪匹配 `/<div>.*<\/div>/` 会匹配整个字符串
- 使用惰性匹配 `/<div>.*?<\/div>/` 会分别匹配 `"<div>Hello</div>"` 和 `"<div>World</div>"`

### 2. 如何实现一个简单的URL解析器，获取其中的协议、域名和路径？

**答案**：

```javascript
function parseURL(url) {
  const regex = /^(?:([a-z]+):\/\/)?([^\/\s]+)([\/\w\-\.]+)?$/i;
  const match = url.match(regex);

  if (match) {
    return {
      protocol: match[1] || '',
      domain: match[2] || '',
      path: match[3] || ''
    };
  }

  return null;
}

// 测试
console.log(parseURL('https://www.example.com/path/page.html'));
// { protocol: 'https', domain: 'www.example.com', path: '/path/page.html' }
```

### 3. 什么是先行断言和后行断言？有什么用途？

**答案**：
先行断言(lookahead)和后行断言(lookbehind)是用来匹配满足特定条件但又不消耗字符的模式：

- **先行断言**：`X(?=Y)` 匹配X，但仅当X后面跟着Y时
- **负先行断言**：`X(?!Y)` 匹配X，但仅当X后面不是Y时
- **后行断言**：`(?<=Y)X` 匹配X，但仅当X前面是Y时
- **负后行断言**：`(?<!Y)X` 匹配X，但仅当X前面不是Y时

用途举例：
1. 匹配密码中的数字，但不匹配后面跟着字母的数字：`\d+(?![a-zA-Z])`
2. 匹配美元金额：`(?<=\$)\d+(\.\d{2})?`
3. 匹配不在HTML标签内的内容：`(?<=>)[^<>]+(?=<)`

### 4. 如何使用正则表达式匹配包含中文字符的字符串？

**答案**：
在JavaScript中，可以使用Unicode属性转义来匹配中文字符：

```javascript
// 匹配包含中文字符的字符串
const containsChineseRegex = /[\u4e00-\u9fa5]/;

// 匹配全中文字符串
const allChineseRegex = /^[\u4e00-\u9fa5]+$/;

// 测试
console.log(containsChineseRegex.test("Hello世界")); // true
console.log(allChineseRegex.test("你好世界")); // true
console.log(allChineseRegex.test("Hello世界")); // false
```

在ES2018及以后，也可以使用：

```javascript
const containsChineseRegex = /\p{Script=Han}/u;
const allChineseRegex = /^\p{Script=Han}+$/u;
```

### 5. 如何在正则表达式中匹配特殊字符？

**答案**：
要匹配特殊字符（如 `^ $ . * + ? ( ) [ ] { } | \ /`），需要使用反斜杠 `\` 进行转义：

```javascript
// 匹配包含问号的字符串
const questionMarkRegex = /\?/;
console.log(questionMarkRegex.test("What?")); // true

// 匹配包含圆点的字符串
const dotRegex = /\./;
console.log(dotRegex.test("www.example.com")); // true

// 如果需要匹配多个特殊字符，可以将它们放在字符类中
const specialCharsRegex = /[\^$.*+?()[\]{}|\\]/;
```

在构造函数中创建正则表达式时，需要额外转义反斜杠：

```javascript
const dotRegex = new RegExp("\\.");
console.log(dotRegex.test("www.example.com")); // true
```