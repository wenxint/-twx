# 算法复杂度

## 概念介绍

算法复杂度是衡量算法执行效率的重要指标，主要分为**时间复杂度**和**空间复杂度**：

- **时间复杂度**：表示算法执行时间随输入规模增长的变化趋势，不关注具体时间（受硬件影响），而是关注操作次数的增长规律。
- **空间复杂度**：表示算法执行过程中所需内存空间随输入规模增长的变化趋势，包括输入数据、临时变量、递归栈等占用的空间。

## 核心特性

### 大O表示法
大O表示法（Big O Notation）是描述复杂度的标准方式，定义为：当输入规模n趋近于无穷大时，算法时间/空间复杂度的上界。

**数学定义**：若存在正常数c和n₀，使得对于所有n≥n₀，有f(n) ≤ c·g(n)，则记f(n) = O(g(n))。

### 常见复杂度类型
| 复杂度       | 名称         | 典型场景                  | 增长趋势（n→∞） |
|--------------|--------------|---------------------------|-----------------|
| O(1)         | 常数复杂度   | 数组随机访问、哈希查找     | 无增长          |
| O(log n)     | 对数复杂度   | 二分查找、平衡树操作       | 极缓慢增长      |
| O(n)         | 线性复杂度   | 数组遍历、单循环操作       | 线性增长        |
| O(n log n)   | 线性对数复杂度 | 快速排序、归并排序         | 中等增长        |
| O(n²)        | 平方复杂度   | 冒泡排序、双重循环嵌套     | 快速增长        |
| O(2ⁿ)        | 指数复杂度   | 斐波那契递归（未优化）     | 爆炸式增长      |

## 实战案例

### 案例1：数组遍历的时间复杂度
```javascript
function traverseArray(arr) {
  for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]); // 单循环操作
  }
}
```
- **时间复杂度**：O(n)（n为数组长度，每个元素访问一次）
- **空间复杂度**：O(1)（仅使用固定大小的临时变量i）

### 案例2：冒泡排序的时间复杂度
```javascript
function bubbleSort(arr) {
  const n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // 交换操作
      }
    }
  }
  return arr;
}
```
- **时间复杂度**：
  - 最坏情况（逆序）：O(n²)（双重循环总次数≈n²/2）
  - 最好情况（已排序）：O(n)（优化后仅需一次外层循环）
- **空间复杂度**：O(1)（原地排序，无额外空间）

### 案例4：快速排序的复杂度分析

#### 代码实现
```javascript
/**
 * @description 快速排序算法
 * @param {number[]} arr - 待排序数组
 * @return {number[]} 排序后的数组
 */
function quickSort(arr) {
  if (arr.length <= 1) return arr;
  const pivot = arr[Math.floor(arr.length / 2)];
  const left = [];
  const middle = [];
  const right = [];
  for (const num of arr) {
    if (num < pivot) left.push(num);
    else if (num === pivot) middle.push(num);
    else right.push(num);
  }
  return [...quickSort(left), ...middle, ...quickSort(right)];
}
```

#### 复杂度分析
- **时间复杂度**：
  - 最好情况（每次分区平衡）：O(n log n)，递归深度为log n，每层处理n个元素。
  - 平均情况：O(n log n)，基于概率的期望复杂度。
  - 最坏情况（数组已排序，每次选最大/最小元素为基准）：O(n²)，递归深度为n，每层处理n个元素。
- **空间复杂度**：O(log n)（递归栈空间，平衡分区时）；最坏情况O(n)（非平衡分区时）。

### 案例5：斐波那契递归的指数复杂度分析

#### 基础递归实现
```javascript
/**
 * @description 斐波那契数列（未优化递归版）
 * @param {number} n - 第n项
 * @return {number} 第n项的值
 */
function fibonacci(n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}
```

#### 复杂度分析
斐波那契递归的时间复杂度为O(2ⁿ)，其增长规律可通过递归树观察：
- 每个节点产生2个子节点（调用fib(n-1)和fib(n-2)）。
- 树的高度为n，总节点数约为2ⁿ（实际为斐波那契数列本身，渐近于O(2ⁿ)）。

#### 优化方向
通过动态规划（记忆化搜索或迭代）可将时间复杂度优化至O(n)，空间复杂度优化至O(1)（迭代版）。例如：
```javascript
// 记忆化搜索优化
const memo = [0, 1];
function fibonacciOptimized(n) {
  if (memo[n] !== undefined) return memo[n];
  memo[n] = fibonacciOptimized(n - 1) + fibonacciOptimized(n - 2);
  return memo[n];
}
```

## 面试常见问题

### 问题1：如何区分时间复杂度的最优、平均和最坏情况？
**解答**：
- 最优情况：输入数据对算法最有利时的复杂度（如冒泡排序中数组已排序，复杂度O(n)）。
- 最坏情况：输入数据对算法最不利时的复杂度（如冒泡排序中数组逆序，复杂度O(n²)）。
- 平均情况：所有可能输入的复杂度期望值（需结合概率分布计算，如快速排序平均复杂度O(n log n)）。

### 问题2：空间复杂度是否包括输入数据本身？
**解答**：
通常空间复杂度仅计算算法运行过程中**额外占用**的空间，输入数据本身的空间不计入（除非题目特别说明）。例如，计算一个数组的和时，输入数组的空间不算，仅计算临时变量的空间（O(1)）。

### 问题3：递归算法的空间复杂度如何计算？
**解答**：
递归算法的空间复杂度主要由**递归栈深度**决定。例如，计算n的阶乘的递归函数：
```javascript
function factorial(n) {
  if (n === 0) return 1;
  return n * factorial(n - 1); // 递归调用栈深度为n
}
```
其空间复杂度为O(n)（递归栈最多保存n层调用）。

## 扩展思考

1. 为什么快速排序的平均复杂度是O(n log n)，而最坏情况是O(n²)？如何避免最坏情况？
2. 空间复杂度为O(1)的算法是否一定比O(n)的算法更优？举例说明。
3. 如何用大O表示法分析嵌套循环的复杂度（如三层循环）？