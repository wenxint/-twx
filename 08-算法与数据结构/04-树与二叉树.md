# 树与二叉树

## 基本概念

### 树的定义

树是一种非线性的数据结构，由节点和边组成，没有环路。树具有以下特点：

- 每个节点有零个或多个子节点
- 除了根节点外，每个节点有且只有一个父节点
- 没有环路（即不存在从某个节点出发，经过若干个节点后又回到该节点的路径）
- 任意两个节点之间有且仅有一条路径相连

### 树的基本术语

- **节点（Node）**：树中的基本单位，包含数据和指向子节点的引用
- **根节点（Root）**：树的顶部节点，没有父节点
- **父节点（Parent）**：直接连接到子节点的节点
- **子节点（Child）**：直接连接到父节点的节点
- **叶节点（Leaf）**：没有子节点的节点
- **兄弟节点（Sibling）**：共享同一个父节点的节点
- **深度（Depth）**：从根节点到该节点的边数
- **高度（Height）**：从该节点到最远叶节点的边数
- **层级（Level）**：节点的深度加1

### 二叉树

二叉树是一种特殊的树，每个节点最多有两个子节点，通常称为左子节点和右子节点。

#### 二叉树的类型

1. **满二叉树**：除了叶节点外，每个节点都有两个子节点，所有叶节点都在同一层
2. **完全二叉树**：除了最后一层外，其他层的节点数都达到最大，且最后一层的节点都靠左排列
3. **平衡二叉树**：任意节点的左右子树高度差不超过1
4. **二叉搜索树（BST）**：左子树上所有节点的值都小于根节点的值，右子树上所有节点的值都大于根节点的值

## JavaScript实现

### 二叉树节点

```javascript
class TreeNode {
  constructor(val) {
    this.val = val;
    this.left = null;
    this.right = null;
  }
}
```

### 二叉搜索树

```javascript
class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  // 插入节点
  insert(val) {
    const newNode = new TreeNode(val);

    if (!this.root) {
      this.root = newNode;
      return this;
    }

    let current = this.root;

    while (true) {
      // 值已存在
      if (val === current.val) return undefined;

      // 值小于当前节点，向左走
      if (val < current.val) {
        if (!current.left) {
          current.left = newNode;
          return this;
        }
        current = current.left;
      }
      // 值大于当前节点，向右走
      else {
        if (!current.right) {
          current.right = newNode;
          return this;
        }
        current = current.right;
      }
    }
  }

  // 查找节点
  find(val) {
    if (!this.root) return false;

    let current = this.root;
    let found = false;

    while (current && !found) {
      if (val < current.val) {
        current = current.left;
      } else if (val > current.val) {
        current = current.right;
      } else {
        found = true;
      }
    }

    if (!found) return false;
    return current;
  }

  // 检查值是否存在
  contains(val) {
    if (!this.root) return false;

    let current = this.root;

    while (current) {
      if (val < current.val) {
        current = current.left;
      } else if (val > current.val) {
        current = current.right;
      } else {
        return true;
      }
    }

    return false;
  }
}
```

## 树的遍历

### 深度优先遍历（DFS）

#### 1. 前序遍历（根-左-右）

```javascript
function preOrderTraversal(root) {
  const result = [];

  function traverse(node) {
    if (!node) return;

    // 访问根节点
    result.push(node.val);
    // 遍历左子树
    traverse(node.left);
    // 遍历右子树
    traverse(node.right);
  }

  traverse(root);
  return result;
}
```

#### 2. 中序遍历（左-根-右）

```javascript
function inOrderTraversal(root) {
  const result = [];

  function traverse(node) {
    if (!node) return;

    // 遍历左子树
    traverse(node.left);
    // 访问根节点
    result.push(node.val);
    // 遍历右子树
    traverse(node.right);
  }

  traverse(root);
  return result;
}
```

#### 3. 后序遍历（左-右-根）

```javascript
function postOrderTraversal(root) {
  const result = [];

  function traverse(node) {
    if (!node) return;

    // 遍历左子树
    traverse(node.left);
    // 遍历右子树
    traverse(node.right);
    // 访问根节点
    result.push(node.val);
  }

  traverse(root);
  return result;
}
```

### 广度优先遍历（BFS）

#### 层序遍历

```javascript
function levelOrderTraversal(root) {
  if (!root) return [];

  const result = [];
  const queue = [root];

  while (queue.length > 0) {
    const levelSize = queue.length;
    const currentLevel = [];

    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();
      currentLevel.push(node.val);

      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }

    result.push(currentLevel);
  }

  return result;
}
```

## 常见树操作

### 1. 计算树的高度

```javascript
function treeHeight(root) {
  if (!root) return 0;

  const leftHeight = treeHeight(root.left);
  const rightHeight = treeHeight(root.right);

  return Math.max(leftHeight, rightHeight) + 1;
}
```

### 2. 判断是否为平衡二叉树

```javascript
function isBalanced(root) {
  if (!root) return true;

  function height(node) {
    if (!node) return 0;

    const leftHeight = height(node.left);
    if (leftHeight === -1) return -1;

    const rightHeight = height(node.right);
    if (rightHeight === -1) return -1;

    if (Math.abs(leftHeight - rightHeight) > 1) return -1;

    return Math.max(leftHeight, rightHeight) + 1;
  }

  return height(root) !== -1;
}
```

### 3. 判断是否为二叉搜索树

```javascript
function isValidBST(root) {
  function validate(node, min, max) {
    if (!node) return true;

    if ((min !== null && node.val <= min) || (max !== null && node.val >= max)) {
      return false;
    }

    return validate(node.left, min, node.val) && validate(node.right, node.val, max);
  }

  return validate(root, null, null);
}
```

### 4. 二叉树的最近公共祖先

```javascript
function lowestCommonAncestor(root, p, q) {
  if (!root || root === p || root === q) return root;

  const left = lowestCommonAncestor(root.left, p, q);
  const right = lowestCommonAncestor(root.right, p, q);

  if (left && right) return root;
  return left ? left : right;
}
```

### 5. 二叉树的序列化与反序列化

```javascript
// 序列化
function serialize(root) {
  if (!root) return 'null';

  const left = serialize(root.left);
  const right = serialize(root.right);

  return `${root.val},${left},${right}`;
}

// 反序列化
function deserialize(data) {
  const list = data.split(',');

  function buildTree() {
    const val = list.shift();

    if (val === 'null') return null;

    const node = new TreeNode(parseInt(val));
    node.left = buildTree();
    node.right = buildTree();

    return node;
  }

  return buildTree();
}
```

## 复杂度分析

### 二叉搜索树操作的时间复杂度

| 操作 | 平均时间复杂度 | 最坏时间复杂度 | 说明 |
|------|--------------|--------------|------|
| 查找 | O(log n) | O(n) | 平衡树为O(log n)，退化为链表时为O(n) |
| 插入 | O(log n) | O(n) | 平衡树为O(log n)，退化为链表时为O(n) |
| 删除 | O(log n) | O(n) | 平衡树为O(log n)，退化为链表时为O(n) |

### 树遍历的时间复杂度

| 遍历方式 | 时间复杂度 | 空间复杂度 | 说明 |
|---------|-----------|-----------|------|
| 前序遍历 | O(n) | O(h) | h为树的高度，最坏情况下为O(n) |
| 中序遍历 | O(n) | O(h) | h为树的高度，最坏情况下为O(n) |
| 后序遍历 | O(n) | O(h) | h为树的高度，最坏情况下为O(n) |
| 层序遍历 | O(n) | O(w) | w为树的最大宽度，最坏情况下为O(n) |

## 平衡树

### AVL树

AVL树是一种自平衡二叉搜索树，任何节点的两个子树的高度差不超过1。当插入或删除节点导致不平衡时，通过旋转操作恢复平衡。

### 红黑树

红黑树是一种自平衡二叉搜索树，通过节点的颜色（红色或黑色）来维持平衡。红黑树的特性：

1. 每个节点是红色或黑色
2. 根节点是黑色
3. 所有叶节点（NIL节点）是黑色
4. 如果一个节点是红色，则其子节点必须是黑色
5. 从任一节点到其每个叶子节点的所有路径都包含相同数量的黑色节点

## 前端应用场景

1. **DOM操作**：浏览器将HTML解析为DOM树，前端开发中经常需要遍历和操作DOM树
2. **虚拟DOM**：React、Vue等框架使用树结构表示虚拟DOM
3. **状态管理**：Redux等状态管理库使用树结构存储应用状态
4. **文件系统**：文件目录结构本质上是一个树
5. **组件树**：前端框架中的组件嵌套形成组件树
6. **抽象语法树（AST）**：JavaScript解析器将代码解析为AST，用于代码转换、压缩等
7. **路由系统**：前端路由通常使用树结构组织路由配置

## 经典算法题

### 1. 路径总和

```javascript
function hasPathSum(root, targetSum) {
  if (!root) return false;

  if (!root.left && !root.right) {
    return root.val === targetSum;
  }

  return hasPathSum(root.left, targetSum - root.val) ||
         hasPathSum(root.right, targetSum - root.val);
}
```

### 2. 二叉树的直径

```javascript
function diameterOfBinaryTree(root) {
  let diameter = 0;

  function depth(node) {
    if (!node) return 0;

    const leftDepth = depth(node.left);
    const rightDepth = depth(node.right);

    // 更新直径（左子树深度 + 右子树深度）
    diameter = Math.max(diameter, leftDepth + rightDepth);

    // 返回当前节点为根的子树的深度
    return Math.max(leftDepth, rightDepth) + 1;
  }

  depth(root);
  return diameter;
}
```

### 3. 翻转二叉树

```javascript
function invertTree(root) {
  if (!root) return null;

  // 交换左右子树
  const temp = root.left;
  root.left = root.right;
  root.right = temp;

  // 递归翻转左右子树
  invertTree(root.left);
  invertTree(root.right);

  return root;
}
```

### 4. 对称二叉树

```javascript
function isSymmetric(root) {
  if (!root) return true;

  function isMirror(left, right) {
    if (!left && !right) return true;
    if (!left || !right) return false;

    return (left.val === right.val) &&
           isMirror(left.left, right.right) &&
           isMirror(left.right, right.left);
  }

  return isMirror(root.left, root.right);
}
```

## 面试常见问题

1. 二叉树和二叉搜索树的区别是什么？
2. 如何实现二叉树的各种遍历方式？能否不使用递归实现？
3. 什么是平衡二叉树？如何判断一棵树是否平衡？
4. 红黑树和AVL树的区别是什么？各自的优缺点？
5. 如何在二叉搜索树中查找第k小的元素？
6. 如何序列化和反序列化一棵二叉树？
7. 如何判断两棵二叉树是否相同？
8. 如何找到二叉树中两个节点的最近公共祖先？
9. 如何计算二叉树的最大深度和最小深度？
10. 在前端开发中，树结构有哪些实际应用？

## 学习资源

- [JavaScript数据结构 - 树](https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/tree) - GitHub上的JS实现
- [LeetCode树题集](https://leetcode.com/tag/tree/) - 相关算法练习
- [前端进阶之道 - 树](https://juejin.cn/post/6844903606226845710) - 前端视角的树结构讲解
- [JavaScript树实现详解](https://www.freecodecamp.org/news/all-you-need-to-know-about-tree-data-structures-bceacb85490c/) - FreeCodeCamp上的教程