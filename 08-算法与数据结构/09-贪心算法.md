# 贪心算法

## 基本概念

贪心算法（Greedy Algorithm）是一种在每一步选择中都采取当前状态下最好或最优的选择，从而希望导致结果是最好或最优的算法。

### 核心特性

1. **贪心选择性质**：通过做出一系列局部最优的选择，来达到全局最优
2. **无后效性**：当前决策仅依赖于当前状态，不依赖于之前的决策
3. **子问题最优性**：问题的最优解包含子问题的最优解

### 贪心算法解题步骤

1. 将问题分解为若干个子问题
2. 找出适合的贪心策略
3. 求解每个子问题的最优解
4. 将局部最优解堆叠成全局最优解

### 贪心算法与动态规划的区别

- 贪心算法：每一步都做出当前看似最优的选择，不能回退
- 动态规划：保存以前的运算结果，根据以前的结果对当前进行选择，有回退功能

## 常见贪心算法问题

### 1. 活动选择问题

```javascript
/**
 * @description 活动选择问题 - 在互不重叠的活动中选择最多的活动
 * @param {number[][]} activities - 活动数组，每个活动为[开始时间, 结束时间]
 * @return {number} 最多可参加的活动数量
 */
function activitySelection(activities) {
  // 按结束时间排序
  activities.sort((a, b) => a[1] - b[1]);

  let count = 1;  // 至少参加第一个活动
  let lastEndTime = activities[0][1];

  for (let i = 1; i < activities.length; i++) {
    // 如果当前活动的开始时间大于等于上一个选择的活动的结束时间，则可以参加
    if (activities[i][0] >= lastEndTime) {
      count++;
      lastEndTime = activities[i][1];
    }
  }

  return count;
}
```

### 2. 分发饼干问题

```javascript
/**
 * @description 分发饼干 - 使尽可能多的孩子满足
 * @param {number[]} children - 每个孩子的胃口值
 * @param {number[]} cookies - 每个饼干的尺寸
 * @return {number} 最多可以满足的孩子数量
 */
function findContentChildren(children, cookies) {
  // 对胃口值和饼干尺寸进行排序
  children.sort((a, b) => a - b);
  cookies.sort((a, b) => a - b);

  let child = 0;
  let cookie = 0;

  // 尽可能满足胃口小的孩子
  while (child < children.length && cookie < cookies.length) {
    // 当前饼干可以满足当前孩子
    if (cookies[cookie] >= children[child]) {
      child++;
    }
    cookie++;
  }

  return child;
}
```

### 3. 零钱兑换问题（贪心版本）

```javascript
/**
 * @description 零钱兑换问题 - 使用最少的硬币凑出指定金额（贪心版本，仅适用于特定币值系统）
 * @param {number[]} coins - 硬币面值数组
 * @param {number} amount - 目标金额
 * @return {number} 所需的最少硬币数量
 */
function coinChangeGreedy(coins, amount) {
  // 对硬币面值进行降序排序
  coins.sort((a, b) => b - a);

  let count = 0;
  let remaining = amount;

  for (const coin of coins) {
    // 使用当前面值的硬币尽可能多地凑
    const num = Math.floor(remaining / coin);
    count += num;
    remaining -= num * coin;

    // 已经凑齐
    if (remaining === 0) {
      return count;
    }
  }

  // 无法凑齐
  return remaining > 0 ? -1 : count;
}

// 注意：贪心算法在某些币值系统下可能无法得到最优解
// 例如：coins = [1, 3, 4], amount = 6
// 贪心结果：4 + 1 + 1 = 3枚硬币
// 最优结果：3 + 3 = 2枚硬币
```

### 4. 区间覆盖问题

```javascript
/**
 * @description 用最少的区间覆盖整个范围
 * @param {number[][]} intervals - 区间数组，每个区间为[开始位置, 结束位置]
 * @param {number} start - 需要覆盖的起始位置
 * @param {number} end - 需要覆盖的结束位置
 * @return {number} 最少需要的区间数量，如果无法完全覆盖则返回-1
 */
function minIntervalsCover(intervals, start, end) {
  // 按照起始位置排序
  intervals.sort((a, b) => a[0] - b[0]);

  let count = 0;
  let currentEnd = start;
  let i = 0;

  while (currentEnd < end && i < intervals.length) {
    // 找到能覆盖当前位置且结束位置最远的区间
    let maxEnd = currentEnd;
    let maxIndex = -1;

    while (i < intervals.length && intervals[i][0] <= currentEnd) {
      if (intervals[i][1] > maxEnd) {
        maxEnd = intervals[i][1];
        maxIndex = i;
      }
      i++;
    }

    // 没有找到合适的区间
    if (maxIndex === -1) {
      return -1;
    }

    count++;
    currentEnd = maxEnd;

    // 已经覆盖到终点
    if (currentEnd >= end) {
      return count;
    }
  }

  // 无法完全覆盖
  return -1;
}
```

## 前端应用场景

### 1. 任务调度和资源分配

在前端应用中，当需要调度多个任务或分配有限资源时，可以使用贪心算法来优化执行顺序。

```javascript
// 示例：按照任务执行时间排序，优先执行短任务
function scheduleTasks(tasks) {
  return tasks.sort((a, b) => a.executionTime - b.executionTime);
}
```

### 2. 图像压缩和数据优化

在前端图像处理中，某些压缩算法使用贪心策略来减少数据量。

### 3. 前端路由的最短路径

在复杂的单页应用中，计算页面间的最短导航路径可以应用贪心算法。

### 4. UI组件布局优化

在某些自适应布局算法中，可以使用贪心策略来优化组件排列。

```javascript
// 示例：贪心策略的简化版瀑布流布局
function waterfallLayout(items, columns) {
  const columnHeights = new Array(columns).fill(0);

  return items.map(item => {
    // 找到当前高度最小的列
    const minColumn = columnHeights.indexOf(Math.min(...columnHeights));

    // 将元素放入该列
    const position = {
      column: minColumn,
      top: columnHeights[minColumn]
    };

    // 更新列高度
    columnHeights[minColumn] += item.height;

    return position;
  });
}
```

## 时间复杂度分析

贪心算法的时间复杂度通常取决于问题的规模和排序的复杂度：

- 活动选择问题：O(n log n)，主要是排序的时间复杂度
- 分发饼干问题：O(n log n)，主要是排序的时间复杂度
- 区间覆盖问题：O(n log n)，主要是排序的时间复杂度

## 面试常见问题

1. **如何判断一个问题是否可以使用贪心算法求解？**
   - 问题具有贪心选择性质
   - 问题具有最优子结构性质
   - 局部最优解能导致全局最优解

2. **贪心算法和动态规划的区别是什么？**
   - 贪心算法只考虑当前最优解，不回溯
   - 动态规划考虑所有可能的解，并从中选择最优解
   - 贪心算法通常更高效，但不一定能得到全局最优解

3. **举例说明贪心算法可能失效的情况？**
   - 零钱兑换问题：对于某些币值系统，贪心算法可能无法得到最优解
   - 背包问题：0-1背包问题不能用贪心算法解决，因为物品不可分割

4. **如何证明贪心算法的正确性？**
   - 数学归纳法
   - 反证法
   - 交换论证（证明局部最优可以推导出全局最优）

5. **前端开发中有哪些实际应用贪心算法的场景？**
   - 任务调度和资源分配
   - 图像压缩和数据优化
   - 自适应UI布局算法
   - 网络请求优先级排序