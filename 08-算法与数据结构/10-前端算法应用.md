# 前端算法应用

## 前端常见算法应用场景

### 1. 防抖与节流

**防抖(Debounce)**：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

```javascript
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}

// 使用示例
const handleSearch = debounce(function(e) {
  // 搜索请求逻辑
  console.log('搜索内容：', e.target.value);
}, 300);

// 绑定到输入框
searchInput.addEventListener('input', handleSearch);
```

**节流(Throttle)**：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行。

```javascript
function throttle(fn, delay) {
  let lastTime = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastTime >= delay) {
      fn.apply(this, args);
      lastTime = now;
    }
  };
}

// 使用示例
const handleScroll = throttle(function() {
  // 滚动处理逻辑
  console.log('页面滚动位置：', window.scrollY);
}, 200);

// 绑定到滚动事件
window.addEventListener('scroll', handleScroll);
```

### 2. 数据结构优化

**使用Map/Set优化查找**：

```javascript
// 使用Map进行缓存优化
function memoize(fn) {
  const cache = new Map();
  return function(...args) {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

// 使用Set去重
function uniqueArray(arr) {
  return [...new Set(arr)];
}
```

### 3. 虚拟列表实现

虚拟列表核心思想：只渲染可视区域的内容。

```javascript
class VirtualList {
  constructor(options) {
    this.container = options.container;
    this.itemHeight = options.itemHeight;
    this.items = options.items || [];
    this.visibleItems = Math.ceil(this.container.clientHeight / this.itemHeight);
    this.startIndex = 0;
    this.endIndex = this.startIndex + this.visibleItems;

    this.initScroll();
    this.render();
  }

  initScroll() {
    this.container.style.overflow = 'auto';
    this.container.style.position = 'relative';

    // 创建高度占位元素
    this.phantom = document.createElement('div');
    this.phantom.style.height = `${this.items.length * this.itemHeight}px`;
    this.phantom.style.position = 'absolute';
    this.phantom.style.left = '0';
    this.phantom.style.top = '0';
    this.phantom.style.right = '0';
    this.phantom.style.zIndex = '-1';
    this.container.appendChild(this.phantom);

    // 创建内容容器
    this.content = document.createElement('div');
    this.content.style.position = 'absolute';
    this.content.style.left = '0';
    this.content.style.top = '0';
    this.content.style.right = '0';
    this.container.appendChild(this.content);

    this.container.addEventListener('scroll', this.handleScroll.bind(this));
  }

  handleScroll() {
    const scrollTop = this.container.scrollTop;
    this.startIndex = Math.floor(scrollTop / this.itemHeight);
    this.endIndex = this.startIndex + this.visibleItems;
    this.render();
  }

  render() {
    const visibleData = this.items.slice(this.startIndex, this.endIndex + 1);
    this.content.style.transform = `translateY(${this.startIndex * this.itemHeight}px)`;
    this.content.innerHTML = visibleData.map((item, index) => `
      <div style="height: ${this.itemHeight}px;">
        ${item.content || item}
      </div>
    `).join('');
  }
}
```

### 4. 树结构操作

**树的遍历与操作**：

```javascript
// 深度优先遍历(DFS)
function deepTraversal(node, nodeList = []) {
  if (node) {
    nodeList.push(node);
    const children = node.children || [];
    for (let i = 0; i < children.length; i++) {
      deepTraversal(children[i], nodeList);
    }
  }
  return nodeList;
}

// 广度优先遍历(BFS)
function breadthTraversal(node) {
  const result = [];
  const queue = [];

  if (node) {
    queue.push(node);
    while (queue.length > 0) {
      const item = queue.shift();
      result.push(item);

      const children = item.children || [];
      for (let i = 0; i < children.length; i++) {
        queue.push(children[i]);
      }
    }
  }

  return result;
}

// 查找节点
function findNode(tree, id) {
  const queue = [...tree];
  while (queue.length) {
    const node = queue.shift();
    if (node.id === id) return node;
    if (node.children) queue.push(...node.children);
  }
  return null;
}
```

## 前端常见算法面试题

### 1. 实现一个LRU缓存

```javascript
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }

  get(key) {
    if (!this.cache.has(key)) return -1;

    // 更新位置（删除后重新插入到最后）
    const value = this.cache.get(key);
    this.cache.delete(key);
    this.cache.set(key, value);
    return value;
  }

  put(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.capacity) {
      // 删除最久未使用的元素（第一个）
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }
}
```

### 2. 实现数组打平(Flatten)

```javascript
// 递归实现
function flatten(arr) {
  let result = [];
  arr.forEach(item => {
    if (Array.isArray(item)) {
      result = result.concat(flatten(item));
    } else {
      result.push(item);
    }
  });
  return result;
}

// 非递归实现
function flattenIterative(arr) {
  return arr.reduce((result, item) => {
    return result.concat(Array.isArray(item) ? flattenIterative(item) : item);
  }, []);
}

// 使用ES6的flat
const flatArray = arr => arr.flat(Infinity);
```

### 3. 实现深拷贝

```javascript
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return obj;
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  if (typeof obj !== 'object') return obj;

  // 处理循环引用
  if (hash.has(obj)) return hash.get(obj);

  const cloneObj = Array.isArray(obj) ? [] : {};
  hash.set(obj, cloneObj);

  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }

  return cloneObj;
}
```

## 实际项目应用场景

1. **搜索建议优化**：使用前缀树(Trie)实现高效的关键词匹配
2. **表单验证**：使用策略模式结合正则表达式
3. **复杂表格**：使用虚拟滚动优化大数据量渲染
4. **图表可视化**：使用数据结构优化和布局算法
5. **路由管理**：使用有限状态机管理复杂的页面状态转换

## 常见面试问题解答

### 1. 在前端开发中，你最常用到哪些算法和数据结构？
在实际前端开发中，我最常用到的算法包括防抖节流、事件委托、递归遍历、排序和搜索算法等。常用的数据结构有数组、对象、Map/Set、树结构等。这些算法和数据结构主要用于处理用户交互、DOM操作优化、数据处理与展示等场景。

### 2. 如何优化大量数据的前端渲染？
优化大量数据渲染可以采用：
- 虚拟列表/虚拟滚动技术，只渲染可视区域的数据
- 时间分片(Time Slicing)，将大任务分割成小任务分批执行
- Web Worker处理数据计算，避免阻塞主线程
- 数据缓存与懒加载策略

### 3. 实现一个简单的前端路由是如何工作的？
前端路由主要有两种实现方式：
- 基于hash(#)：监听hashchange事件，根据hash值渲染对应组件
- 基于History API：使用pushState和replaceState修改URL，监听popstate事件处理前进后退

### 4. 如何设计一个高效的前端状态管理系统？
高效的状态管理系统需要考虑：
- 单一数据源原则
- 状态的不可变性
- 使用观察者模式或发布-订阅模式处理状态变化
- 合理的组件通信机制
- 支持中间件处理副作用

### 5. 如何处理前端的大文件上传？
大文件上传可以采用：
- 文件分片上传：将大文件切分成小块上传
- 断点续传：记录已上传的分片，支持中断后继续上传
- MD5校验：避免重复上传相同内容
- 并发控制：控制同时上传的分片数量
