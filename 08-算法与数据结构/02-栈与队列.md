# 栈与队列

## 基本概念

### 栈（Stack）

栈是一种遵循后进先出（LIFO, Last-In-First-Out）原则的有序集合：

- 只能在栈顶添加或删除元素
- 最后添加的元素最先被移除
- 类似于一摞盘子，只能从顶部放入或取出

### 队列（Queue）

队列是一种遵循先进先出（FIFO, First-In-First-Out）原则的有序集合：

- 在队尾添加元素，从队首移除元素
- 最先添加的元素最先被移除
- 类似于排队，先到先得

## JavaScript实现

### 栈的实现

```javascript
class Stack {
  constructor() {
    this.items = [];
  }

  // 入栈
  push(element) {
    this.items.push(element);
  }

  // 出栈
  pop() {
    if (this.isEmpty()) {
      return "栈为空";
    }
    return this.items.pop();
  }

  // 查看栈顶元素
  peek() {
    if (this.isEmpty()) {
      return "栈为空";
    }
    return this.items[this.items.length - 1];
  }

  // 检查栈是否为空
  isEmpty() {
    return this.items.length === 0;
  }

  // 获取栈的大小
  size() {
    return this.items.length;
  }

  // 清空栈
  clear() {
    this.items = [];
  }
}
```

### 队列的实现

```javascript
class Queue {
  constructor() {
    this.items = {};
    this.frontIndex = 0;
    this.backIndex = 0;
  }

  // 入队
  enqueue(element) {
    this.items[this.backIndex] = element;
    this.backIndex++;
  }

  // 出队
  dequeue() {
    if (this.isEmpty()) {
      return "队列为空";
    }
    const item = this.items[this.frontIndex];
    delete this.items[this.frontIndex];
    this.frontIndex++;
    return item;
  }

  // 查看队首元素
  front() {
    if (this.isEmpty()) {
      return "队列为空";
    }
    return this.items[this.frontIndex];
  }

  // 检查队列是否为空
  isEmpty() {
    return this.backIndex - this.frontIndex === 0;
  }

  // 获取队列的大小
  size() {
    return this.backIndex - this.frontIndex;
  }

  // 清空队列
  clear() {
    this.items = {};
    this.frontIndex = 0;
    this.backIndex = 0;
  }
}
```

## 特殊类型

### 双端队列（Deque）

双端队列是一种允许在两端添加和移除元素的特殊队列：

```javascript
class Deque {
  constructor() {
    this.items = {};
    this.frontIndex = 0;
    this.backIndex = 0;
  }

  // 在队首添加元素
  addFront(element) {
    if (this.isEmpty()) {
      this.addBack(element);
    } else {
      this.frontIndex--;
      this.items[this.frontIndex] = element;
    }
  }

  // 在队尾添加元素
  addBack(element) {
    this.items[this.backIndex] = element;
    this.backIndex++;
  }

  // 从队首移除元素
  removeFront() {
    if (this.isEmpty()) {
      return "双端队列为空";
    }
    const item = this.items[this.frontIndex];
    delete this.items[this.frontIndex];
    this.frontIndex++;
    return item;
  }

  // 从队尾移除元素
  removeBack() {
    if (this.isEmpty()) {
      return "双端队列为空";
    }
    this.backIndex--;
    const item = this.items[this.backIndex];
    delete this.items[this.backIndex];
    return item;
  }

  // 其他方法与Queue类似
  // ...
}
```

### 优先队列

优先队列中的元素具有优先级，优先级高的元素先出队：

```javascript
class PriorityQueue {
  constructor() {
    this.items = [];
  }

  // 入队（带优先级）
  enqueue(element, priority) {
    const queueElement = { element, priority };
    let added = false;

    for (let i = 0; i < this.items.length; i++) {
      if (queueElement.priority < this.items[i].priority) {
        this.items.splice(i, 0, queueElement);
        added = true;
        break;
      }
    }

    if (!added) {
      this.items.push(queueElement);
    }
  }

  // 其他方法与普通队列类似
  // ...
}
```

### 单调栈

单调栈是一种特殊的栈，其中的元素保持单调递增或单调递减的顺序：

```javascript
// 单调递增栈示例（处理下一个更大元素问题）
function nextGreaterElement(nums) {
  const result = Array(nums.length).fill(-1);
  const stack = [];

  for (let i = 0; i < nums.length; i++) {
    // 当前元素大于栈顶元素时，栈顶元素的下一个更大元素就是当前元素
    while (stack.length > 0 && nums[i] > nums[stack[stack.length - 1]]) {
      const index = stack.pop();
      result[index] = nums[i];
    }
    stack.push(i);
  }

  return result;
}
```

## 复杂度分析

### 栈操作的时间复杂度

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| push | O(1) | 添加到栈顶 |
| pop | O(1) | 移除栈顶元素 |
| peek | O(1) | 查看栈顶元素 |
| isEmpty | O(1) | 检查栈是否为空 |
| size | O(1) | 获取栈的大小 |

### 队列操作的时间复杂度

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| enqueue | O(1) | 添加到队尾 |
| dequeue | O(1) | 移除队首元素 |
| front | O(1) | 查看队首元素 |
| isEmpty | O(1) | 检查队列是否为空 |
| size | O(1) | 获取队列的大小 |

## 前端应用场景

### 栈的应用

1. **浏览器历史记录**：前进和后退功能
2. **撤销/重做功能**：编辑器中的操作历史
3. **路由管理**：前端路由的历史记录
4. **表达式求值**：计算器的实现
5. **语法解析**：括号匹配、HTML标签匹配
6. **函数调用栈**：JavaScript引擎中的执行上下文管理

### 队列的应用

1. **任务队列**：异步操作的管理（如事件循环中的任务队列）
2. **消息队列**：前端与后端的通信
3. **缓冲区管理**：处理用户输入或API请求
4. **广度优先搜索**：DOM树遍历
5. **打印队列**：按顺序处理打印任务
6. **请求限流**：控制API请求频率

## 经典算法题

### 1. 有效的括号

```javascript
function isValidParentheses(s) {
  const stack = [];
  const map = {
    '(': ')',
    '[': ']',
    '{': '}'
  };

  for (let i = 0; i < s.length; i++) {
    const char = s[i];
    if (char in map) { // 左括号
      stack.push(char);
    } else { // 右括号
      const top = stack.pop();
      if (map[top] !== char) {
        return false;
      }
    }
  }

  return stack.length === 0;
}
```

### 2. 用栈实现队列

```javascript
class MyQueue {
  constructor() {
    this.stackIn = [];
    this.stackOut = [];
  }

  push(x) {
    this.stackIn.push(x);
  }

  pop() {
    if (this.stackOut.length === 0) {
      this.transferElements();
    }
    return this.stackOut.pop();
  }

  peek() {
    if (this.stackOut.length === 0) {
      this.transferElements();
    }
    return this.stackOut[this.stackOut.length - 1];
  }

  empty() {
    return this.stackIn.length === 0 && this.stackOut.length === 0;
  }

  transferElements() {
    while (this.stackIn.length > 0) {
      this.stackOut.push(this.stackIn.pop());
    }
  }
}
```

### 3. 用队列实现栈

```javascript
class MyStack {
  constructor() {
    this.queue1 = [];
    this.queue2 = [];
  }

  push(x) {
    this.queue1.push(x);
  }

  pop() {
    while (this.queue1.length > 1) {
      this.queue2.push(this.queue1.shift());
    }

    const result = this.queue1.shift();

    // 交换两个队列
    [this.queue1, this.queue2] = [this.queue2, this.queue1];

    return result;
  }

  top() {
    while (this.queue1.length > 1) {
      this.queue2.push(this.queue1.shift());
    }

    const result = this.queue1[0];
    this.queue2.push(this.queue1.shift());

    // 交换两个队列
    [this.queue1, this.queue2] = [this.queue2, this.queue1];

    return result;
  }

  empty() {
    return this.queue1.length === 0;
  }
}
```

### 4. 滑动窗口最大值

```javascript
function maxSlidingWindow(nums, k) {
  const result = [];
  const deque = []; // 存储索引

  for (let i = 0; i < nums.length; i++) {
    // 移除超出窗口范围的元素
    if (deque.length > 0 && deque[0] <= i - k) {
      deque.shift();
    }

    // 移除比当前元素小的元素（它们不可能是最大值）
    while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {
      deque.pop();
    }

    deque.push(i);

    // 当窗口形成后，记录最大值
    if (i >= k - 1) {
      result.push(nums[deque[0]]);
    }
  }

  return result;
}
```

## 面试常见问题

1. 栈和队列的区别是什么？它们各自适用于哪些场景？
2. 如何用JavaScript实现一个栈？如何确保其操作的时间复杂度为O(1)？
3. 什么是单调栈？它在解决哪类问题时特别有效？
4. 如何使用栈实现表达式求值（如计算器功能）？
5. 浏览器的历史记录是如何使用栈来实现的？
6. JavaScript的事件循环中，任务队列是如何工作的？
7. 如何使用队列实现广度优先搜索？
8. 如何设计一个高效的LRU（最近最少使用）缓存？
9. 如何判断一个HTML文档的标签是否匹配？
10. 如何实现一个支持最小值操作的栈，要求push、pop、getMin操作的时间复杂度都是O(1)？

## 学习资源

- [JavaScript数据结构 - 栈与队列](https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures) - GitHub上的JS实现
- [LeetCode栈与队列题集](https://leetcode.com/tag/stack/) - 相关算法练习
- [前端进阶之道 - 栈与队列](https://juejin.cn/post/6844903907580944398) - 前端视角的栈与队列讲解
- [JavaScript栈与队列实现详解](https://www.freecodecamp.org/news/data-structures-101-stacks-and-queues-in-javascript-7298d3a1091/) - FreeCodeCamp上的教程