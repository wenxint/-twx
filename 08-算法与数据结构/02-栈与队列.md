# 栈与队列

## 栈（Stack）

### 基本概念

栈是一种遵循后进先出（LIFO，Last In First Out）原则的有序集合。新元素的添加和移除都发生在同一端，称为栈顶，另一端称为栈底。最新添加的元素总是位于栈顶，最先被移除。

### 栈的基本操作

- **push(element)**：将元素添加到栈顶
- **pop()**：移除并返回栈顶元素
- **peek()**：返回栈顶元素但不移除
- **isEmpty()**：检查栈是否为空
- **size()**：返回栈中元素的数量
- **clear()**：清空栈

### JavaScript实现栈

#### 使用数组实现

```javascript
class Stack {
  constructor() {
    this.items = [];
  }

  push(element) {
    this.items.push(element);
  }

  pop() {
    if (this.isEmpty()) {
      return "栈为空";
    }
    return this.items.pop();
  }

  peek() {
    if (this.isEmpty()) {
      return "栈为空";
    }
    return this.items[this.items.length - 1];
  }

  isEmpty() {
    return this.items.length === 0;
  }

  size() {
    return this.items.length;
  }

  clear() {
    this.items = [];
  }
}

// 使用示例
const stack = new Stack();
stack.push(10);
stack.push(20);
stack.push(30);
console.log(stack.peek()); // 30
console.log(stack.pop()); // 30
console.log(stack.size()); // 2
```

#### 使用对象实现（更高效）

```javascript
class Stack {
  constructor() {
    this.items = {};
    this.count = 0;
  }

  push(element) {
    this.items[this.count] = element;
    this.count++;
  }

  pop() {
    if (this.isEmpty()) {
      return undefined;
    }
    this.count--;
    const result = this.items[this.count];
    delete this.items[this.count];
    return result;
  }

  peek() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.items[this.count - 1];
  }

  isEmpty() {
    return this.count === 0;
  }

  size() {
    return this.count;
  }

  clear() {
    this.items = {};
    this.count = 0;
  }
}
```

### 栈的应用场景

1. **函数调用栈**：JavaScript引擎使用栈来管理函数调用
2. **表达式求值**：计算中缀、前缀和后缀表达式
3. **括号匹配**：检查括号是否匹配
4. **浏览器历史记录**：实现前进和后退功能
5. **撤销操作**：实现撤销/重做功能
6. **深度优先搜索**：图和树的遍历算法
7. **路径查找**：迷宫问题和路径查找算法

### 栈的时间复杂度

| 操作 | 时间复杂度 |
|------|----------|
| push | O(1) |
| pop | O(1) |
| peek | O(1) |
| isEmpty | O(1) |
| size | O(1) |

## 队列（Queue）

### 基本概念

队列是一种遵循先进先出（FIFO，First In First Out）原则的有序集合。新元素的添加发生在一端，称为队尾，而元素的移除发生在另一端，称为队首。最先添加的元素总是最先被移除。

### 队列的基本操作

- **enqueue(element)**：将元素添加到队尾
- **dequeue()**：移除并返回队首元素
- **front()**：返回队首元素但不移除
- **isEmpty()**：检查队列是否为空
- **size()**：返回队列中元素的数量
- **clear()**：清空队列

### JavaScript实现队列

#### 使用数组实现

```javascript
class Queue {
  constructor() {
    this.items = [];
  }

  enqueue(element) {
    this.items.push(element);
  }

  dequeue() {
    if (this.isEmpty()) {
      return "队列为空";
    }
    return this.items.shift();
  }

  front() {
    if (this.isEmpty()) {
      return "队列为空";
    }
    return this.items[0];
  }

  isEmpty() {
    return this.items.length === 0;
  }

  size() {
    return this.items.length;
  }

  clear() {
    this.items = [];
  }
}

// 使用示例
const queue = new Queue();
queue.enqueue(10);
queue.enqueue(20);
queue.enqueue(30);
console.log(queue.front()); // 10
console.log(queue.dequeue()); // 10
console.log(queue.size()); // 2
```

#### 使用对象实现（更高效）

```javascript
class Queue {
  constructor() {
    this.items = {};
    this.frontIndex = 0;
    this.backIndex = 0;
  }

  enqueue(element) {
    this.items[this.backIndex] = element;
    this.backIndex++;
  }

  dequeue() {
    if (this.isEmpty()) {
      return undefined;
    }
    const result = this.items[this.frontIndex];
    delete this.items[this.frontIndex];
    this.frontIndex++;
    return result;
  }

  front() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.items[this.frontIndex];
  }

  isEmpty() {
    return this.backIndex - this.frontIndex === 0;
  }

  size() {
    return this.backIndex - this.frontIndex;
  }

  clear() {
    this.items = {};
    this.frontIndex = 0;
    this.backIndex = 0;
  }
}
```

### 队列的变体

#### 1. 双端队列（Deque）

双端队列是一种允许在两端添加和移除元素的特殊队列。

```javascript
class Deque {
  constructor() {
    this.items = {};
    this.frontIndex = 0;
    this.backIndex = 0;
  }

  addFront(element) {
    if (this.isEmpty()) {
      this.addBack(element);
    } else {
      this.frontIndex--;
      this.items[this.frontIndex] = element;
    }
  }

  addBack(element) {
    this.items[this.backIndex] = element;
    this.backIndex++;
  }

  removeFront() {
    if (this.isEmpty()) {
      return undefined;
    }
    const result = this.items[this.frontIndex];
    delete this.items[this.frontIndex];
    this.frontIndex++;
    return result;
  }

  removeBack() {
    if (this.isEmpty()) {
      return undefined;
    }
    this.backIndex--;
    const result = this.items[this.backIndex];
    delete this.items[this.backIndex];
    return result;
  }

  peekFront() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.items[this.frontIndex];
  }

  peekBack() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.items[this.backIndex - 1];
  }

  isEmpty() {
    return this.backIndex - this.frontIndex === 0;
  }

  size() {
    return this.backIndex - this.frontIndex;
  }

  clear() {
    this.items = {};
    this.frontIndex = 0;
    this.backIndex = 0;
  }
}
```

#### 2. 优先队列（Priority Queue）

优先队列中的元素具有优先级，优先级高的元素先出队。

```javascript
class PriorityQueue {
  constructor() {
    this.items = [];
  }

  enqueue(element, priority) {
    const queueElement = { element, priority };
    let added = false;

    for (let i = 0; i < this.items.length; i++) {
      if (queueElement.priority < this.items[i].priority) {
        this.items.splice(i, 0, queueElement);
        added = true;
        break;
      }
    }

    if (!added) {
      this.items.push(queueElement);
    }
  }

  dequeue() {
    if (this.isEmpty()) {
      return "队列为空";
    }
    return this.items.shift().element;
  }

  front() {
    if (this.isEmpty()) {
      return "队列为空";
    }
    return this.items[0].element;
  }

  isEmpty() {
    return this.items.length === 0;
  }

  size() {
    return this.items.length;
  }

  clear() {
    this.items = [];
  }
}

// 使用示例
const priorityQueue = new PriorityQueue();
priority.enqueue("普通任务", 2);
priority.enqueue("紧急任务", 1);
priority.enqueue("非常紧急任务", 0);
console.log(priorityQueue.dequeue()); // 非常紧急任务
```

#### 3. 循环队列（Circular Queue）

循环队列是一种环形结构，当队尾到达数组末尾时，下一个元素会被放置在数组开头。

```javascript
class CircularQueue {
  constructor(capacity) {
    this.items = new Array(capacity);
    this.capacity = capacity;
    this.currentLength = 0;
    this.front = -1;
    this.rear = -1;
  }

  isFull() {
    return this.currentLength === this.capacity;
  }

  isEmpty() {
    return this.currentLength === 0;
  }

  enqueue(element) {
    if (this.isFull()) {
      return false;
    }

    this.rear = (this.rear + 1) % this.capacity;
    this.items[this.rear] = element;
    this.currentLength++;

    if (this.front === -1) {
      this.front = this.rear;
    }

    return true;
  }

  dequeue() {
    if (this.isEmpty()) {
      return null;
    }

    const item = this.items[this.front];
    this.items[this.front] = null;
    this.front = (this.front + 1) % this.capacity;
    this.currentLength--;

    if (this.isEmpty()) {
      this.front = -1;
      this.rear = -1;
    }

    return item;
  }

  peek() {
    if (this.isEmpty()) {
      return null;
    }

    return this.items[this.front];
  }

  size() {
    return this.currentLength;
  }

  print() {
    if (this.isEmpty()) {
      console.log('队列为空');
    } else {
      let i;
      let str = '';
      for (i = this.front; i !== this.rear; i = (i + 1) % this.capacity) {
        str += this.items[i] + ' ';
      }
      str += this.items[i];
      console.log(str);
    }
  }
}
```

### 队列的应用场景

1. **任务队列**：JavaScript事件循环中的任务队列
2. **消息队列**：处理异步消息和事件
3. **缓冲区管理**：管理数据流和缓冲区
4. **打印任务队列**：管理打印任务
5. **广度优先搜索**：图和树的遍历算法
6. **请求处理**：Web服务器中的请求处理
7. **线程池**：管理线程和进程

### 队列的时间复杂度

| 操作 | 数组实现 | 对象实现 |
|------|---------|--------|
| enqueue | O(1) | O(1) |
| dequeue | O(n) | O(1) |
| front | O(1) | O(1) |
| isEmpty | O(1) | O(1) |
| size | O(1) | O(1) |

## 栈与队列的比较

| 特性 | 栈 | 队列 |
|------|-----|------|
| 插入/删除原则 | LIFO（后进先出） | FIFO（先进先出） |
| 插入操作 | push（在栈顶） | enqueue（在队尾） |
| 删除操作 | pop（从栈顶） | dequeue（从队首） |
| 访问元素 | 只能访问栈顶元素 | 只能访问队首元素 |
| 应用场景 | 函数调用、表达式求值、深度优先搜索 | 任务调度、消息队列、广度优先搜索 |

## 前端应用场景

### 栈的前端应用

1. **路由历史管理**：实现浏览器的前进/后退功能
2. **撤销/重做功能**：在编辑器中实现操作历史
3. **括号匹配验证**：验证HTML/XML标签或JavaScript代码中的括号是否匹配
4. **表达式计算器**：实现简单的计算器功能
5. **调用栈可视化**：调试工具中的调用栈展示
6. **组件层级管理**：管理组件的嵌套层级

### 队列的前端应用

1. **异步任务队列**：管理异步操作和回调
2. **事件处理**：事件监听和处理机制
3. **动画效果队列**：按顺序执行动画效果
4. **请求限流**：控制API请求频率
5. **消息通知系统**：管理通知的显示和消失
6. **图片懒加载**：管理待加载的图片队列

## 常见算法题

### 1. 有效的括号（栈应用）

```javascript
/**
 * 判断括号是否有效匹配
 * @param {string} s 包含括号的字符串
 * @return {boolean} 是否有效
 */
function isValid(s) {
  const stack = [];
  const map = {
    '(': ')',
    '[': ']',
    '{': '}'
  };

  for (let i = 0; i < s.length; i++) {
    const char = s[i];

    if (map[char]) { // 左括号
      stack.push(char);
    } else { // 右括号
      const top = stack.pop();

      if (map[top] !== char) {
        return false;
      }
    }
  }

  return stack.length === 0;
}

console.log(isValid("()[]{}")); // true
console.log(isValid("([)]")); // false
```

### 2. 用栈实现队列

```javascript
class MyQueue {
  constructor() {
    this.stackIn = [];
    this.stackOut = [];
  }

  push(x) {
    this.stackIn.push(x);
  }

  pop() {
    if (this.stackOut.length === 0) {
      this.transferElements();
    }
    return this.stackOut.pop();
  }

  peek() {
    if (this.stackOut.length === 0) {
      this.transferElements();
    }
    return this.stackOut[this.stackOut.length - 1];
  }

  empty() {
    return this.stackIn.length === 0 && this.stackOut.length === 0;
  }

  transferElements() {
    while (this.stackIn.length > 0) {
      this.stackOut.push(this.stackIn.pop());
    }
  }
}
```

### 3. 用队列实现栈

```javascript
class MyStack {
  constructor() {
    this.queue1 = [];
    this.queue2 = [];
  }

  push(x) {
    this.queue1.push(x);
  }

  pop() {
    while (this.queue1.length > 1) {
      this.queue2.push(this.queue1.shift());
    }

    const result = this.queue1.shift();

    // 交换两个队列
    [this.queue1, this.queue2] = [this.queue2, this.queue1];

    return result;
  }

  top() {
    while (this.queue1.length > 1) {
      this.queue2.push(this.queue1.shift());
    }

    const result = this.queue1[0];
    this.queue2.push(this.queue1.shift());

    // 交换两个队列
    [this.queue1, this.queue2] = [this.queue2, this.queue1];

    return result;
  }

  empty() {
    return this.queue1.length === 0;
  }
}
```

### 4. 最小栈

```javascript
class MinStack {
  constructor() {
    this.stack = [];
    this.minStack = [];
  }

  push(val) {
    this.stack.push(val);

    if (this.minStack.length === 0 || val <= this.minStack[this.minStack.length - 1]) {
      this.minStack.push(val);
    }
  }

  pop() {
    const val = this.stack.pop();

    if (val === this.minStack[this.minStack.length - 1]) {
      this.minStack.pop();
    }

    return val;
  }

  top() {
    return this.stack[this.stack.length - 1];
  }

  getMin() {
    return this.minStack[this.minStack.length - 1];
  }
}
```

### 5. 滑动窗口最大值（双端队列应用）

```javascript
/**
 * 返回滑动窗口中的最大值
 * @param {number[]} nums 数组
 * @param {number} k 窗口大小
 * @return {number[]} 每个窗口的最大值
 */
function maxSlidingWindow(nums, k) {
  const result = [];
  const deque = [];

  for (let i = 0; i < nums.length; i++) {
    // 移除队列中所有小于当前元素的值
    while (deque.length > 0 && nums[deque[deque.length - 1]] < nums[i]) {
      deque.pop();
    }

    // 添加当前元素索引到队列
    deque.push(i);

    // 移除超出窗口范围的元素
    if (deque[0] <= i - k) {
      deque.shift();
    }

    // 当窗口形成后，记录最大值
    if (i >= k - 1) {
      result.push(nums[deque[0]]);
    }
  }

  return result;
}
```

## 面试常见问题

1. 栈和队列的主要区别是什么？
2. 如何使用两个栈实现一个队列？
3. 如何使用两个队列实现一个栈？
4. 什么是优先队列？它与普通队列有什么区别？
5. 如何实现一个支持获取最小元素的栈？
6. 描述一下JavaScript的事件循环中的任务队列机制。
7. 如何使用栈来检查括号是否匹配？
8. 什么是双端队列？它有哪些应用场景？
9. 如何实现一个循环队列？
10. 在前端开发中，栈和队列有哪些实际应用？

## 学习资源

- [MDN Web Docs - Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array) - 用于实现栈和队列的数组方法
- [JavaScript数据结构 - 栈与队列](https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures) - GitHub上的JS实现
- [LeetCode栈题集](https://leetcode.com/tag/stack/) - 栈相关算法练习
- [LeetCode队列题集](https://leetcode.com/tag/queue/) - 队列相关算法练习
- [前端进阶之道 - 数据结构](https://juejin.cn/post/6844903919722692621) - 前端视角的栈和队列讲解
- [JavaScript事件循环](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop) - 理解JavaScript中的任务队列