# 查找算法

查找算法是计算机科学中的基础算法，用于在数据集合中查找特定元素。在前端开发中，掌握高效的查找算法可以优化数据处理、DOM操作和状态管理等方面的性能。

## 1. 二分查找

### 1.1 基本概念

二分查找（Binary Search）是一种高效的查找算法，适用于**已排序**的数组。其基本思想是将目标值与数组中间元素比较，通过不断缩小查找范围来定位目标元素。

### 1.2 算法步骤

1. 将待查找区间初始化为整个数组
2. 找到区间的中间元素
3. 将目标值与中间元素比较
   - 如果目标值等于中间元素，查找成功
   - 如果目标值小于中间元素，在左半部分继续查找
   - 如果目标值大于中间元素，在右半部分继续查找
4. 重复步骤2-3直到找到目标值或区间为空

### 1.3 代码实现

```javascript
/**
 * 二分查找 - 迭代版本
 * @param {number[]} arr 已排序的数组
 * @param {number} target 目标值
 * @return {number} 目标值的索引，未找到返回-1
 */
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    // 计算中间索引 (避免整数溢出)
    const mid = left + Math.floor((right - left) / 2);

    // 找到目标值
    if (arr[mid] === target) {
      return mid;
    }

    // 在左半部分继续查找
    if (arr[mid] > target) {
      right = mid - 1;
    }
    // 在右半部分继续查找
    else {
      left = mid + 1;
    }
  }

  // 未找到目标值
  return -1;
}

// 递归版本
function binarySearchRecursive(arr, target, left = 0, right = arr.length - 1) {
  // 基本情况：未找到目标值
  if (left > right) {
    return -1;
  }

  const mid = left + Math.floor((right - left) / 2);

  // 找到目标值
  if (arr[mid] === target) {
    return mid;
  }

  // 递归查找
  if (arr[mid] > target) {
    return binarySearchRecursive(arr, target, left, mid - 1);
  } else {
    return binarySearchRecursive(arr, target, mid + 1, right);
  }
}
```

### 1.4 时间复杂度和空间复杂度

- **时间复杂度**：O(log n) - 每次比较后，查找范围缩小一半
- **空间复杂度**：
  - 迭代版本：O(1) - 仅使用常数额外空间
  - 递归版本：O(log n) - 由于递归调用栈的开销

### 1.5 二分查找变种

#### 寻找第一个等于目标值的元素

```javascript
function findFirstEqual(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  let result = -1;

  while (left <= right) {
    const mid = left + Math.floor((right - left) / 2);

    if (arr[mid] >= target) {
      right = mid - 1;
      if (arr[mid] === target) {
        result = mid;
      }
    } else {
      left = mid + 1;
    }
  }

  return result;
}
```

#### 寻找最后一个等于目标值的元素

```javascript
function findLastEqual(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  let result = -1;

  while (left <= right) {
    const mid = left + Math.floor((right - left) / 2);

    if (arr[mid] <= target) {
      left = mid + 1;
      if (arr[mid] === target) {
        result = mid;
      }
    } else {
      right = mid - 1;
    }
  }

  return result;
}
```

#### 寻找第一个大于等于目标值的元素

```javascript
function findFirstGreaterOrEqual(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  let result = arr.length; // 若所有元素都小于target，返回数组长度

  while (left <= right) {
    const mid = left + Math.floor((right - left) / 2);

    if (arr[mid] >= target) {
      result = mid;
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }

  return result;
}
```

## 2. 深度优先搜索 (DFS)

### 2.1 基本概念

深度优先搜索（Depth-First Search，简称DFS）是一种用于遍历或搜索树或图的算法。其特点是沿着一条路径尽可能深入，直到不能再深入为止，然后回溯到前一个节点，继续搜索其他路径。

### 2.2 算法步骤

1. 从起始节点开始，标记为已访问
2. 对于当前节点的每个未访问的相邻节点，递归地应用DFS
3. 如果没有未访问的相邻节点，则回溯

### 2.3 代码实现

#### 递归实现（以树为例）

```javascript
/**
 * 树节点定义
 * function TreeNode(val, left, right) {
 *   this.val = (val === undefined ? 0 : val);
 *   this.left = (left === undefined ? null : left);
 *   this.right = (right === undefined ? null : right);
 * }
 */

// 前序遍历（根-左-右）
function preorderDFS(root) {
  const result = [];

  function traverse(node) {
    if (!node) return;

    // 访问当前节点
    result.push(node.val);
    // 递归遍历左子树
    traverse(node.left);
    // 递归遍历右子树
    traverse(node.right);
  }

  traverse(root);
  return result;
}

// 中序遍历（左-根-右）
function inorderDFS(root) {
  const result = [];

  function traverse(node) {
    if (!node) return;

    traverse(node.left);
    result.push(node.val);
    traverse(node.right);
  }

  traverse(root);
  return result;
}

// 后序遍历（左-右-根）
function postorderDFS(root) {
  const result = [];

  function traverse(node) {
    if (!node) return;

    traverse(node.left);
    traverse(node.right);
    result.push(node.val);
  }

  traverse(root);
  return result;
}
```

#### 非递归实现（使用栈）

```javascript
// 前序遍历（非递归）
function preorderDFSIterative(root) {
  if (!root) return [];

  const result = [];
  const stack = [root];

  while (stack.length > 0) {
    const node = stack.pop();

    // 访问当前节点
    result.push(node.val);

    // 注意：先压入右子节点，再压入左子节点（因为栈是后进先出）
    if (node.right) stack.push(node.right);
    if (node.left) stack.push(node.left);
  }

  return result;
}

// 中序遍历（非递归）
function inorderDFSIterative(root) {
  const result = [];
  const stack = [];
  let current = root;

  while (current || stack.length > 0) {
    // 遍历到最左叶子节点
    while (current) {
      stack.push(current);
      current = current.left;
    }

    // 弹出栈顶元素并访问
    current = stack.pop();
    result.push(current.val);

    // 处理右子树
    current = current.right;
  }

  return result;
}
```

### 2.4 时间复杂度和空间复杂度

- **时间复杂度**：O(V + E)，其中V是节点数，E是边数
- **空间复杂度**：O(V)，最坏情况下需要存储所有节点

## 3. 广度优先搜索 (BFS)

### 3.1 基本概念

广度优先搜索（Breadth-First Search，简称BFS）是一种逐层遍历树或图的算法。与DFS不同，BFS优先访问距离起始节点近的节点，然后再访问距离较远的节点。

### 3.2 算法步骤

1. 从起始节点开始，将其加入队列并标记为已访问
2. 当队列非空时，取出队首节点，访问该节点
3. 将该节点的所有未访问的相邻节点加入队列并标记为已访问
4. 重复步骤2-3直到队列为空

### 3.3 代码实现

#### 树的层序遍历

```javascript
/**
 * 二叉树的层序遍历
 * @param {TreeNode} root 根节点
 * @return {number[][]} 每层节点值的数组
 */
function levelOrder(root) {
  if (!root) return [];

  const result = [];
  const queue = [root];

  while (queue.length > 0) {
    const levelSize = queue.length;
    const currentLevel = [];

    // 处理当前层的所有节点
    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();
      currentLevel.push(node.val);

      // 将下一层节点加入队列
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }

    result.push(currentLevel);
  }

  return result;
}
```

#### 图的BFS（邻接表表示）

```javascript
/**
 * 图的广度优先搜索
 * @param {Map<number, number[]>} graph 邻接表表示的图
 * @param {number} start 起始节点
 * @return {number[]} 访问节点的顺序
 */
function bfs(graph, start) {
  const visited = new Set();
  const queue = [start];
  const result = [];

  visited.add(start);

  while (queue.length > 0) {
    const node = queue.shift();
    result.push(node);

    // 访问所有相邻节点
    const neighbors = graph.get(node) || [];
    for (const neighbor of neighbors) {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.push(neighbor);
      }
    }
  }

  return result;
}
```

### 3.4 时间复杂度和空间复杂度

- **时间复杂度**：O(V + E)，其中V是节点数，E是边数
- **空间复杂度**：O(V)，最坏情况下需要存储所有节点

## 4. 前端应用场景

### 4.1 二分查找的应用

1. **虚拟列表优化**：在处理大型数据列表时，可以使用二分查找快速定位可视区域的起始和结束索引。

```javascript
function findFirstVisibleIndex(items, scrollTop, itemHeight) {
  let left = 0;
  let right = items.length - 1;
  let result = 0;

  while (left <= right) {
    const mid = left + Math.floor((right - left) / 2);
    const itemTop = mid * itemHeight;

    if (itemTop >= scrollTop) {
      result = mid;
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }

  return result;
}
```

2. **自动完成/搜索建议**：在已排序的关键词列表中快速查找匹配项。

3. **日期选择器**：在日期排序列表中定位特定日期。

### 4.2 DFS的应用

1. **DOM树遍历和操作**：遍历DOM树查找特定元素或应用样式。

```javascript
function findElementsByClassName(root, className) {
  const results = [];

  function dfs(node) {
    if (node.classList && node.classList.contains(className)) {
      results.push(node);
    }

    for (const child of node.children) {
      dfs(child);
    }
  }

  dfs(root);
  return results;
}
```

2. **组件树遍历**：在React或Vue等框架中遍历组件树。

3. **状态管理解析**：在Redux或Vuex中的状态对象深度查找。

4. **路径查找问题**：如迷宫、游戏关卡路径等。

### 4.3 BFS的应用

1. **最短路径问题**：如网络请求的最短路径查找。

2. **DOM树级联更新**：按层更新DOM元素。

```javascript
function updateDOMByLevel(root, updateFn) {
  const queue = [root];

  while (queue.length > 0) {
    const size = queue.length;

    for (let i = 0; i < size; i++) {
      const node = queue.shift();
      updateFn(node);

      for (const child of node.children) {
        queue.push(child);
      }
    }
  }
}
```

3. **组件级联渲染**：按层次顺序渲染组件。

4. **网站爬虫**：按层次抓取网站链接。

## 5. 面试常见问题

### 5.1 二分查找相关

1. **二分查找的前提条件是什么？**

   **答案**：二分查找的前提条件是数据必须是有序的（递增或递减排列）。此外，数据结构必须支持随机访问（如数组），不适用于链表等顺序访问的数据结构。

2. **如何在一个旋转排序数组中使用二分查找？**

   **答案**：旋转排序数组是指原本有序的数组被从某个位置旋转，如[4,5,6,7,0,1,2]。在这种情况下，可以先判断中间元素所在的区间是否有序，然后决定在哪个区间继续查找。

   ```javascript
   function searchInRotatedArray(nums, target) {
     let left = 0;
     let right = nums.length - 1;

     while (left <= right) {
       const mid = left + Math.floor((right - left) / 2);

       if (nums[mid] === target) {
         return mid;
       }

       // 判断左半部分是否有序
       if (nums[left] <= nums[mid]) {
         // 目标值在有序的左半部分
         if (nums[left] <= target && target < nums[mid]) {
           right = mid - 1;
         } else {
           left = mid + 1;
         }
       }
       // 右半部分有序
       else {
         // 目标值在有序的右半部分
         if (nums[mid] < target && target <= nums[right]) {
           left = mid + 1;
         } else {
           right = mid - 1;
         }
       }
     }

     return -1;
   }
   ```

3. **二分查找的边界条件如何处理？**

   **答案**：二分查找的边界条件主要有以下几个：
   - 循环条件：使用 `left <= right` 还是 `left < right`
   - 中间值计算：`mid = left + (right - left) / 2` 避免整数溢出
   - 更新边界：当 `arr[mid] > target` 时，使用 `right = mid - 1` 还是 `right = mid`
   - 返回值：查找失败时返回什么值（通常是-1或目标值应该插入的位置）

   这些边界条件的选择取决于具体需求，如查找第一个或最后一个满足条件的元素。

### 5.2 DFS和BFS相关

1. **DFS和BFS各自的优缺点是什么？**

   **答案**：

   **DFS优点**：
   - 实现简单，尤其是使用递归时
   - 内存占用相对较小（在广度较大的树/图中）
   - 适合查找离起点较远的结果
   - 可以方便地生成全部解决方案

   **DFS缺点**：
   - 可能陷入很深的路径而错过更优解
   - 不保证找到最短路径
   - 在解空间很大时可能导致栈溢出

   **BFS优点**：
   - 保证找到最短路径（在边权重相同的情况下）
   - 适合查找离起点较近的结果
   - 不会陷入无限递归的风险

   **BFS缺点**：
   - 内存消耗较大，尤其是在广度较大的树/图中
   - 实现相对复杂
   - 对于深度很大的结构，可能效率较低

   选择使用哪种算法取决于具体问题的性质和要求。

2. **如何判断一个二叉树是否是平衡二叉树？**

   **答案**：平衡二叉树是指任意节点的左右子树高度差不超过1的二叉树。可以使用DFS自底向上地计算高度：

   ```javascript
   function isBalanced(root) {
     // 返回高度，如果不平衡则返回-1
     function getHeight(node) {
       if (!node) return 0;

       const leftHeight = getHeight(node.left);
       if (leftHeight === -1) return -1;

       const rightHeight = getHeight(node.right);
       if (rightHeight === -1) return -1;

       // 检查高度差
       if (Math.abs(leftHeight - rightHeight) > 1) {
         return -1;
       }

       return Math.max(leftHeight, rightHeight) + 1;
     }

     return getHeight(root) !== -1;
   }
   ```

3. **在前端开发中，什么情况下使用BFS比DFS更合适？**

   **答案**：
   - 需要按层级处理DOM节点时（如级联样式或动画）
   - 寻找最近的满足条件的元素时
   - 需要考虑节点间距离时（如事件冒泡路径的最短路径）
   - 实现广度优先的渲染策略时
   - 在内存有限的情况下处理较浅但宽度大的树结构时

   例如，当实现一个点击事件处理器，需要找到最近的带有特定属性的父元素时，BFS比DFS更为合适。

### 5.3 综合问题

1. **如何优化大数据量下的查找操作？**

   **答案**：优化大数据量下查找操作的策略：
   - 确保数据已排序，使用二分查找代替线性查找
   - 使用哈希表进行O(1)的查找（以空间换时间）
   - 实现索引结构，如B树、前缀树等
   - 分块存储和查找，减少每次处理的数据量
   - 使用Web Worker进行并行查找
   - 虚拟化显示，只渲染可见区域的数据
   - 实现延迟加载策略

   具体选择取决于数据特性、查询模式和性能要求。

2. **如何在前端实现一个高效的搜索建议功能？**

   **答案**：实现高效搜索建议功能的方法：
   - 使用前缀树(Trie)存储候选词
   - 实现节流/防抖限制搜索频率
   - 使用二分查找在已排序结果中定位匹配项
   - 缓存常见查询的结果
   - 预加载热门搜索词
   - 优先展示部分结果，异步加载更多
   - 使用索引优化（如倒排索引）
   - 实现模糊匹配算法

   ```javascript
   // 简单的搜索建议实现
   function searchSuggestions(query, dictionary) {
     const lowercaseQuery = query.toLowerCase();
     return dictionary
       .filter(word => word.toLowerCase().startsWith(lowercaseQuery))
       .sort((a, b) => a.length - b.length)
       .slice(0, 5); // 限制返回数量
   }
   ```

## 6. 学习资源

- [二分查找详解 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
- [深度优先搜索与广度优先搜索 - GeeksforGeeks](https://www.geeksforgeeks.org/difference-between-bfs-and-dfs/)
- [前端常见算法 - GitHub](https://github.com/trekhleb/javascript-algorithms)
- [LeetCode 查找专题](https://leetcode.com/tag/binary-search/)
- [前端进阶之路 - 算法篇](https://juejin.cn/post/6844903776512393224)