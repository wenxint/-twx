# 树与二叉树

## 树的基本概念

树是一种非线性的数据结构，由节点和边组成，没有环路。树具有以下特点：

- 每个节点有零个或多个子节点
- 除了根节点外，每个节点都有且只有一个父节点
- 没有环路（即不存在从某个节点出发，经过若干个节点后又回到该节点的路径）
- 任意两个节点之间有且仅有一条路径相连

### 树的术语

- **节点（Node）**：树中的基本单位，包含数据和指向子节点的链接
- **根节点（Root）**：树的顶部节点，没有父节点
- **父节点（Parent）**：直接连接到子节点的节点
- **子节点（Child）**：直接连接到父节点的节点
- **兄弟节点（Siblings）**：共享同一个父节点的节点
- **叶节点（Leaf）**：没有子节点的节点
- **边（Edge）**：连接两个节点的线
- **路径（Path）**：从一个节点到另一个节点的节点序列
- **深度（Depth）**：从根节点到该节点的边的数量
- **高度（Height）**：从该节点到最远叶节点的边的数量
- **层级（Level）**：节点的深度加1
- **度（Degree）**：节点的子节点数量

## 二叉树

### 基本概念

二叉树是一种特殊的树，其中每个节点最多有两个子节点，通常称为左子节点和右子节点。

### 二叉树的类型

1. **满二叉树（Full Binary Tree）**：每个节点要么有0个子节点，要么有2个子节点
2. **完全二叉树（Complete Binary Tree）**：除了最后一层外，其他层都被完全填充，且最后一层的所有节点都尽可能地靠左
3. **完美二叉树（Perfect Binary Tree）**：所有内部节点都有两个子节点，所有叶节点都在同一层
4. **平衡二叉树（Balanced Binary Tree）**：任意节点的左右子树高度差不超过1
5. **二叉搜索树（Binary Search Tree）**：左子树上所有节点的值都小于根节点的值，右子树上所有节点的值都大于根节点的值

### JavaScript实现二叉树节点

```javascript
class TreeNode {
  constructor(val) {
    this.val = val;
    this.left = null;
    this.right = null;
  }
}
```

## 二叉搜索树（BST）

### 基本概念

二叉搜索树是一种特殊的二叉树，具有以下性质：

- 左子树上所有节点的值都小于根节点的值
- 右子树上所有节点的值都大于根节点的值
- 左右子树也分别是二叉搜索树

这种结构使得查找、插入和删除操作的平均时间复杂度为O(log n)。

### JavaScript实现二叉搜索树

```javascript
class BinarySearchTree {
  constructor() {
    this.root = null;
  }

  // 插入节点
  insert(val) {
    const newNode = new TreeNode(val);

    if (this.root === null) {
      this.root = newNode;
      return this;
    }

    let current = this.root;

    while (true) {
      if (val === current.val) return undefined; // 值已存在

      if (val < current.val) {
        if (current.left === null) {
          current.left = newNode;
          return this;
        }
        current = current.left;
      } else {
        if (current.right === null) {
          current.right = newNode;
          return this;
        }
        current = current.right;
      }
    }
  }

  // 查找节点
  find(val) {
    if (this.root === null) return false;

    let current = this.root;
    let found = false;

    while (current && !found) {
      if (val < current.val) {
        current = current.left;
      } else if (val > current.val) {
        current = current.right;
      } else {
        found = true;
      }
    }

    if (!found) return false;
    return current;
  }

  // 检查值是否存在
  contains(val) {
    if (this.root === null) return false;

    let current = this.root;

    while (current) {
      if (val < current.val) {
        current = current.left;
      } else if (val > current.val) {
        current = current.right;
      } else {
        return true;
      }
    }

    return false;
  }
}

// 使用示例
const bst = new BinarySearchTree();
bst.insert(10);
bst.insert(5);
bst.insert(15);
bst.insert(2);
bst.insert(7);
console.log(bst.contains(7)); // true
console.log(bst.contains(9)); // false
```

## 树的遍历

树的遍历是指按照特定顺序访问树中的每个节点。主要有两类遍历方式：深度优先遍历（DFS）和广度优先遍历（BFS）。

### 深度优先遍历（DFS）

深度优先遍历优先探索树的深度，有三种主要方式：

#### 1. 前序遍历（Preorder）

访问顺序：根节点 -> 左子树 -> 右子树

```javascript
// 递归实现
function preorderTraversal(root) {
  const result = [];

  function traverse(node) {
    if (node === null) return;

    // 访问根节点
    result.push(node.val);
    // 遍历左子树
    traverse(node.left);
    // 遍历右子树
    traverse(node.right);
  }

  traverse(root);
  return result;
}

// 迭代实现
function preorderTraversalIterative(root) {
  if (root === null) return [];

  const result = [];
  const stack = [root];

  while (stack.length > 0) {
    const node = stack.pop();

    // 访问节点
    result.push(node.val);

    // 先将右子节点入栈，再将左子节点入栈
    // 这样出栈时会先处理左子节点
    if (node.right !== null) stack.push(node.right);
    if (node.left !== null) stack.push(node.left);
  }

  return result;
}
```

#### 2. 中序遍历（Inorder）

访问顺序：左子树 -> 根节点 -> 右子树

对于二叉搜索树，中序遍历会按照升序访问节点。

```javascript
// 递归实现
function inorderTraversal(root) {
  const result = [];

  function traverse(node) {
    if (node === null) return;

    // 遍历左子树
    traverse(node.left);
    // 访问根节点
    result.push(node.val);
    // 遍历右子树
    traverse(node.right);
  }

  traverse(root);
  return result;
}

// 迭代实现
function inorderTraversalIterative(root) {
  const result = [];
  const stack = [];
  let current = root;

  while (current !== null || stack.length > 0) {
    // 遍历到最左边的节点
    while (current !== null) {
      stack.push(current);
      current = current.left;
    }

    // 弹出栈顶节点并访问
    current = stack.pop();
    result.push(current.val);

    // 处理右子树
    current = current.right;
  }

  return result;
}
```

#### 3. 后序遍历（Postorder）

访问顺序：左子树 -> 右子树 -> 根节点

```javascript
// 递归实现
function postorderTraversal(root) {
  const result = [];

  function traverse(node) {
    if (node === null) return;

    // 遍历左子树
    traverse(node.left);
    // 遍历右子树
    traverse(node.right);
    // 访问根节点
    result.push(node.val);
  }

  traverse(root);
  return result;
}

// 迭代实现
function postorderTraversalIterative(root) {
  if (root === null) return [];

  const result = [];
  const stack = [root];

  while (stack.length > 0) {
    const node = stack.pop();

    // 将当前节点值插入到结果的开头
    result.unshift(node.val);

    // 先将左子节点入栈，再将右子节点入栈
    if (node.left !== null) stack.push(node.left);
    if (node.right !== null) stack.push(node.right);
  }

  return result;
}
```

### 广度优先遍历（BFS）

广度优先遍历按层级访问节点，也称为层序遍历（Level Order Traversal）。

```javascript
function levelOrderTraversal(root) {
  if (root === null) return [];

  const result = [];
  const queue = [root];

  while (queue.length > 0) {
    const levelSize = queue.length;
    const currentLevel = [];

    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();

      // 访问当前节点
      currentLevel.push(node.val);

      // 将子节点加入队列
      if (node.left !== null) queue.push(node.left);
      if (node.right !== null) queue.push(node.right);
    }

    result.push(currentLevel);
  }

  return result;
}
```

## 平衡二叉树

### AVL树

AVL树是一种自平衡的二叉搜索树，其中任意节点的左右子树高度差不超过1。每次插入或删除操作后，可能需要通过旋转操作来保持平衡。

### 红黑树

红黑树是另一种自平衡的二叉搜索树，通过为每个节点着色（红色或黑色）并满足一系列性质来保持平衡。红黑树在实际应用中比AVL树更常用，因为它的插入和删除操作需要的旋转次数更少。

## 树的应用

1. **文件系统**：目录结构是一个树形结构
2. **DOM**：HTML文档的DOM结构是一个树
3. **组织架构**：公司的组织结构通常是树形的
4. **决策树**：用于决策分析和机器学习
5. **编译器**：语法分析生成的抽象语法树（AST）
6. **数据库索引**：B树和B+树用于数据库索引
7. **网络路由**：路由算法中的最小生成树

## 树的时间复杂度

对于平衡的二叉搜索树：

| 操作 | 平均时间复杂度 | 最坏时间复杂度 |
|------|--------------|---------------|
| 访问 | O(log n) | O(log n) |
| 搜索 | O(log n) | O(log n) |
| 插入 | O(log n) | O(log n) |
| 删除 | O(log n) | O(log n) |

对于不平衡的二叉搜索树（最坏情况下退化为链表）：

| 操作 | 最坏时间复杂度 |
|------|---------------|
| 访问 | O(n) |
| 搜索 | O(n) |
| 插入 | O(n) |
| 删除 | O(n) |

## 前端应用场景

### 树在前端中的应用

1. **DOM操作**：浏览器将HTML解析为DOM树，前端开发中经常需要遍历和操作DOM树
2. **虚拟DOM**：React等框架使用虚拟DOM树来优化渲染性能
3. **组件树**：前端框架中的组件通常组织为树形结构
4. **状态管理**：Redux等状态管理库中的状态可以表示为树形结构
5. **路由系统**：前端路由通常组织为树形结构
6. **文件目录**：文件浏览器或编辑器中的文件目录树
7. **树形控件**：如树形菜单、组织架构图等UI组件
8. **语法分析**：JavaScript解析器将代码解析为抽象语法树（AST）

### 实际案例

#### 实现树形菜单组件

```javascript
// 树节点数据结构
const treeData = [
  {
    id: '1',
    label: '一级菜单A',
    children: [
      {
        id: '1-1',
        label: '二级菜单A-1',
        children: [
          { id: '1-1-1', label: '三级菜单A-1-1' },
          { id: '1-1-2', label: '三级菜单A-1-2' }
        ]
      },
      { id: '1-2', label: '二级菜单A-2' }
    ]
  },
  {
    id: '2',
    label: '一级菜单B',
    children: [
      { id: '2-1', label: '二级菜单B-1' },
      { id: '2-2', label: '二级菜单B-2' }
    ]
  }
];

// React树形菜单组件
function TreeNode({ node, level = 0 }) {
  const [expanded, setExpanded] = useState(false);

  const hasChildren = node.children && node.children.length > 0;

  return (
    <div className="tree-node" style={{ marginLeft: `${level * 20}px` }}>
      <div className="node-content">
        {hasChildren && (
          <span
            className={`expand-icon ${expanded ? 'expanded' : ''}`}
            onClick={() => setExpanded(!expanded)}
          >
            {expanded ? '▼' : '►'}
          </span>
        )}
        <span className="node-label">{node.label}</span>
      </div>

      {expanded && hasChildren && (
        <div className="node-children">
          {node.children.map(child => (
            <TreeNode
              key={child.id}
              node={child}
              level={level + 1}
            />
          ))}
        </div>
      )}
    </div>
  );
}

function TreeMenu({ data }) {
  return (
    <div className="tree-menu">
      {data.map(node => (
        <TreeNode key={node.id} node={node} />
      ))}
    </div>
  );
}
```

## 常见算法题

### 1. 二叉树的最大深度

```javascript
/**
 * 计算二叉树的最大深度
 * @param {TreeNode} root 二叉树根节点
 * @return {number} 最大深度
 */
function maxDepth(root) {
  if (root === null) return 0;

  const leftDepth = maxDepth(root.left);
  const rightDepth = maxDepth(root.right);

  return Math.max(leftDepth, rightDepth) + 1;
}
```

### 2. 验证二叉搜索树

```javascript
/**
 * 验证一棵树是否是二叉搜索树
 * @param {TreeNode} root 二叉树根节点
 * @return {boolean} 是否是二叉搜索树
 */
function isValidBST(root) {
  function validate(node, lower, upper) {
    if (node === null) return true;

    if ((lower !== null && node.val <= lower) ||
        (upper !== null && node.val >= upper)) {
      return false;
    }

    return validate(node.left, lower, node.val) &&
           validate(node.right, node.val, upper);
  }

  return validate(root, null, null);
}
```

### 3. 二叉树的层序遍历

```javascript
/**
 * 二叉树的层序遍历
 * @param {TreeNode} root 二叉树根节点
 * @return {number[][]} 层序遍历结果
 */
function levelOrder(root) {
  if (root === null) return [];

  const result = [];
  const queue = [root];

  while (queue.length > 0) {
    const levelSize = queue.length;
    const currentLevel = [];

    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();
      currentLevel.push(node.val);

      if (node.left !== null) queue.push(node.left);
      if (node.right !== null) queue.push(node.right);
    }

    result.push(currentLevel);
  }

  return result;
}
```

### 4. 对称二叉树

```javascript
/**
 * 判断二叉树是否是对称的
 * @param {TreeNode} root 二叉树根节点
 * @return {boolean} 是否对称
 */
function isSymmetric(root) {
  if (root === null) return true;

  function isMirror(left, right) {
    if (left === null && right === null) return true;
    if (left === null || right === null) return false;

    return (left.val === right.val) &&
           isMirror(left.left, right.right) &&
           isMirror(left.right, right.left);
  }

  return isMirror(root.left, root.right);
}
```

### 5. 路径总和

```javascript
/**
 * 判断是否存在从根节点到叶节点的路径，使得路径上所有节点值相加等于目标和
 * @param {TreeNode} root 二叉树根节点
 * @param {number} targetSum 目标和
 * @return {boolean} 是否存在这样的路径
 */
function hasPathSum(root, targetSum) {
  if (root === null) return false;

  // 如果是叶节点，检查值是否等于目标和
  if (root.left === null && root.right === null) {
    return root.val === targetSum;
  }

  // 递归检查左右子树，目标和减去当前节点的值
  return hasPathSum(root.left, targetSum - root.val) ||
         hasPathSum(root.right, targetSum - root.val);
}
```

## 面试常见问题

1. 什么是二叉树？它与普通树有什么区别？
2. 什么是二叉搜索树？它有哪些特性？
3. 二叉树的前序、中序和后序遍历有什么区别？
4. 如何判断一棵二叉树是否是平衡的？
5. 什么是完全二叉树和满二叉树？
6. 如何实现二叉树的层序遍历？
7. 红黑树和AVL树有什么区别？
8. 如何在二叉搜索树中查找第k小的元素？
9. 如何序列化和反序列化二叉树？
10. 在前端开发中，树结构有哪些常见应用？

## 学习资源

- [MDN Web Docs - 树数据结构](https://developer.mozilla.org/zh-CN/docs/Glossary/Tree) - 树的基本概念
- [JavaScript数据结构 - 树](https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/tree) - GitHub上的JS实现
- [LeetCode树题集](https://leetcode.com/tag/tree/) - 树相关算法练习
- [前端进阶之道 - 树结构](https://juejin.cn/post/6844903606281904141) - 前端视角的树结构讲解
- [可视化算法](https://visualgo.net/en/bst) - 二叉搜索树的可视化学习工具