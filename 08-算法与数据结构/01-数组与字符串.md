# 数组与字符串

## 数组基础

### 数组的定义

数组是一种线性数据结构，用于存储相同类型的元素集合。在JavaScript中，数组可以存储不同类型的元素，并且是动态的，可以根据需要调整大小。

### JavaScript中的数组特性

1. **动态大小**：JavaScript数组的大小可以动态调整
2. **混合类型**：可以存储不同类型的元素
3. **稀疏数组**：索引不一定连续，可以有空槽
4. **类数组对象**：某些JavaScript对象（如arguments、NodeList）类似数组但不是真正的数组

### 数组的基本操作

#### 创建数组

```javascript
// 字面量语法
const arr1 = [1, 2, 3, 4, 5];

// 构造函数语法
const arr2 = new Array(1, 2, 3, 4, 5);

// 创建指定长度的空数组
const arr3 = new Array(5); // 创建长度为5的空数组

// Array.from 方法
const arr4 = Array.from('hello'); // ['h', 'e', 'l', 'l', 'o']

// Array.of 方法
const arr5 = Array.of(5); // [5]，与 new Array(5) 不同
```

#### 访问和修改元素

```javascript
const arr = [10, 20, 30, 40, 50];

// 访问元素
console.log(arr[0]); // 10
console.log(arr[2]); // 30

// 修改元素
arr[1] = 25;
console.log(arr); // [10, 25, 30, 40, 50]

// 获取数组长度
console.log(arr.length); // 5

// 通过修改length属性可以截断数组
arr.length = 3;
console.log(arr); // [10, 25, 30]
```

#### 添加和删除元素

```javascript
const arr = [1, 2, 3];

// 末尾添加元素
arr.push(4, 5);
console.log(arr); // [1, 2, 3, 4, 5]

// 开头添加元素
arr.unshift(0);
console.log(arr); // [0, 1, 2, 3, 4, 5]

// 末尾删除元素
const lastElement = arr.pop();
console.log(lastElement); // 5
console.log(arr); // [0, 1, 2, 3, 4]

// 开头删除元素
const firstElement = arr.shift();
console.log(firstElement); // 0
console.log(arr); // [1, 2, 3, 4]

// 任意位置添加/删除元素
// splice(起始索引, 删除数量, 添加的元素...)
arr.splice(1, 1, 'a', 'b');
console.log(arr); // [1, 'a', 'b', 3, 4]
```

## 数组常用方法

### 遍历数组

```javascript
const arr = [1, 2, 3, 4, 5];

// for循环
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}

// for...of循环
for (const item of arr) {
  console.log(item);
}

// forEach方法
arr.forEach((item, index) => {
  console.log(`索引${index}: ${item}`);
});

// map方法 - 返回新数组
const doubled = arr.map(item => item * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

// filter方法 - 返回符合条件的元素组成的新数组
const evenNumbers = arr.filter(item => item % 2 === 0);
console.log(evenNumbers); // [2, 4]

// reduce方法 - 将数组减少为单个值
const sum = arr.reduce((accumulator, current) => accumulator + current, 0);
console.log(sum); // 15
```

### 查找元素

```javascript
const arr = [10, 20, 30, 40, 20, 50];

// indexOf - 返回第一个匹配元素的索引，未找到返回-1
console.log(arr.indexOf(20)); // 1
console.log(arr.indexOf(60)); // -1

// lastIndexOf - 从后向前查找
console.log(arr.lastIndexOf(20)); // 4

// includes - 检查数组是否包含某个元素
console.log(arr.includes(30)); // true
console.log(arr.includes(60)); // false

// find - 返回第一个满足条件的元素
const found = arr.find(item => item > 25);
console.log(found); // 30

// findIndex - 返回第一个满足条件的元素的索引
const foundIndex = arr.findIndex(item => item > 25);
console.log(foundIndex); // 2
```

### 数组排序和操作

```javascript
const arr = [3, 1, 4, 1, 5, 9, 2, 6];

// sort - 对数组进行排序（默认按字符串顺序）
arr.sort();
console.log(arr); // [1, 1, 2, 3, 4, 5, 6, 9]

// 自定义排序函数
const nums = [10, 5, 8, 2, 1];
nums.sort((a, b) => a - b); // 升序
console.log(nums); // [1, 2, 5, 8, 10]

// reverse - 反转数组
nums.reverse();
console.log(nums); // [10, 8, 5, 2, 1]

// concat - 合并数组
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const combined = arr1.concat(arr2);
console.log(combined); // [1, 2, 3, 4, 5, 6]

// slice - 提取数组的一部分
const sliced = combined.slice(2, 5);
console.log(sliced); // [3, 4, 5]

// join - 将数组元素连接成字符串
const joined = arr1.join('-');
console.log(joined); // "1-2-3"
```

### ES6+新增数组方法

```javascript
// Array.from - 从类数组对象或可迭代对象创建新数组
const str = 'hello';
const chars = Array.from(str);
console.log(chars); // ['h', 'e', 'l', 'l', 'o']

// Array.of - 创建具有可变数量参数的新数组
const arr = Array.of(1, 2, 3);
console.log(arr); // [1, 2, 3]

// fill - 用固定值填充数组
const filled = new Array(3).fill(0);
console.log(filled); // [0, 0, 0]

// flat - 扁平化嵌套数组
const nested = [1, [2, [3, 4]]];
console.log(nested.flat()); // [1, 2, [3, 4]]
console.log(nested.flat(2)); // [1, 2, 3, 4]

// flatMap - 先映射再扁平化
const sentences = ['hello world', 'goodbye world'];
const words = sentences.flatMap(sentence => sentence.split(' '));
console.log(words); // ['hello', 'world', 'goodbye', 'world']
```

## 数组的时间复杂度

| 操作 | 时间复杂度 | 说明 |
|------|-----------|------|
| 访问元素 | O(1) | 通过索引直接访问 |
| 查找元素 | O(n) | 需要遍历数组 |
| push/pop | O(1) | 在末尾添加/删除元素 |
| unshift/shift | O(n) | 在开头添加/删除元素，需要移动其他元素 |
| splice | O(n) | 可能需要移动元素 |
| sort | O(n log n) | 排序算法的平均时间复杂度 |

## 字符串基础

### 字符串的定义

字符串是由零个或多个字符组成的有序序列。在JavaScript中，字符串是不可变的，这意味着一旦创建，就不能修改。

### 创建字符串

```javascript
// 字符串字面量
const str1 = 'Hello';
const str2 = "World";
const str3 = `Hello World`; // 模板字符串（ES6）

// String构造函数
const str4 = new String('Hello'); // 创建String对象，不推荐
```

### 字符串的基本操作

#### 访问字符

```javascript
const str = 'Hello';

// 使用charAt方法
console.log(str.charAt(0)); // 'H'

// 使用方括号（类似数组）
console.log(str[1]); // 'e'

// 获取字符串长度
console.log(str.length); // 5
```

#### 字符串拼接

```javascript
const firstName = 'John';
const lastName = 'Doe';

// 使用+运算符
const fullName1 = firstName + ' ' + lastName;
console.log(fullName1); // 'John Doe'

// 使用模板字符串（ES6）
const fullName2 = `${firstName} ${lastName}`;
console.log(fullName2); // 'John Doe'

// 使用concat方法
const fullName3 = firstName.concat(' ', lastName);
console.log(fullName3); // 'John Doe'
```

## 字符串常用方法

### 查找和提取

```javascript
const str = 'Hello World';

// indexOf - 查找子字符串，返回首次出现的索引
console.log(str.indexOf('o')); // 4
console.log(str.indexOf('o', 5)); // 7 (从索引5开始查找)

// lastIndexOf - 从后向前查找
console.log(str.lastIndexOf('o')); // 7

// includes - 检查是否包含子字符串
console.log(str.includes('World')); // true

// startsWith/endsWith - 检查是否以特定子字符串开始/结束
console.log(str.startsWith('Hello')); // true
console.log(str.endsWith('World')); // true

// substring - 提取子字符串
console.log(str.substring(0, 5)); // 'Hello'

// slice - 提取子字符串，支持负索引
console.log(str.slice(6)); // 'World'
console.log(str.slice(-5)); // 'World'

// split - 分割字符串为数组
console.log(str.split(' ')); // ['Hello', 'World']
```

### 修改字符串

```javascript
const str = 'Hello World';

// replace - 替换子字符串（只替换第一个匹配项）
console.log(str.replace('o', 'x')); // 'Hellx World'

// replaceAll - 替换所有匹配项（ES2021）
console.log(str.replaceAll('o', 'x')); // 'Hellx Wxrld'

// toLowerCase/toUpperCase - 转换为小写/大写
console.log(str.toLowerCase()); // 'hello world'
console.log(str.toUpperCase()); // 'HELLO WORLD'

// trim - 去除首尾空格
const paddedStr = '  Hello World  ';
console.log(paddedStr.trim()); // 'Hello World'
console.log(paddedStr.trimStart()); // 'Hello World  '
console.log(paddedStr.trimEnd()); // '  Hello World'

// padStart/padEnd - 填充字符串到指定长度
console.log('5'.padStart(3, '0')); // '005'
console.log('5'.padEnd(3, '0')); // '500'
```

### 正则表达式与字符串

```javascript
const str = 'Hello World 123';

// match - 查找匹配项
const matches = str.match(/\d+/); // 查找数字
console.log(matches[0]); // '123'

// matchAll - 查找所有匹配项（ES2020）
const regex = /[a-z]/g; // 查找所有小写字母
const allMatches = [...str.matchAll(regex)];
console.log(allMatches.map(match => match[0])); // ['e', 'l', 'l', 'o', 'o', 'r', 'l', 'd']

// search - 查找匹配项的索引
console.log(str.search(/\d+/)); // 12

// test - 检查是否存在匹配项
console.log(/World/.test(str)); // true
```

## 字符串的时间复杂度

| 操作 | 时间复杂度 | 说明 |
|------|-----------|------|
| 访问字符 | O(1) | 通过索引直接访问 |
| 查找子字符串 | O(n*m) | n是字符串长度，m是子字符串长度 |
| 拼接字符串 | O(n+m) | n和m是两个字符串的长度 |
| 替换子字符串 | O(n) | n是字符串长度 |

## 数组和字符串的常见算法题

### 1. 两数之和

```javascript
/**
 * 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数的索引
 */
function twoSum(nums, target) {
  const map = new Map();

  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i];

    if (map.has(complement)) {
      return [map.get(complement), i];
    }

    map.set(nums[i], i);
  }

  return [];
}

console.log(twoSum([2, 7, 11, 15], 9)); // [0, 1]
```

### 2. 回文字符串判断

```javascript
/**
 * 判断一个字符串是否是回文字符串（正着读和倒着读一样）
 */
function isPalindrome(s) {
  // 将字符串转换为小写，并移除非字母数字字符
  s = s.toLowerCase().replace(/[^a-z0-9]/g, '');

  // 双指针法
  let left = 0;
  let right = s.length - 1;

  while (left < right) {
    if (s[left] !== s[right]) {
      return false;
    }
    left++;
    right--;
  }

  return true;
}

console.log(isPalindrome("A man, a plan, a canal: Panama")); // true
console.log(isPalindrome("race a car")); // false
```

### 3. 最长公共前缀

```javascript
/**
 * 查找字符串数组中的最长公共前缀
 */
function longestCommonPrefix(strs) {
  if (strs.length === 0) return "";

  // 以第一个字符串为基准
  let prefix = strs[0];

  for (let i = 1; i < strs.length; i++) {
    // 当前字符串不以prefix为前缀时，缩短prefix
    while (strs[i].indexOf(prefix) !== 0) {
      prefix = prefix.substring(0, prefix.length - 1);
      if (prefix === "") return "";
    }
  }

  return prefix;
}

console.log(longestCommonPrefix(["flower", "flow", "flight"])); // "fl"
console.log(longestCommonPrefix(["dog", "racecar", "car"])); // ""
```

### 4. 有效的括号

```javascript
/**
 * 判断字符串中的括号是否有效匹配
 */
function isValidParentheses(s) {
  const stack = [];
  const map = {
    '(': ')',
    '[': ']',
    '{': '}'
  };

  for (let i = 0; i < s.length; i++) {
    const char = s[i];

    if (map[char]) { // 左括号
      stack.push(char);
    } else { // 右括号
      const top = stack.pop();

      if (map[top] !== char) {
        return false;
      }
    }
  }

  return stack.length === 0;
}

console.log(isValidParentheses("()[]{}")); // true
console.log(isValidParentheses("([)]")); // false
```

### 5. 合并两个有序数组

```javascript
/**
 * 合并两个有序数组
 */
function merge(nums1, m, nums2, n) {
  let i = m - 1; // nums1的末尾索引
  let j = n - 1; // nums2的末尾索引
  let k = m + n - 1; // 合并后数组的末尾索引

  while (i >= 0 && j >= 0) {
    if (nums1[i] > nums2[j]) {
      nums1[k--] = nums1[i--];
    } else {
      nums1[k--] = nums2[j--];
    }
  }

  // 如果nums2还有剩余元素
  while (j >= 0) {
    nums1[k--] = nums2[j--];
  }

  return nums1;
}

console.log(merge([1, 3, 5, 0, 0, 0], 3, [2, 4, 6], 3)); // [1, 2, 3, 4, 5, 6]
```

## 前端应用场景

### 数组应用场景

1. **数据列表渲染**：使用数组存储列表数据，通过map方法渲染到UI
2. **表单数据处理**：收集表单字段值到数组中进行批量处理
3. **分页数据处理**：存储分页数据和处理分页逻辑
4. **状态管理**：在Redux等状态管理库中存储应用状态
5. **虚拟DOM diff算法**：使用数组表示组件树结构
6. **事件处理**：存储和管理事件监听器
7. **数据缓存**：缓存API请求结果

### 字符串应用场景

1. **表单验证**：验证用户输入的格式（邮箱、手机号等）
2. **URL处理**：解析和构建URL
3. **模板渲染**：使用模板字符串生成HTML
4. **国际化**：处理多语言文本
5. **富文本编辑**：处理和格式化文本内容
6. **数据格式化**：格式化日期、货币等
7. **搜索功能**：实现文本搜索和高亮

## 面试常见问题

1. JavaScript中数组和对象的区别是什么？

   **答案**：JavaScript中数组和对象有以下主要区别：
   - **索引类型**：数组使用整数索引，对象使用字符串（或Symbol）键。
   - **顺序性**：数组元素有顺序且保留顺序，对象属性在ES2015之前不保证顺序。
   - **长度属性**：数组有自动维护的`length`属性，对象没有。
   - **原型链**：数组继承自`Array.prototype`，而对象继承自`Object.prototype`。
   - **内置方法**：数组有大量用于迭代和转换的内置方法（如map、filter、reduce等）。
   - **内存布局**：在实现上，JavaScript引擎会对数组进行优化，特别是包含相同类型数据的密集数组。

   ```javascript
   // 数组例子
   const arr = [1, 2, 3];
   console.log(arr[0]); // 1
   console.log(arr.length); // 3

   // 对象例子
   const obj = { a: 1, b: 2, c: 3 };
   console.log(obj.a); // 1
   console.log(obj['b']); // 2
   ```

2. 如何判断一个变量是否是数组？

   **答案**：判断一个变量是否是数组有以下几种方法：

   ```javascript
   // 1. 使用Array.isArray()方法（ES5+，推荐使用）
   Array.isArray([1, 2, 3]); // true
   Array.isArray({foo: 123}); // false

   // 2. 使用instanceof运算符
   [1, 2, 3] instanceof Array; // true

   // 3. 使用Object.prototype.toString.call()
   Object.prototype.toString.call([1, 2, 3]) === '[object Array]'; // true

   // 4. 使用构造函数
   [1, 2, 3].constructor === Array; // true
   ```

   其中，`Array.isArray()`是最可靠的方法，它能正确处理跨窗口(iframe)的数组对象，而instanceof在跨窗口情况下可能失效。对于不支持ES5的老旧环境，可以使用Object.prototype.toString.call()方法。

3. 数组的forEach和map方法有什么区别？

   **答案**：`forEach`和`map`的主要区别在于：

   - **返回值**：`map`返回一个新数组，包含每次回调函数的返回值；`forEach`返回undefined，不创建新数组。
   - **用途**：`map`用于数据转换，当你需要将数组转换为另一个数组时使用；`forEach`用于执行副作用(side effects)，如打印值或更新外部变量。
   - **链式调用**：由于`map`返回数组，可以继续链式调用其他数组方法；`forEach`不返回有意义的值，无法链式调用。
   - **性能**：对于纯粹的迭代而不需要新数组时，`forEach`性能略好一些；若需要新数组，`map`更直接。

   ```javascript
   const numbers = [1, 2, 3, 4];

   // forEach 示例 - 仅执行操作
   let sum = 0;
   numbers.forEach(num => {
     sum += num;
   });
   console.log(sum); // 10

   // map 示例 - 创建新数组
   const doubled = numbers.map(num => num * 2);
   console.log(doubled); // [2, 4, 6, 8]
   ```

4. 如何实现数组去重？

   **答案**：实现数组去重有多种方法，各有优缺点：

   ```javascript
   const arr = [1, 2, 2, 3, 4, 4, 5];

   // 1. 使用Set（ES6+，最简洁高效）
   const unique1 = [...new Set(arr)];
   // 或
   const unique1Alt = Array.from(new Set(arr));

   // 2. 使用filter和indexOf
   const unique2 = arr.filter((item, index) => arr.indexOf(item) === index);

   // 3. 使用reduce和includes
   const unique3 = arr.reduce((acc, curr) => {
     if (!acc.includes(curr)) {
       acc.push(curr);
     }
     return acc;
   }, []);

   // 4. 使用Map
   const unique4 = Array.from(new Map(arr.map(item => [item, item])).values());

   // 5. 使用Object对象（不适用于复杂对象数组）
   function uniqueUsingObject(arr) {
     const obj = {};
     return arr.filter(item => {
       return obj.hasOwnProperty(typeof item + item) ?
         false : (obj[typeof item + item] = true);
     });
   }

   console.log(unique1); // [1, 2, 3, 4, 5]
   ```

   性能上，Set方法通常是最快的，尤其是对大型数组；但对于对象数组，可能需要自定义比较逻辑或将对象序列化。

5. 字符串和数组有什么相似之处和不同之处？

   **答案**：字符串和数组的相似点和不同点：

   **相似之处**：
   - 都是有序集合，可以通过索引访问元素
   - 都有length属性
   - 都可以使用for循环或for...of遍历
   - 都有许多内置方法（如indexOf, slice等）

   **不同之处**：
   - **可变性**：数组是可变的(mutable)，可以修改元素；字符串是不可变的(immutable)，操作会返回新字符串
   - **元素类型**：数组可以存储任意类型的值；字符串只能包含字符
   - **可用方法**：数组有更多用于修改的方法（push, pop, splice等）；字符串方法总是返回新字符串
   - **类型**：数组是对象类型，字符串是基本数据类型（虽然可以被临时包装为String对象）

   ```javascript
   // 相似点示例
   const str = "hello";
   const arr = ['h', 'e', 'l', 'l', 'o'];

   console.log(str[0]); // "h"
   console.log(arr[0]); // "h"

   console.log(str.length); // 5
   console.log(arr.length); // 5

   // 不同点示例
   arr[0] = 'H'; // 可以修改
   console.log(arr); // ['H', 'e', 'l', 'l', 'o']

   // 字符串不能通过索引修改
   str[0] = 'H';
   console.log(str); // 仍然是 "hello"

   // 字符串操作返回新字符串
   const newStr = str.toUpperCase();
   console.log(str); // "hello" - 原字符串不变
   console.log(newStr); // "HELLO" - 返回新字符串
   ```

6. JavaScript中字符串为什么是不可变的？这有什么影响？

   **答案**：JavaScript中字符串之所以不可变，主要出于以下考虑：

   - **性能优化**：不可变字符串可以进行内存共享、缓存哈希值，提高字符串比较和操作效率
   - **安全性**：特别是在作为对象键或涉及网络安全的场景中
   - **简化实现**：避免字符串修改引发的级联更新

   这种不可变性的影响包括：

   - **创建新实例**：每次字符串操作（如连接、替换）都会创建新字符串，而不是修改原字符串
   - **内存使用**：大量字符串操作可能导致内存使用增加（创建临时字符串）
   - **性能考量**：在需要频繁修改的场景中，使用可变数据结构如数组或StringBuffer更高效
   - **编程风格**：鼓励函数式编程风格，强调值不变性

   ```javascript
   let str = "hello";

   // 这看起来是修改，但实际上是创建新字符串并重新赋值
   str = str + " world";

   // 在循环中频繁拼接字符串会影响性能
   let result = "";
   for (let i = 0; i < 1000; i++) {
     result += i; // 每次迭代都创建新字符串
   }

   // 更高效的方式是使用数组，然后join
   const parts = [];
   for (let i = 0; i < 1000; i++) {
     parts.push(i);
   }
   result = parts.join('');
   ```

7. 如何高效地拼接大量字符串？

   **答案**：高效拼接大量字符串的方法：

   ```javascript
   // 1. 使用数组join（推荐用于大量字符串）
   function efficientConcat1(strings) {
     return strings.join('');
   }

   // 2. 使用数组以及push和join的组合
   function efficientConcat2(strings) {
     const parts = [];
     for (let i = 0; i < strings.length; i++) {
       parts.push(strings[i]);
     }
     return parts.join('');
   }

   // 3. 使用字符串模板（适用于少量拼接）
   function templateConcat(str1, str2, str3) {
     return `${str1}${str2}${str3}`;
   }

   // 4. Array.prototype.reduce
   function reduceConcat(strings) {
     return strings.reduce((acc, val) => acc + val, '');
   }

   // 性能测试
   const smallArr = ['a', 'b', 'c', 'd', 'e'];
   const largeArr = Array(10000).fill('a');

   console.time('join-small');
   efficientConcat1(smallArr);
   console.timeEnd('join-small');

   console.time('join-large');
   efficientConcat1(largeArr);
   console.timeEnd('join-large');

   console.time('reduce-small');
   reduceConcat(smallArr);
   console.timeEnd('reduce-small');

   console.time('reduce-large');
   reduceConcat(largeArr);
   console.timeEnd('reduce-large');
   ```

   对于大量字符串拼接，数组的`join`方法通常是最高效的，因为它减少了临时字符串的创建。在现代浏览器中，模板字符串的性能也很不错。`reduce`方法虽然代码简洁，但对大量字符串的性能不如`join`。

8. 解释一下JavaScript中的稀疏数组。

   **答案**：稀疏数组是指包含"空位"(holes)的数组，其中某些索引位置没有实际的值。

   ```javascript
   // 创建稀疏数组的方法
   const sparse1 = [1, , 3]; // 索引1没有值
   const sparse2 = new Array(5); // 长度为5但没有元素
   const sparse3 = [];
   sparse3[0] = 1;
   sparse3[2] = 3; // 索引1是空位

   console.log(sparse1.length); // 3
   console.log(0 in sparse1); // true - 索引0有值
   console.log(1 in sparse1); // false - 索引1没有值

   // 稀疏数组的遍历行为
   // forEach, map, filter等会跳过空位
   sparse1.forEach(item => console.log(item)); // 只输出1和3

   // for...in会跳过空位
   for (let key in sparse1) {
     console.log(key, sparse1[key]); // 只输出索引0和2的值
   }

   // for循环会遍历空位，值为undefined
   for (let i = 0; i < sparse1.length; i++) {
     console.log(i, sparse1[i]); // 索引1的值是undefined
   }

   // 判断数组是否稀疏
   function isSparse(arr) {
     return arr.length > Object.keys(arr).length;
   }

   console.log(isSparse(sparse1)); // true
   console.log(isSparse([1, 2, 3])); // false
   ```

   在实际开发中，通常应该避免稀疏数组，因为它们：
   - 在不同方法中的行为不一致
   - 可能导致性能问题
   - 增加代码的复杂性和不可预测性

   现代JavaScript项目中，优先使用密集数组，必要时可以用`null`或其他值显式标记空位。

9. 如何实现数组的浅拷贝和深拷贝？

   **答案**：数组的浅拷贝和深拷贝实现方法：

   **浅拷贝**（只复制一层，嵌套对象共享引用）：

   ```javascript
   const original = [1, 2, {a: 3}];

   // 1. 使用展开运算符
   const copy1 = [...original];

   // 2. 使用slice()方法
   const copy2 = original.slice();

   // 3. 使用Array.from()
   const copy3 = Array.from(original);

   // 4. 使用concat()方法
   const copy4 = [].concat(original);

   // 5. 使用Object.assign()
   const copy5 = Object.assign([], original);

   // 演示浅拷贝特性
   copy1[0] = 999; // 不影响原数组
   copy1[2].a = 999; // 影响原数组，因为对象是引用共享的

   console.log(original); // [1, 2, {a: 999}]
   console.log(copy1); // [999, 2, {a: 999}]
   ```

   **深拷贝**（递归复制所有嵌套结构）：

   ```javascript
   const original = [1, 2, {a: 3, b: [4, 5]}];

   // 1. 使用JSON（简单但有限制）
   const deepCopy1 = JSON.parse(JSON.stringify(original));
   // 注意：JSON方法不能处理函数、循环引用、特殊对象(如Date, RegExp)等

   // 2. 手动实现深拷贝
   function deepCopy(obj) {
     if (obj === null || typeof obj !== 'object') {
       return obj;
     }

     if (Array.isArray(obj)) {
       const copyArr = [];
       for (let i = 0; i < obj.length; i++) {
         copyArr[i] = deepCopy(obj[i]);
       }
       return copyArr;
     }

     const copyObj = {};
     for (const key in obj) {
       if (Object.prototype.hasOwnProperty.call(obj, key)) {
         copyObj[key] = deepCopy(obj[key]);
       }
     }
     return copyObj;
   }

   const deepCopy2 = deepCopy(original);

   // 3. 使用结构化克隆算法
   const deepCopy3 = structuredClone(original); // 现代浏览器支持

   // 4. 使用第三方库，如lodash
   // const deepCopy4 = _.cloneDeep(original);

   // 演示深拷贝特性
   deepCopy2[2].b[0] = 999;
   console.log(original[2].b[0]); // 仍然是4，不受影响
   console.log(deepCopy2[2].b[0]); // 999
   ```

   在实际项目中：
   - 简单数据用浅拷贝，足够且性能好
   - 复杂嵌套数据用`structuredClone`或专业库(如lodash的`_.cloneDeep`)
   - 避免使用JSON方法做深拷贝，除非确定数据结构简单且无特殊类型

10. 如何检测字符串中是否包含特定的子字符串？有哪些方法？

    **答案**：检测字符串是否包含特定子字符串的方法：

    ```javascript
    const str = "Hello World, welcome to JavaScript!";
    const searchTerm = "JavaScript";

    // 1. includes() 方法 (ES6+, 推荐使用)
    const hasJS1 = str.includes(searchTerm); // true
    const hasJSAt = str.includes(searchTerm, 10); // 从索引10开始搜索

    // 2. indexOf() 方法
    const hasJS2 = str.indexOf(searchTerm) !== -1; // true

    // 3. search() 方法 (支持正则表达式)
    const hasJS3 = str.search(searchTerm) !== -1; // true
    const hasJS3Regex = str.search(/JavaScript/i) !== -1; // 不区分大小写

    // 4. match() 方法 (支持正则表达式)
    const hasJS4 = str.match(searchTerm) !== null; // true

    // 5. RegExp.test() 方法
    const hasJS5 = /JavaScript/.test(str); // true

    // 6. startsWith() 和 endsWith() (检查开头或结尾)
    const startsWithHello = str.startsWith("Hello"); // true
    const endsWithJS = str.endsWith("JavaScript!"); // true
    ```

    **方法比较**：
    - `includes()`：最直观简洁，ES6+中推荐使用
    - `indexOf()`：适用于所有JavaScript环境，包括旧版本
    - 正则表达式方法(`search()`, `match()`, `test()`)：需要更复杂的模式匹配时使用
    - `startsWith()/endsWith()`：专门用于检查字符串的开头或结尾

    **选择建议**：
    - 简单包含检查：优先使用`includes()`
    - 需要兼容性：使用`indexOf() !== -1`
    - 复杂模式匹配：使用正则表达式方法
    - 性能关键场景：`indexOf()`和`includes()`通常性能较好

    现代前端开发中，除非需要考虑旧浏览器兼容性，否则`includes()`是最清晰直观的选择。

## 学习资源

- [MDN Web Docs - Array](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array) - JavaScript数组详细文档
- [MDN Web Docs - String](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String) - JavaScript字符串详细文档
- [JavaScript数据结构与算法](https://github.com/trekhleb/javascript-algorithms) - GitHub上的JS算法实现
- [LeetCode数组题集](https://leetcode.com/tag/array/) - 数组相关算法练习
- [LeetCode字符串题集](https://leetcode.com/tag/string/) - 字符串相关算法练习
- [前端进阶之道](https://juejin.cn/post/6844903776512393224) - 前端视角的数据结构讲解