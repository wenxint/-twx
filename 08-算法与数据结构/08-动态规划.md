# 动态规划

## 基本概念

动态规划（Dynamic Programming，简称DP）是一种通过将复杂问题分解为更简单的子问题来解决问题的算法思想。它适用于具有**重叠子问题**和**最优子结构**特性的问题。

### 核心特性

1. **最优子结构**：问题的最优解包含其子问题的最优解
2. **重叠子问题**：在求解过程中，同一个子问题会被重复计算多次
3. **状态转移**：通过状态转移方程，将大问题转化为小问题

### 动态规划解题步骤

1. 定义状态（确定dp数组的含义）
2. 找出状态转移方程
3. 确定初始条件和边界情况
4. 确定计算顺序（自底向上或自顶向下）
5. 实现代码并验证

## 常见动态规划问题类型

### 1. 线性DP

#### 斐波那契数列

```javascript
/**
 * @description 计算斐波那契数列的第n个数
 * @param {number} n - 位置索引
 * @return {number} 斐波那契数
 */
function fibonacci(n) {
  if (n <= 1) return n;

  // 创建dp数组
  const dp = new Array(n + 1);

  // 设置初始状态
  dp[0] = 0;
  dp[1] = 1;

  // 状态转移
  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  return dp[n];
}

// 优化空间复杂度的版本
function fibonacciOptimized(n) {
  if (n <= 1) return n;

  let prev = 0;
  let curr = 1;

  for (let i = 2; i <= n; i++) {
    const next = prev + curr;
    prev = curr;
    curr = next;
  }

  return curr;
}
```

#### 最长递增子序列

```javascript
/**
 * @description 计算最长递增子序列的长度
 * @param {number[]} nums - 输入数组
 * @return {number} 最长递增子序列的长度
 */
function lengthOfLIS(nums) {
  if (!nums || nums.length === 0) return 0;

  const n = nums.length;
  // dp[i]表示以nums[i]结尾的最长递增子序列的长度
  const dp = new Array(n).fill(1);

  let maxLength = 1;

  for (let i = 1; i < n; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[i] > nums[j]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
    maxLength = Math.max(maxLength, dp[i]);
  }

  return maxLength;
}
```

### 2. 背包问题

#### 0-1背包问题

```javascript
/**
 * @description 0-1背包问题
 * @param {number[]} weights - 物品重量数组
 * @param {number[]} values - 物品价值数组
 * @param {number} capacity - 背包容量
 * @return {number} 最大价值
 */
function knapsack(weights, values, capacity) {
  const n = weights.length;
  // dp[i][j]表示前i个物品，背包容量为j时的最大价值
  const dp = Array(n + 1).fill().map(() => Array(capacity + 1).fill(0));

  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= capacity; j++) {
      if (weights[i - 1] > j) {
        // 当前物品重量大于背包容量，不能放入
        dp[i][j] = dp[i - 1][j];
      } else {
        // 可以放入，取放入或不放入的最大值
        dp[i][j] = Math.max(
          dp[i - 1][j],  // 不放入
          dp[i - 1][j - weights[i - 1]] + values[i - 1]  // 放入
        );
      }
    }
  }

  return dp[n][capacity];
}
```

#### 完全背包问题

```javascript
/**
 * @description 完全背包问题（每种物品可以选择无限次）
 * @param {number[]} weights - 物品重量数组
 * @param {number[]} values - 物品价值数组
 * @param {number} capacity - 背包容量
 * @return {number} 最大价值
 */
function completePack(weights, values, capacity) {
  const n = weights.length;
  // dp[j]表示背包容量为j时的最大价值
  const dp = Array(capacity + 1).fill(0);

  for (let i = 0; i < n; i++) {
    for (let j = weights[i]; j <= capacity; j++) {
      // 注意：这里内层循环从小到大遍历，而0-1背包需要从大到小遍历
      dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);
    }
  }

  return dp[capacity];
}
```

### 3. 区间DP

#### 最长回文子串

```javascript
/**
 * @description 寻找字符串中的最长回文子串
 * @param {string} s - 输入字符串
 * @return {string} 最长回文子串
 */
function longestPalindrome(s) {
  if (!s || s.length < 2) return s;

  const n = s.length;
  // dp[i][j]表示s[i...j]是否为回文串
  const dp = Array(n).fill().map(() => Array(n).fill(false));

  let start = 0;
  let maxLength = 1;

  // 所有单个字符都是回文
  for (let i = 0; i < n; i++) {
    dp[i][i] = true;
  }

  // 检查长度为2的子串
  for (let i = 0; i < n - 1; i++) {
    if (s[i] === s[i + 1]) {
      dp[i][i + 1] = true;
      start = i;
      maxLength = 2;
    }
  }

  // 检查长度大于2的子串
  for (let len = 3; len <= n; len++) {
    for (let i = 0; i <= n - len; i++) {
      const j = i + len - 1;
      if (s[i] === s[j] && dp[i + 1][j - 1]) {
        dp[i][j] = true;
        start = i;
        maxLength = len;
      }
    }
  }

  return s.substring(start, start + maxLength);
}
```

#### 矩阵链乘法

```javascript
/**
 * @description 矩阵链乘法问题 - 寻找最优的矩阵乘法顺序
 * @param {number[]} dimensions - 矩阵维度数组，dimensions[i-1]×dimensions[i]表示第i个矩阵的维度
 * @return {number} 最少的乘法运算次数
 */
function matrixChainMultiplication(dimensions) {
  const n = dimensions.length - 1; // 矩阵的数量

  // dp[i][j]表示从第i个矩阵到第j个矩阵的最小乘法次数
  const dp = Array(n).fill().map(() => Array(n).fill(0));

  // 计算不同长度的矩阵链
  for (let len = 2; len <= n; len++) {
    for (let i = 0; i <= n - len; i++) {
      const j = i + len - 1;
      dp[i][j] = Infinity;

      // 尝试在不同位置切分矩阵链
      for (let k = i; k < j; k++) {
        const cost = dp[i][k] + dp[k+1][j] + dimensions[i] * dimensions[k+1] * dimensions[j+1];
        dp[i][j] = Math.min(dp[i][j], cost);
      }
    }
  }

  return dp[0][n-1];
}
```

### 4. 状态压缩DP

```javascript
/**
 * @description 旅行商问题的动态规划解法（小规模）
 * @param {number[][]} graph - 城市间距离矩阵
 * @return {number} 最短路径长度
 */
function tsp(graph) {
  const n = graph.length;
  const ALL_VISITED = (1 << n) - 1;

  // dp[i][j]表示从起点0出发，当前在城市j，已经访问过的城市集合为i的最短路径长度
  const dp = Array(1 << n).fill().map(() => Array(n).fill(Infinity));

  // 初始状态：从城市0出发，已访问城市集合仅包含0
  dp[1][0] = 0;

  // 状态转移
  for (let mask = 1; mask < (1 << n); mask++) {
    for (let u = 0; u < n; u++) {
      // 如果城市u不在已访问集合中，跳过
      if (!(mask & (1 << u))) continue;

      // 前一个状态（去掉城市u）
      const prevMask = mask & ~(1 << u);

      // 如果是起点且不是唯一访问的城市，跳过
      if (u === 0 && prevMask !== 0) continue;

      // 遍历所有可能的前一个城市v
      for (let v = 0; v < n; v++) {
        if (mask & (1 << v) && u !== v) {
          dp[mask][u] = Math.min(dp[mask][u], dp[prevMask][v] + graph[v][u]);
        }
      }
    }
  }

  // 所有城市都访问过，最后回到起点0
  return dp[ALL_VISITED][0];
}
```

## 前端应用场景

### 1. 虚拟DOM的Diff算法

虚拟DOM的Diff算法中，寻找两个树的最小编辑距离可以使用动态规划思想。例如，React的协调算法在比较两棵树时，计算如何以最小的操作将一棵树转换为另一棵树。

```javascript
// 简化版DOM节点比较算法
function minEditDistance(oldNodes, newNodes) {
  const m = oldNodes.length;
  const n = newNodes.length;

  // dp[i][j]表示将oldNodes的前i个节点转换为newNodes的前j个节点所需的最小操作次数
  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

  // 初始化：删除所有旧节点或插入所有新节点
  for (let i = 1; i <= m; i++) dp[i][0] = i;
  for (let j = 1; j <= n; j++) dp[0][j] = j;

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (nodesEqual(oldNodes[i-1], newNodes[j-1])) {
        // 节点相同，不需要操作
        dp[i][j] = dp[i-1][j-1];
      } else {
        // 取最小操作：替换、删除、插入
        dp[i][j] = 1 + Math.min(
          dp[i-1][j-1], // 替换
          dp[i-1][j],   // 删除
          dp[i][j-1]    // 插入
        );
      }
    }
  }

  return dp[m][n];
}
```

### 2. 前端路由的最短路径计算

在复杂的前端应用中，计算路由间的最短路径可以使用动态规划，特别是在需要考虑权重和约束条件的情况下。

```javascript
// 前端路由最短路径计算
function shortestRoutePath(routes, start, end, constraints) {
  const n = routes.length;

  // 构建邻接矩阵
  const graph = Array(n).fill().map(() => Array(n).fill(Infinity));
  for (let i = 0; i < n; i++) graph[i][i] = 0;

  // 填充路由连接关系
  for (const [from, to, weight] of constraints) {
    graph[from][to] = weight;
  }

  // Floyd-Warshall算法
  for (let k = 0; k < n; k++) {
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        graph[i][j] = Math.min(graph[i][j], graph[i][k] + graph[k][j]);
      }
    }
  }

  return graph[start][end] === Infinity ? null : graph[start][end];
}
```

### 3. 前端缓存策略

LRU（最近最少使用）缓存是一种常用的缓存淘汰策略，它使用动态规划思想来优化缓存使用。

```javascript
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.map = new Map();
  }

  get(key) {
    if (!this.map.has(key)) return -1;

    const value = this.map.get(key);
    // 更新访问顺序（删除后重新插入到末尾）
    this.map.delete(key);
    this.map.set(key, value);
    return value;
  }

  put(key, value) {
    // 如果已存在，先删除
    if (this.map.has(key)) {
      this.map.delete(key);
    }

    // 如果达到容量上限，删除最久未使用的项（Map的第一个项）
    if (this.map.size >= this.capacity) {
      const firstKey = this.map.keys().next().value;
      this.map.delete(firstKey);
    }

    // 添加新项到末尾
    this.map.set(key, value);
  }
}
```

### 4. 图像处理算法

在前端进行图像处理时，例如图像平滑或边缘检测，可以使用动态规划来优化计算。

```javascript
// 图像平滑算法（3x3均值滤波）
function smoothImage(imageData, width, height) {
  const result = new Uint8ClampedArray(imageData.length);

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let r = 0, g = 0, b = 0, count = 0;

      // 3x3邻域
      for (let ny = Math.max(0, y-1); ny <= Math.min(height-1, y+1); ny++) {
        for (let nx = Math.max(0, x-1); nx <= Math.min(width-1, x+1); nx++) {
          const idx = (ny * width + nx) * 4;
          r += imageData[idx];
          g += imageData[idx + 1];
          b += imageData[idx + 2];
          count++;
        }
      }

      const resultIdx = (y * width + x) * 4;
      result[resultIdx] = r / count;
      result[resultIdx + 1] = g / count;
      result[resultIdx + 2] = b / count;
      result[resultIdx + 3] = imageData[(y * width + x) * 4 + 3]; // 保持原Alpha值
    }
  }

  return result;
}
```

## 时间复杂度分析

动态规划算法的时间复杂度通常取决于状态数量和计算每个状态所需的时间：

- 斐波那契数列：O(n)
- 最长递增子序列：O(n²)，可用二分查找优化到O(n log n)
- 0-1背包问题：O(n × capacity)
- 最长回文子串：O(n²)
- 矩阵链乘法：O(n³)
- 状态压缩DP（如旅行商问题）：O(2^n × n²)

## 面试常见问题

1. **如何判断一个问题是否可以使用动态规划求解？**

   **答案**：判断一个问题是否适合用动态规划求解，需要满足以下条件：

   - **最优子结构**：问题的最优解包含其子问题的最优解。例如，最短路径问题中，如果最短路径经过中间点k，那么从起点到k的路径和从k到终点的路径都必须是最短的。

   - **重叠子问题**：在求解过程中，同一个子问题会被多次计算。动态规划通过存储子问题的解来避免重复计算。例如，在计算斐波那契数列F(n)时，F(2)会在计算F(4)、F(5)等过程中被重复计算。

   - **无后效性**：一旦状态确定，未来的决策只与当前状态有关，而与之前的决策过程无关。

   - **问题可以被分解**：原问题可以被分解为子问题，且子问题的解可以递推出原问题的解。

   实践检验：尝试将问题定义为状态，看是否能写出状态转移方程。如果能够清晰地定义状态和状态转移方程，那么问题很可能适合用动态规划求解。

   示例：在"最长递增子序列"问题中，我们可以定义状态dp[i]为"以第i个元素结尾的最长递增子序列长度"，状态转移方程为dp[i] = max(dp[j] + 1)，其中j < i且nums[j] < nums[i]。这满足上述所有条件，因此适合使用动态规划。

2. **动态规划和分治算法的区别是什么？**

   **答案**：动态规划和分治算法都是将问题分解为子问题，但它们有几个关键区别：

   - **子问题的重叠性**：
     - 分治算法：子问题之间相互独立，不重叠。例如，归并排序将数组分为两半，每半独立排序。
     - 动态规划：子问题之间有重叠。例如，斐波那契数列中，F(n) = F(n-1) + F(n-2)，计算F(n-1)和F(n-2)时会重叠计算更小的值。

   - **解决方法**：
     - 分治算法：通常使用递归自顶向下解决，每次将问题分解为不相交的子问题。
     - 动态规划：可以自底向上迭代求解，使用表格存储中间结果，或者自顶向下递归+记忆化。

   - **效率考虑**：
     - 分治算法：当子问题没有重叠时更高效。
     - 动态规划：当存在大量重叠子问题时能显著提高效率。

   - **适用问题**：
     - 分治算法：适用于排序（归并排序、快速排序）、大数乘法等问题。
     - 动态规划：适用于最优化问题，如最短路径、背包问题、最长公共子序列等。

   示例对比：
   ```javascript
   // 分治算法：归并排序
   function mergeSort(arr) {
     if (arr.length <= 1) return arr;
     const mid = Math.floor(arr.length / 2);
     const left = mergeSort(arr.slice(0, mid));  // 子问题1
     const right = mergeSort(arr.slice(mid));    // 子问题2（与子问题1无重叠）
     return merge(left, right);
   }

   // 动态规划：斐波那契数列
   function fibonacci(n) {
     const dp = new Array(n + 1);
     dp[0] = 0;
     dp[1] = 1;
     for (let i = 2; i <= n; i++) {
       dp[i] = dp[i - 1] + dp[i - 2];  // 子问题重叠
     }
     return dp[n];
   }
   ```

3. **如何优化动态规划的空间复杂度？**

   **答案**：优化动态规划的空间复杂度通常有以下几种方法：

   - **滚动数组**：当当前状态只依赖于前面有限个状态时，可以只保留必要的状态。例如，对于斐波那契数列，只需保存前两个状态：

   ```javascript
   function fibonacci(n) {
     if (n <= 1) return n;
     let prev = 0, curr = 1;
     for (let i = 2; i <= n; i++) {
       const next = prev + curr;
       prev = curr;
       curr = next;
     }
     return curr;
   }
   ```

   - **状态压缩**：将二维dp数组压缩为一维。例如，0-1背包问题可以优化为：

   ```javascript
   function knapsackOptimized(weights, values, capacity) {
     const n = weights.length;
     const dp = Array(capacity + 1).fill(0);

     for (let i = 0; i < n; i++) {
       // 注意：必须从大到小遍历，避免一个物品被重复放入
       for (let j = capacity; j >= weights[i]; j--) {
         dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);
       }
     }

     return dp[capacity];
   }
   ```

   - **原地更新**：有些问题可以直接在原输入数组上进行状态更新，省去额外空间。例如，路径和问题：

   ```javascript
   function minPathSum(grid) {
     const m = grid.length;
     const n = grid[0].length;

     // 原地更新第一行和第一列
     for (let i = 1; i < m; i++) {
       grid[i][0] += grid[i-1][0];
     }
     for (let j = 1; j < n; j++) {
       grid[0][j] += grid[0][j-1];
     }

     // 原地更新其余格子
     for (let i = 1; i < m; i++) {
       for (let j = 1; j < n; j++) {
         grid[i][j] += Math.min(grid[i-1][j], grid[i][j-1]);
       }
     }

     return grid[m-1][n-1];
   }
   ```

   - **记忆化搜索**：对于状态庞大且大部分不需要计算的问题，可以使用自顶向下的递归+记忆化，只计算需要的状态：

   ```javascript
   function coinChangeMemorization(coins, amount) {
     // 记忆化数组
     const memo = Array(amount + 1).fill(-1);
     memo[0] = 0;

     function dp(remaining) {
       if (remaining < 0) return -1;
       if (memo[remaining] !== -1) return memo[remaining];

       let minCoins = Infinity;
       for (const coin of coins) {
         const result = dp(remaining - coin);
         if (result >= 0) {
           minCoins = Math.min(minCoins, result + 1);
         }
       }

       memo[remaining] = minCoins === Infinity ? -1 : minCoins;
       return memo[remaining];
     }

     return dp(amount);
   }
   ```

   空间优化的选择取决于具体问题的结构和依赖关系。分析状态之间的依赖，通常可以将空间复杂度从O(n²)降至O(n)，甚至常数空间O(1)。

4. **能否举例说明前端开发中实际应用动态规划的场景？**

   **答案**：动态规划在前端开发中有多种实际应用场景：

   - **文本相似度比较与自动纠错**：使用Levenshtein距离（编辑距离）算法可以实现拼写纠错、搜索推荐等功能。

   ```javascript
   // 编辑距离计算（可用于拼写检查、自动纠错）
   function levenshteinDistance(str1, str2) {
     const m = str1.length;
     const n = str2.length;
     const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));

     // 初始化
     for (let i = 0; i <= m; i++) dp[i][0] = i;
     for (let j = 0; j <= n; j++) dp[0][j] = j;

     for (let i = 1; i <= m; i++) {
       for (let j = 1; j <= n; j++) {
         if (str1[i-1] === str2[j-1]) {
           dp[i][j] = dp[i-1][j-1];
         } else {
           dp[i][j] = 1 + Math.min(
             dp[i-1][j],   // 删除
             dp[i][j-1],   // 插入
             dp[i-1][j-1]  // 替换
           );
         }
       }
     }

     return dp[m][n];
   }

   // 应用：搜索建议
   function getSuggestions(query, dictionary, maxDistance = 2) {
     return dictionary.filter(word =>
       levenshteinDistance(query, word) <= maxDistance
     ).sort((a, b) =>
       levenshteinDistance(query, a) - levenshteinDistance(query, b)
     );
   }
   ```

   - **虚拟DOM的差异计算**：框架如React、Vue在比较新旧虚拟DOM时使用类似编辑距离的算法。

   ```javascript
   // 简化版React Reconciliation算法
   function diffVirtualDOM(oldNode, newNode) {
     // 如果节点类型变了，直接替换
     if (oldNode.type !== newNode.type) {
       return { type: 'REPLACE', newNode };
     }

     // 如果是文本节点且内容变了
     if (!oldNode.children && !newNode.children && oldNode.text !== newNode.text) {
       return { type: 'TEXT', text: newNode.text };
     }

     // 比较子节点（简化版）
     if (oldNode.children && newNode.children) {
       const patches = [];
       const maxLen = Math.max(oldNode.children.length, newNode.children.length);

       for (let i = 0; i < maxLen; i++) {
         if (i >= oldNode.children.length) {
           patches.push({ type: 'INSERT', index: i, node: newNode.children[i] });
         } else if (i >= newNode.children.length) {
           patches.push({ type: 'REMOVE', index: i });
         } else {
           const childPatch = diffVirtualDOM(oldNode.children[i], newNode.children[i]);
           if (childPatch) {
             patches.push({ type: 'PATCH', index: i, patch: childPatch });
           }
         }
       }

       return patches.length ? { type: 'CHILDREN', patches } : null;
     }

     return null; // 节点未变化
   }
   ```

   - **前端性能优化**：使用LRU（最近最少使用）缓存算法优化数据缓存，减少网络请求：

   ```javascript
   // LRU缓存实现（用于API响应缓存、组件渲染结果缓存等）
   class LRUCache {
     constructor(capacity) {
       this.capacity = capacity;
       this.cache = new Map();
     }

     get(key) {
       if (!this.cache.has(key)) return undefined;

       // 更新使用顺序
       const value = this.cache.get(key);
       this.cache.delete(key);
       this.cache.set(key, value);
       return value;
     }

     put(key, value) {
       if (this.cache.has(key)) {
         this.cache.delete(key);
       } else if (this.cache.size >= this.capacity) {
         // 删除最久未使用的项（Map的第一个条目）
         const oldestKey = this.cache.keys().next().value;
         this.cache.delete(oldestKey);
       }
       this.cache.set(key, value);
     }
   }

   // 使用示例：API响应缓存
   const apiCache = new LRUCache(100);

   async function fetchData(url, params) {
     const cacheKey = `${url}:${JSON.stringify(params)}`;

     // 检查缓存
     const cachedResult = apiCache.get(cacheKey);
     if (cachedResult) return cachedResult;

     // 获取数据
     const response = await fetch(url, { params });
     const data = await response.json();

     // 存入缓存
     apiCache.put(cacheKey, data);
     return data;
   }
   ```

   - **复杂动画效果计算**：例如，计算渐变路径动画的中间状态：

   ```javascript
   // 路径动画中间点计算
   function calculateAnimationPoints(startPoint, endPoint, steps) {
     const points = [];

     // 复杂路径的中间状态计算（使用曲线函数）
     for (let i = 0; i <= steps; i++) {
       const t = i / steps;
       const x = startPoint.x + (endPoint.x - startPoint.x) * easeInOutCubic(t);
       const y = startPoint.y + (endPoint.y - startPoint.y) * easeInOutCubic(t);
       points.push({ x, y });
     }

     return points;
   }

   // 缓动函数
   function easeInOutCubic(t) {
     return t < 0.5
       ? 4 * t * t * t
       : 1 - Math.pow(-2 * t + 2, 3) / 2;
   }
   ```

   这些例子展示了动态规划思想在前端实际场景中的应用，从文本处理、UI渲染到性能优化和动画计算，动态规划都能提供有效的解决方案。

5. **如何将递归解法转换为动态规划解法？**

   **答案**：将递归解法转换为动态规划解法通常有以下步骤：

   1. **识别状态和状态转移方程**：
      - 分析递归函数的参数，确定状态的定义
      - 明确递归的终止条件，对应动态规划的基础情况
      - 提取递归调用中的状态转移逻辑，转化为状态转移方程

   2. **确定计算顺序**：
      - 分析状态间的依赖关系，确定自底向上的计算顺序
      - 通常递归是自顶向下的，而动态规划一般采用自底向上的迭代方式

   3. **使用数组存储中间结果**：
      - 创建dp数组存储每个状态的结果
      - 确定dp数组的维度（通常与递归函数的参数数量相关）

   4. **优化空间复杂度**：
      - 分析状态转移过程中的依赖关系
      - 如果当前状态只依赖于有限的之前状态，可以使用滚动数组或直接降维

   示例：将递归解法的斐波那契数列转换为动态规划解法

   ```javascript
   // 递归解法
   function fibRecursive(n) {
     // 终止条件
     if (n <= 1) return n;
     // 递归调用
     return fibRecursive(n - 1) + fibRecursive(n - 2);
   }

   // 转换步骤1：使用记忆化优化递归（自顶向下的动态规划）
   function fibMemoization(n) {
     const memo = {};

     function fib(n) {
       // 已经计算过
       if (n in memo) return memo[n];
       // 终止条件
       if (n <= 1) return n;
       // 计算并存储结果
       memo[n] = fib(n - 1) + fib(n - 2);
       return memo[n];
     }

     return fib(n);
   }

   // 转换步骤2：完全迭代方式（自底向上的动态规划）
   function fibDP(n) {
     if (n <= 1) return n;

     // 创建dp数组
     const dp = new Array(n + 1);

     // 设置基础情况
     dp[0] = 0;
     dp[1] = 1;

     // 自底向上填充dp数组
     for (let i = 2; i <= n; i++) {
       dp[i] = dp[i - 1] + dp[i - 2];
     }

     return dp[n];
   }

   // 转换步骤3：空间优化
   function fibDPOptimized(n) {
     if (n <= 1) return n;

     let prev = 0, curr = 1;

     // 只保留必要的状态
     for (let i = 2; i <= n; i++) {
       const next = prev + curr;
       prev = curr;
       curr = next;
     }

     return curr;
   }
   ```

   递归到动态规划的转换不仅提高了效率，还消除了递归可能导致的栈溢出问题。这个过程需要深入理解状态的定义和转移关系，是掌握动态规划的关键步骤。

## 高级动态规划技巧

### 1. 状态定义技巧

选择合适的状态定义是解决动态规划问题的关键。状态定义应该满足：
- 能够表示子问题的解
- 能够从更小的子问题推导出来
- 最终能够得到原问题的解

举例：在"打家劫舍"问题中，可以定义：
```javascript
// dp[i] = 从前i个房屋能偷到的最大金额
function rob(nums) {
  if (!nums.length) return 0;

  const dp = new Array(nums.length + 1);
  dp[0] = 0;
  dp[1] = nums[0];

  for (let i = 2; i <= nums.length; i++) {
    dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]);
  }

  return dp[nums.length];
}
```

### 2. 维度转换技巧

有时增加状态维度可以简化问题，虽然看起来增加了复杂度，但实际上可能使问题更容易解决：

```javascript
// 股票买卖问题（最多交易k次）
function maxProfit(k, prices) {
  if (!prices.length) return 0;

  const n = prices.length;

  // 当k大于n/2时，问题退化为不限交易次数
  if (k >= Math.floor(n / 2)) {
    let profit = 0;
    for (let i = 1; i < n; i++) {
      if (prices[i] > prices[i-1]) {
        profit += prices[i] - prices[i-1];
      }
    }
    return profit;
  }

  // dp[i][j][0] = 第i天，最多进行j次交易，不持有股票的最大利润
  // dp[i][j][1] = 第i天，最多进行j次交易，持有股票的最大利润
  const dp = Array(n).fill().map(() =>
    Array(k+1).fill().map(() => Array(2).fill(0))
  );

  // 初始化
  for (let j = 0; j <= k; j++) {
    dp[0][j][0] = 0;
    dp[0][j][1] = -prices[0];
  }

  // 填充dp表格
  for (let i = 1; i < n; i++) {
    for (let j = 1; j <= k; j++) {
      // 不持有股票：前一天不持有或前一天持有今天卖出
      dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i-1][j][1] + prices[i]);
      // 持有股票：前一天持有或前一天不持有今天买入（此时消耗一次交易机会）
      dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i]);
    }
  }

  return dp[n-1][k][0];
}
```

### 3. 前缀和技巧

前缀和是动态规划中常用的优化技巧，可以将某些查询操作的时间复杂度从O(n)降至O(1)：

```javascript
// 区间和查询
function sumRange(nums) {
  const prefixSum = [0];

  // 计算前缀和
  for (let i = 0; i < nums.length; i++) {
    prefixSum[i + 1] = prefixSum[i] + nums[i];
  }

  // 查询函数：O(1)时间复杂度
  return function query(left, right) {
    return prefixSum[right + 1] - prefixSum[left];
  };
}

// 应用：给定一个整数数组和一个整数k，找到该数组中和为k的连续子数组的个数
function subarraySum(nums, k) {
  const prefixSumCount = new Map();
  prefixSumCount.set(0, 1);  // 初始前缀和为0出现1次

  let count = 0;
  let sum = 0;

  for (const num of nums) {
    sum += num;
    // 如果sum-k的前缀和存在，说明存在和为k的子数组
    if (prefixSumCount.has(sum - k)) {
      count += prefixSumCount.get(sum - k);
    }
    // 更新前缀和计数
    prefixSumCount.set(sum, (prefixSumCount.get(sum) || 0) + 1);
  }

  return count;
}
```

## 总结与面试技巧

### 解题模板

在面试中遇到动态规划问题时，可以按照以下步骤思考：

1. **确认是否适合用动态规划**：检查是否具有最优子结构和重叠子问题的特性。

2. **定义状态**：明确dp数组中每个元素的含义，尽量使状态定义简洁明了。

3. **找出状态转移方程**：确定如何从已知状态推导出新状态，这通常是解题的关键。

4. **确定基础情况**：确定初始状态和边界条件。

5. **确定计算顺序**：明确状态依赖关系，确保计算顺序正确。

6. **优化空间复杂度**：如果可能，尝试减少额外空间的使用。

7. **验证解法**：用简单的示例验证算法的正确性。

### 面试回答建议

- **思路清晰**：按照上述步骤逐步讲解思路，展示对问题的分析能力。

- **沟通**：在编写代码前，与面试官沟通状态定义和转移方程，确保方向正确。

- **时空复杂度分析**：主动分析算法的时间和空间复杂度，并思考优化方案。

- **处理边界情况**：注意讨论特殊情况和边界条件的处理方式。

- **代码风格**：编写简洁、易读的代码，适当添加注释说明关键步骤。

动态规划是算法面试中的重要主题，熟练掌握其核心思想和常见应用场景可以在面试中取得优势。通过不断练习各类经典问题，可以建立解决动态规划问题的直觉和模式识别能力。