# 动态规划

## 基本概念

动态规划（Dynamic Programming，简称DP）是一种通过将复杂问题分解为更简单的子问题来解决问题的算法思想。它适用于具有**重叠子问题**和**最优子结构**特性的问题。

### 核心特性

1. **最优子结构**：问题的最优解包含其子问题的最优解
2. **重叠子问题**：在求解过程中，同一个子问题会被重复计算多次
3. **状态转移**：通过状态转移方程，将大问题转化为小问题

### 动态规划解题步骤

1. 定义状态（确定dp数组的含义）
2. 找出状态转移方程
3. 确定初始条件和边界情况
4. 确定计算顺序（自底向上或自顶向下）
5. 实现代码并验证

## 常见动态规划问题类型

### 1. 线性DP

#### 斐波那契数列

```javascript
/**
 * @description 计算斐波那契数列的第n个数
 * @param {number} n - 位置索引
 * @return {number} 斐波那契数
 */
function fibonacci(n) {
  if (n <= 1) return n;

  // 创建dp数组
  const dp = new Array(n + 1);

  // 设置初始状态
  dp[0] = 0;
  dp[1] = 1;

  // 状态转移
  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  return dp[n];
}

// 优化空间复杂度的版本
function fibonacciOptimized(n) {
  if (n <= 1) return n;

  let prev = 0;
  let curr = 1;

  for (let i = 2; i <= n; i++) {
    const next = prev + curr;
    prev = curr;
    curr = next;
  }

  return curr;
}
```

#### 最长递增子序列

```javascript
/**
 * @description 计算最长递增子序列的长度
 * @param {number[]} nums - 输入数组
 * @return {number} 最长递增子序列的长度
 */
function lengthOfLIS(nums) {
  if (!nums || nums.length === 0) return 0;

  const n = nums.length;
  // dp[i]表示以nums[i]结尾的最长递增子序列的长度
  const dp = new Array(n).fill(1);

  let maxLength = 1;

  for (let i = 1; i < n; i++) {
    for (let j = 0; j < i; j++) {
      if (nums[i] > nums[j]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
    maxLength = Math.max(maxLength, dp[i]);
  }

  return maxLength;
}
```

### 2. 背包问题

#### 0-1背包问题

```javascript
/**
 * @description 0-1背包问题
 * @param {number[]} weights - 物品重量数组
 * @param {number[]} values - 物品价值数组
 * @param {number} capacity - 背包容量
 * @return {number} 最大价值
 */
function knapsack(weights, values, capacity) {
  const n = weights.length;
  // dp[i][j]表示前i个物品，背包容量为j时的最大价值
  const dp = Array(n + 1).fill().map(() => Array(capacity + 1).fill(0));

  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= capacity; j++) {
      if (weights[i - 1] > j) {
        // 当前物品重量大于背包容量，不能放入
        dp[i][j] = dp[i - 1][j];
      } else {
        // 可以放入，取放入或不放入的最大值
        dp[i][j] = Math.max(
          dp[i - 1][j],  // 不放入
          dp[i - 1][j - weights[i - 1]] + values[i - 1]  // 放入
        );
      }
    }
  }

  return dp[n][capacity];
}
```

### 3. 区间DP

#### 最长回文子串

```javascript
/**
 * @description 寻找字符串中的最长回文子串
 * @param {string} s - 输入字符串
 * @return {string} 最长回文子串
 */
function longestPalindrome(s) {
  if (!s || s.length < 2) return s;

  const n = s.length;
  // dp[i][j]表示s[i...j]是否为回文串
  const dp = Array(n).fill().map(() => Array(n).fill(false));

  let start = 0;
  let maxLength = 1;

  // 所有单个字符都是回文
  for (let i = 0; i < n; i++) {
    dp[i][i] = true;
  }

  // 检查长度为2的子串
  for (let i = 0; i < n - 1; i++) {
    if (s[i] === s[i + 1]) {
      dp[i][i + 1] = true;
      start = i;
      maxLength = 2;
    }
  }

  // 检查长度大于2的子串
  for (let len = 3; len <= n; len++) {
    for (let i = 0; i <= n - len; i++) {
      const j = i + len - 1;
      if (s[i] === s[j] && dp[i + 1][j - 1]) {
        dp[i][j] = true;
        start = i;
        maxLength = len;
      }
    }
  }

  return s.substring(start, start + maxLength);
}
```

## 前端应用场景

### 1. 虚拟DOM的Diff算法

虚拟DOM的Diff算法中，寻找两个树的最小编辑距离可以使用动态规划思想。

### 2. 前端路由的最短路径计算

在复杂的前端应用中，路由系统可能需要计算最短路径，这可以应用动态规划算法。

### 3. 图像处理和动画效果

某些复杂的图像处理和动画效果计算可以使用动态规划来优化性能。

### 4. 前端缓存策略

设计高效的缓存淘汰策略（如LRU缓存）时可以应用动态规划思想。

## 时间复杂度分析

动态规划算法的时间复杂度通常取决于状态数量和计算每个状态所需的时间：

- 斐波那契数列：O(n)
- 最长递增子序列：O(n²)
- 0-1背包问题：O(n × capacity)
- 最长回文子串：O(n²)

## 面试常见问题

1. **如何判断一个问题是否可以使用动态规划求解？**
   - 问题具有最优子结构
   - 问题存在重叠子问题
   - 问题的解可以通过子问题的解构建出来

2. **动态规划和分治算法的区别是什么？**
   - 分治算法将问题分解为互不相交的子问题，递归解决
   - 动态规划处理的子问题往往是重叠的，通过记忆化或表格法避免重复计算

3. **如何优化动态规划的空间复杂度？**
   - 使用滚动数组
   - 只保留必要的状态
   - 根据依赖关系优化存储结构

4. **能否举例说明前端开发中实际应用动态规划的场景？**
   - 文本相似度比较（如拼写检查）
   - 图像处理算法
   - 复杂动画效果的计算
   - 虚拟DOM的差异计算

5. **如何将递归解法转换为动态规划解法？**
   - 识别状态和状态转移方程
   - 确定计算顺序（自底向上）
   - 使用数组存储中间结果
   - 优化空间复杂度