# 链表

## 基本概念

链表是一种线性数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的引用（指针）。与数组不同，链表中的元素在内存中不是连续存储的。

### 链表的特点

- 动态数据结构，可以根据需要增长或缩小
- 插入和删除操作效率高（不需要移动其他元素）
- 随机访问效率低（需要从头遍历）
- 不需要预先分配内存空间

### 链表的类型

1. **单向链表**：每个节点只有一个指向下一个节点的引用
2. **双向链表**：每个节点有两个引用，分别指向前一个和后一个节点
3. **循环链表**：最后一个节点指向第一个节点，形成一个环
4. **双向循环链表**：结合了双向链表和循环链表的特性

## JavaScript实现

### 单向链表

```javascript
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.size = 0;
  }

  // 在链表末尾添加节点
  append(data) {
    const newNode = new Node(data);

    if (!this.head) {
      this.head = newNode;
    } else {
      let current = this.head;
      while (current.next) {
        current = current.next;
      }
      current.next = newNode;
    }

    this.size++;
  }

  // 在指定位置插入节点
  insert(data, position) {
    if (position < 0 || position > this.size) {
      return false;
    }

    const newNode = new Node(data);

    if (position === 0) {
      newNode.next = this.head;
      this.head = newNode;
    } else {
      let current = this.head;
      let previous = null;
      let index = 0;

      while (index < position) {
        previous = current;
        current = current.next;
        index++;
      }

      newNode.next = current;
      previous.next = newNode;
    }

    this.size++;
    return true;
  }

  // 移除指定位置的节点
  removeAt(position) {
    if (position < 0 || position >= this.size || !this.head) {
      return null;
    }

    let current = this.head;

    if (position === 0) {
      this.head = current.next;
    } else {
      let previous = null;
      let index = 0;

      while (index < position) {
        previous = current;
        current = current.next;
        index++;
      }

      previous.next = current.next;
    }

    this.size--;
    return current.data;
  }

  // 查找元素的索引
  indexOf(data) {
    let current = this.head;
    let index = 0;

    while (current) {
      if (current.data === data) {
        return index;
      }
      current = current.next;
      index++;
    }

    return -1;
  }

  // 移除指定元素
  remove(data) {
    const index = this.indexOf(data);
    return this.removeAt(index);
  }

  // 判断链表是否为空
  isEmpty() {
    return this.size === 0;
  }

  // 获取链表大小
  getSize() {
    return this.size;
  }

  // 获取链表的字符串表示
  toString() {
    if (!this.head) {
      return '';
    }

    let string = `${this.head.data}`;
    let current = this.head.next;

    while (current) {
      string = `${string},${current.data}`;
      current = current.next;
    }

    return string;
  }
}
```

### 双向链表

```javascript
class DoublyNode {
  constructor(data) {
    this.data = data;
    this.prev = null;
    this.next = null;
  }
}

class DoublyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.size = 0;
  }

  // 在链表末尾添加节点
  append(data) {
    const newNode = new DoublyNode(data);

    if (!this.head) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      newNode.prev = this.tail;
      this.tail.next = newNode;
      this.tail = newNode;
    }

    this.size++;
  }

  // 在链表开头添加节点
  prepend(data) {
    const newNode = new DoublyNode(data);

    if (!this.head) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      newNode.next = this.head;
      this.head.prev = newNode;
      this.head = newNode;
    }

    this.size++;
  }

  // 其他方法类似单向链表，但需要维护prev引用
  // ...
}
```

## 常见链表操作

### 1. 反转链表

```javascript
function reverseLinkedList(head) {
  let prev = null;
  let current = head;

  while (current) {
    const next = current.next;
    current.next = prev;
    prev = current;
    current = next;
  }

  return prev; // 新的头节点
}
```

### 2. 检测环形链表

```javascript
function hasCycle(head) {
  if (!head || !head.next) {
    return false;
  }

  let slow = head;
  let fast = head;

  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;

    if (slow === fast) {
      return true;
    }
  }

  return false;
}
```

### 3. 查找链表中间节点

```javascript
function findMiddleNode(head) {
  if (!head) {
    return null;
  }

  let slow = head;
  let fast = head;

  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
  }

  return slow;
}
```

### 4. 合并两个有序链表

```javascript
function mergeTwoSortedLists(l1, l2) {
  const dummy = new Node(0);
  let current = dummy;

  while (l1 && l2) {
    if (l1.data < l2.data) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }
    current = current.next;
  }

  current.next = l1 || l2;

  return dummy.next;
}
```

### 5. 删除链表倒数第N个节点

```javascript
function removeNthFromEnd(head, n) {
  const dummy = new Node(0);
  dummy.next = head;

  let first = dummy;
  let second = dummy;

  // 先让first前进n+1步
  for (let i = 0; i <= n; i++) {
    first = first.next;
  }

  // 同时移动first和second，直到first到达末尾
  while (first) {
    first = first.next;
    second = second.next;
  }

  // 删除节点
  second.next = second.next.next;

  return dummy.next;
}
```

## 复杂度分析

### 链表操作的时间复杂度

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| 访问元素 | O(n) | 需要从头遍历 |
| 插入元素（头部） | O(1) | 直接修改引用 |
| 插入元素（中间） | O(n) | 需要先找到位置 |
| 插入元素（尾部） | O(n)/O(1) | 单链表O(n)，带尾指针O(1) |
| 删除元素（头部） | O(1) | 直接修改引用 |
| 删除元素（中间） | O(n) | 需要先找到位置 |
| 删除元素（尾部） | O(n) | 需要找到倒数第二个节点 |
| 查找元素 | O(n) | 需要遍历链表 |

### 空间复杂度

链表的空间复杂度为O(n)，其中n是链表的长度。每个节点需要额外的空间来存储指向下一个节点的引用。

## 前端应用场景

1. **撤销/重做功能**：使用双向链表实现操作历史
2. **LRU缓存**：最近最少使用缓存的实现
3. **前端路由**：浏览历史的管理
4. **大文件分片上传**：管理文件分片的顺序和状态
5. **虚拟DOM的Diff算法**：某些实现中使用链表结构
6. **无限滚动列表**：管理动态加载的数据

## 经典算法题

### 1. 判断回文链表

回文链表是指从前向后遍历和从后向前遍历得到的结果是一样的链表。与回文字符串类似，链表的回文判断需要比较首尾对应位置的元素是否相等。

**回文链表示例**：
- `1->2->2->1`：正向读是"1,2,2,1"，反向读也是"1,2,2,1"，所以是回文链表
- `1->2->3->2->1`：正向读是"1,2,3,2,1"，反向读也是"1,2,3,2,1"，所以是回文链表
- `1`：单个节点也视为回文链表
- `1->1`：两个相同值的节点构成回文链表

**非回文链表示例**：
- `1->2`：正向读是"1,2"，反向读是"2,1"，不一致，不是回文链表
- `1->2->3->4->5`：正向读是"1,2,3,4,5"，反向读是"5,4,3,2,1"，不一致，不是回文链表
- `1->2->1->2`：正向读是"1,2,1,2"，反向读是"2,1,2,1"，不一致，不是回文链表

```javascript
/**
 * @description 判断链表是否为回文链表
 * @param {ListNode} head - 链表头节点
 * @return {boolean} 是否为回文链表
 */
function isPalindromeLinkedList(head) {
  if (!head || !head.next) {
    return true;  // 空链表或只有一个节点的链表都视为回文
  }

  // 1. 找到中间节点
  let slow = head;
  let fast = head;

  while (fast.next && fast.next.next) {
    slow = slow.next;     // 慢指针每次移动一步
    fast = fast.next.next;  // 快指针每次移动两步
  }

  // 2. 反转后半部分链表
  let secondHalf = reverseLinkedList(slow.next);
  let firstHalfPointer = head;
  let secondHalfPointer = secondHalf;

  let result = true;

  // 3. 比较前半部分和反转后的后半部分
  while (result && secondHalfPointer) {
    if (firstHalfPointer.data !== secondHalfPointer.data) {
      result = false;  // 对应位置的值不同，不是回文
    }
    firstHalfPointer = firstHalfPointer.next;
    secondHalfPointer = secondHalfPointer.next;
  }

  // 4. 恢复链表原始结构（可选）
  slow.next = reverseLinkedList(secondHalf);

  return result;
}

/**
 * 辅助函数：反转链表
 */
function reverseLinkedList(head) {
  let prev = null;
  let current = head;

  while (current) {
    const next = current.next;
    current.next = prev;
    prev = current;
    current = next;
  }

  return prev; // 新的头节点
}
```

**算法解释**：
1. 首先使用快慢指针找到链表的中点
2. 将链表的后半部分反转
3. 比较前半部分和反转后的后半部分是否相同
4. 最后将链表恢复原状（可选步骤）

**时间复杂度**：O(n)，其中n是链表的长度
**空间复杂度**：O(1)，只使用了常数额外空间

### 2. 链表排序

```javascript
function sortLinkedList(head) {
  if (!head || !head.next) {
    return head;
  }

  // 找到中间节点
  const middle = findMiddleNode(head);
  const nextOfMiddle = middle.next;
  middle.next = null;

  // 递归排序两半
  const left = sortLinkedList(head);
  const right = sortLinkedList(nextOfMiddle);

  // 合并两个有序链表
  return mergeTwoSortedLists(left, right);
}
```

### 3. 两个链表的第一个公共节点

```javascript
function getIntersectionNode(headA, headB) {
  if (!headA || !headB) {
    return null;
  }

  let pointerA = headA;
  let pointerB = headB;

  while (pointerA !== pointerB) {
    pointerA = pointerA ? pointerA.next : headB;
    pointerB = pointerB ? pointerB.next : headA;
  }

  return pointerA;
}
```

## 面试常见问题

1. **链表和数组的区别是什么？各自的优缺点是什么？**

   **答案**：

   链表和数组是两种基本的线性数据结构，它们的主要区别在于内存分配和元素访问方式：

   **链表特点**：
   - **内存分配**：动态分配内存，节点在内存中不连续
   - **元素访问**：无法直接随机访问，必须从头开始遍历
   - **插入/删除**：O(1)时间复杂度（如果已知位置）
   - **内存利用**：除了存储数据外，还需额外空间存储指针

   **数组特点**：
   - **内存分配**：静态分配连续内存块（JavaScript中是动态的）
   - **元素访问**：可以通过索引直接访问，O(1)时间复杂度
   - **插入/删除**：O(n)时间复杂度（需要移动元素）
   - **内存利用**：只需要存储数据本身

   **适用场景对比**：
   - 链表适合频繁插入/删除操作，不固定大小的场景
   - 数组适合频繁随机访问，知道元素总数的场景

   **在前端中的应用**：
   - 链表：实现LRU缓存、撤销/重做功能、文件分片上传等
   - 数组：几乎所有需要有序数据的场景，如列表渲染、数据表格等

2. **如何判断一个链表中是否有环？如何找到环的入口点？**

   **答案**：

   **检测是否有环**（快慢指针法）：

   ```javascript
   /**
    * 判断链表是否有环
    * @param {ListNode} head 链表头节点
    * @return {boolean} 是否有环
    */
   function hasCycle(head) {
     if (!head || !head.next) return false;

     let slow = head;
     let fast = head;

     while (fast && fast.next) {
       slow = slow.next;       // 慢指针每次走1步
       fast = fast.next.next;  // 快指针每次走2步

       if (slow === fast) {
         return true;  // 两指针相遇，说明有环
       }
     }

     return false;  // 快指针到达终点，说明无环
   }
   ```

   **查找环的入口点**（Floyd's Tortoise and Hare）：

   ```javascript
   /**
    * 查找链表中环的入口点
    * @param {ListNode} head 链表头节点
    * @return {ListNode|null} 环的入口节点或null
    */
   function detectCycle(head) {
     if (!head || !head.next) return null;

     // 第一阶段：检测是否有环
     let slow = head;
     let fast = head;
     let hasCycle = false;

     while (fast && fast.next) {
       slow = slow.next;
       fast = fast.next.next;

       if (slow === fast) {
         hasCycle = true;
         break;
       }
     }

     if (!hasCycle) return null;

     // 第二阶段：查找环的入口
     slow = head;
     while (slow !== fast) {
       slow = slow.next;
       fast = fast.next;
     }

     return slow;  // 此时slow/fast指向环的入口
   }
   ```

   **原理解释**：
   - 第一阶段使用快慢指针检测环，如果有环，它们一定会在环内相遇
   - 设链表头到环入口的距离为a，环入口到相遇点的距离为b，相遇点到环入口的距离为c
   - 当slow和fast相遇时，slow走了a+b，fast走了a+b+n(b+c)，其中n是fast在环内多走的圈数
   - 因为fast速度是slow的两倍，所以a+b+n(b+c) = 2(a+b)
   - 化简得到：a = c+(n-1)(b+c)
   - 这表明从链表头走a步和从相遇点走c+(n-1)(b+c)步都能到达环入口
   - 实际应用中，我们让一个指针从头出发，另一个从相遇点出发，每次都走1步，它们会在环入口相遇

3. **如何在O(1)时间内删除链表中的一个节点（给定节点的引用，不是位置）？**

   **答案**：

   要在O(1)时间内删除链表节点，我们可以通过复制下一个节点的值到当前节点，然后删除下一个节点来实现：

   ```javascript
   /**
    * 在O(1)时间内删除链表节点
    * @param {ListNode} node 要删除的节点引用(非尾节点)
    * @return {void}
    */
   function deleteNode(node) {
     // 注意：这种方法只适用于非尾节点
     if (!node || !node.next) return;

     // 复制下一个节点的值到当前节点
     node.data = node.next.data;

     // 删除下一个节点
     node.next = node.next.next;
   }
   ```

   **限制条件**：
   - 此方法仅适用于非尾节点，因为尾节点没有下一个节点可复制
   - 无法访问头节点的情况下，不能删除头节点

   **处理尾节点的情况**：
   - 如果可能是尾节点，则需要从头遍历链表，这样时间复杂度就变成了O(n)

   **为什么这样有效**：
   - 实际上我们没有真正删除目标节点，而是：
     1. 把下一个节点的值复制到目标节点
     2. 删除下一个节点
   - 从外部看来，效果等同于删除了目标节点

4. **如何找到两个链表的交点？**

   **答案**：

   两个链表的交点是指两个链表合并的第一个共同节点。注意交点的判断是基于节点引用相同，而不是节点值相同。

   ```javascript
   /**
    * 查找两个链表的交点
    * @param {ListNode} headA 第一个链表头节点
    * @param {ListNode} headB 第二个链表头节点
    * @return {ListNode|null} 交点或null
    */
   function getIntersectionNode(headA, headB) {
     if (!headA || !headB) return null;

     // 使用两个指针
     let pointerA = headA;
     let pointerB = headB;

     // 当两个指针不相等时继续遍历
     while (pointerA !== pointerB) {
       // 如果到达链表末尾，则转到另一个链表开头
       // 如果没有交点，最终两个指针都会变成null
       pointerA = pointerA ? pointerA.next : headB;
       pointerB = pointerB ? pointerB.next : headA;
     }

     // 返回交点（如果没有交点，将返回null）
     return pointerA;
   }
   ```

   **原理解释**：
   - 假设链表A长度为a+c，链表B长度为b+c，其中c是公共部分长度
   - 指针A走完链表A后，开始走链表B；指针B走完链表B后，开始走链表A
   - 当两个指针都走了a+b+c步后，它们会在交点相遇
   - 如果没有交点(c=0)，两个指针会同时变成null，循环结束

   **时间复杂度**：O(a+b)，其中a和b是两个链表的长度
   **空间复杂度**：O(1)

5. **如何判断一个链表是否为回文链表？**

   **答案**：

   前面已经详细讲解了回文链表的判断方法，这里简单回顾核心步骤：

   1. 使用快慢指针找到链表中点
   2. 反转后半部分链表
   3. 比较前半部分和反转后的后半部分
   4. 恢复链表原始结构（可选）

   ```javascript
   // 判断回文链表的函数已在前文详细给出，这里不再重复
   ```

   **进阶解法**：如果要求O(n)时间复杂度和O(1)空间复杂度，上面的解法已经满足。

   **更直观但空间复杂度较高的方法**：

   ```javascript
   /**
    * 使用数组辅助判断回文链表
    * @param {ListNode} head 链表头节点
    * @return {boolean} 是否为回文链表
    */
   function isPalindromeWithArray(head) {
     const values = [];

     // 遍历链表，将所有值存入数组
     let current = head;
     while (current) {
       values.push(current.data);
       current = current.next;
     }

     // 检查数组是否为回文
     let left = 0;
     let right = values.length - 1;

     while (left < right) {
       if (values[left] !== values[right]) {
         return false;
       }
       left++;
       right--;
     }

     return true;
   }
   ```

   **时间复杂度**：O(n)
   **空间复杂度**：O(n) - 需要额外的数组存储所有节点值

6. **如何反转链表的一部分（给定起始和结束位置）？**

   **答案**：

   要反转链表的一部分，我们需要找到要反转部分的前一个节点和要反转的部分，然后进行反转操作。

   ```javascript
   /**
    * 反转链表的一部分，从位置m到n
    * @param {ListNode} head 链表头节点
    * @param {number} m 起始位置（从1开始）
    * @param {number} n 结束位置
    * @return {ListNode} 反转后的链表头节点
    */
   function reverseBetween(head, m, n) {
     if (!head || m === n) return head;

     // 创建哑节点(dummy node)，处理头节点可能被反转的情况
     const dummy = new Node(0);
     dummy.next = head;

     // 找到反转部分的前一个节点
     let prev = dummy;
     for (let i = 1; i < m; i++) {
       prev = prev.next;
     }

     // 反转部分的开始节点
     let start = prev.next;
     let then = start.next;

     // 反转从位置m到n的部分
     for (let i = 0; i < n - m; i++) {
       start.next = then.next;
       then.next = prev.next;
       prev.next = then;
       then = start.next;
     }

     return dummy.next;
   }
   ```

   **算法步骤**：
   1. 创建dummy节点指向head，简化边界情况处理
   2. 找到反转部分的前一个节点`prev`
   3. 开始执行反转：
      - `start`指向反转部分的第一个节点
      - `then`指向当前要处理的节点
      - 每次迭代将`then`节点移到已反转部分的开头
   4. 返回新的头节点

   **示例**：
   - 输入：`1->2->3->4->5`, m=2, n=4
   - 过程：
     - 初始：`dummy->1->2->3->4->5`
     - prev=1, start=2, then=3
     - 第一轮：`dummy->1->3->2->4->5`
     - 第二轮：`dummy->1->4->3->2->5`
   - 输出：`1->4->3->2->5`

   **时间复杂度**：O(n)
   **空间复杂度**：O(1)

7. **如何在不使用额外空间的情况下，判断链表是否有环？**

   **答案**：

   这个问题实际上已经在问题2中解答过了。使用快慢指针（Floyd's乌龟和兔子算法）可以在O(1)空间复杂度下检测链表中的环。

   ```javascript
   /**
    * 在O(1)空间复杂度下检测链表是否有环
    * @param {ListNode} head 链表头节点
    * @return {boolean} 是否有环
    */
   function hasCycle(head) {
     if (!head || !head.next) return false;

     let slow = head;
     let fast = head;

     while (fast && fast.next) {
       slow = slow.next;       // 慢指针每次走1步
       fast = fast.next.next;  // 快指针每次走2步

       if (slow === fast) {
         return true;  // 相遇说明有环
       }
     }

     return false;
   }
   ```

   **算法原理**：
   - 如果链表中有环，快慢指针最终会在环内相遇
   - 如果没有环，快指针会先到达链表末尾

   **时间复杂度分析**：
   - 无环情况：O(n)，n为链表长度
   - 有环情况：O(n)，需要考虑环的长度和环前部分的长度

   **为什么快慢指针一定会相遇**？
   - 假设慢指针进入环时，快指针已在环内某处
   - 相对而言，快指针每轮比慢指针多走1步
   - 可以把这看作是快指针在追赶慢指针
   - 由于环的有限长度，快指针一定会在某个时刻追上慢指针

8. **如何实现链表的深拷贝？**

   **答案**：

   链表的深拷贝是指创建一个全新的链表，其节点结构和值与原链表相同，但是内存空间完全独立。

   **基本链表深拷贝**：

   ```javascript
   /**
    * 普通链表的深拷贝
    * @param {ListNode} head 链表头节点
    * @return {ListNode} 深拷贝后的链表头节点
    */
   function deepCopy(head) {
     if (!head) return null;

     // 创建新的头节点
     const newHead = new Node(head.data);
     let current = newHead;
     let oldCurrent = head.next;

     // 逐个创建并连接新节点
     while (oldCurrent) {
       current.next = new Node(oldCurrent.data);
       current = current.next;
       oldCurrent = oldCurrent.next;
     }

     return newHead;
   }
   ```

   **带随机指针的链表深拷贝**：

   ```javascript
   /**
    * 带随机指针的链表节点
    */
   class RandomNode {
     constructor(data) {
       this.data = data;
       this.next = null;
       this.random = null; // 指向链表中任意节点或null
     }
   }

   /**
    * 带随机指针的链表深拷贝
    * @param {RandomNode} head 链表头节点
    * @return {RandomNode} 深拷贝后的链表头节点
    */
   function copyRandomList(head) {
     if (!head) return null;

     const map = new Map();

     // 第一次遍历：创建所有新节点
     let current = head;
     while (current) {
       map.set(current, new RandomNode(current.data));
       current = current.next;
     }

     // 第二次遍历：连接新节点的next和random指针
     current = head;
     while (current) {
       const newNode = map.get(current);
       newNode.next = current.next ? map.get(current.next) : null;
       newNode.random = current.random ? map.get(current.random) : null;
       current = current.next;
     }

     return map.get(head);
   }
   ```

   **不使用额外空间的解法（O(1)空间复杂度）**：

   ```javascript
   /**
    * 不使用额外空间的带随机指针的链表深拷贝
    * @param {RandomNode} head 链表头节点
    * @return {RandomNode} 深拷贝后的链表头节点
    */
   function copyRandomListO1(head) {
     if (!head) return null;

     // 步骤1：在每个原节点后创建一个新节点
     let current = head;
     while (current) {
       const newNode = new RandomNode(current.data);
       newNode.next = current.next;
       current.next = newNode;
       current = newNode.next;
     }

     // 步骤2：设置新节点的random指针
     current = head;
     while (current) {
       if (current.random) {
         current.next.random = current.random.next;
       }
       current = current.next.next;
     }

     // 步骤3：分离两个链表
     const newHead = head.next;
     current = head;

     while (current) {
       const newNode = current.next;
       current.next = newNode.next;
       newNode.next = newNode.next ? newNode.next.next : null;
       current = current.next;
     }

     return newHead;
   }
   ```

   **时间复杂度**：O(n)
   **空间复杂度**：
   - 第一种方法：O(n)，使用了哈希表
   - 第二种方法：O(1)，通过巧妙的链表操作避免使用额外空间

9. **如何在前端实现LRU缓存？**

   **答案**：

   LRU(Least Recently Used)缓存是一种常用的缓存策略，它在达到容量限制时，会优先删除最长时间未使用的项。结合哈希表和双向链表可以实现O(1)时间复杂度的操作。

   ```javascript
   /**
    * LRU缓存实现
    */
   class LRUCache {
     constructor(capacity) {
       this.capacity = capacity;
       this.cache = new Map();  // 提供O(1)的查找性能

       // 使用双向链表维护访问顺序
       this.head = { key: 0, value: 0 };  // 哑头节点
       this.tail = { key: 0, value: 0 };  // 哑尾节点
       this.head.next = this.tail;
       this.tail.prev = this.head;
     }

     /**
      * 获取缓存中的值
      * @param {any} key 键
      * @return {any} 值，不存在返回-1
      */
     get(key) {
       if (!this.cache.has(key)) return -1;

       // 获取节点
       const node = this.cache.get(key);

       // 将节点移到最前(表示最近使用)
       this.moveToHead(node);

       return node.value;
     }

     /**
      * 设置缓存
      * @param {any} key 键
      * @param {any} value 值
      */
     put(key, value) {
       // 如果已存在，更新值，并移到最前
       if (this.cache.has(key)) {
         const node = this.cache.get(key);
         node.value = value;
         this.moveToHead(node);
         return;
       }

       // 如果不存在，创建新节点
       const newNode = { key, value, prev: null, next: null };
       this.cache.set(key, newNode);
       this.addToHead(newNode);

       // 如果超出容量，删除最久未使用的节点(链表尾部)
       if (this.cache.size > this.capacity) {
         const tailNode = this.removeTail();
         this.cache.delete(tailNode.key);
       }
     }

     /**
      * 添加节点到链表头部
      * @param {Object} node 节点
      */
     addToHead(node) {
       node.prev = this.head;
       node.next = this.head.next;
       this.head.next.prev = node;
       this.head.next = node;
     }

     /**
      * 从链表中移除节点
      * @param {Object} node 节点
      */
     removeNode(node) {
       node.prev.next = node.next;
       node.next.prev = node.prev;
     }

     /**
      * 将节点移到链表头部
      * @param {Object} node 节点
      */
     moveToHead(node) {
       this.removeNode(node);
       this.addToHead(node);
     }

     /**
      * 移除链表尾部节点
      * @return {Object} 尾部节点
      */
     removeTail() {
       const tailNode = this.tail.prev;
       this.removeNode(tailNode);
       return tailNode;
     }
   }
   ```

   **前端实际应用示例**：

   ```javascript
   /**
    * 前端API请求缓存实现
    */
   class APICache {
     constructor(capacity = 100) {
       this.cache = new LRUCache(capacity);
     }

     /**
      * 获取API数据，优先从缓存获取
      * @param {string} url API地址
      * @param {Object} options 请求选项
      * @return {Promise} 请求结果
      */
     async fetchData(url, options = {}) {
       const cacheKey = this.getCacheKey(url, options);

       // 尝试从缓存获取
       const cachedData = this.cache.get(cacheKey);
       if (cachedData !== -1 && !this.isExpired(cachedData)) {
         return cachedData.data;
       }

       // 发起网络请求
       try {
         const response = await fetch(url, options);
         const data = await response.json();

         // 存入缓存
         this.cache.put(cacheKey, {
           data,
           timestamp: Date.now(),
           expiration: options.expiration || 60000 // 默认1分钟
         });

         return data;
       } catch (error) {
         console.error('API请求失败:', error);
         throw error;
       }
     }

     /**
      * 生成缓存键
      * @param {string} url API地址
      * @param {Object} options 请求选项
      * @return {string} 缓存键
      */
     getCacheKey(url, options) {
       return `${url}|${JSON.stringify(options)}`;
     }

     /**
      * 检查缓存是否过期
      * @param {Object} cachedData 缓存数据
      * @return {boolean} 是否过期
      */
     isExpired(cachedData) {
       return Date.now() - cachedData.timestamp > cachedData.expiration;
     }

     /**
      * 清除缓存
      * @param {string} url 可选，特定URL的缓存
      */
     clearCache(url) {
       if (url) {
         // 更复杂的实现需要遍历和匹配
       } else {
         this.cache = new LRUCache(this.cache.capacity);
       }
     }
   }
   ```

   **实现要点**：
   - 使用HashMap(Map)实现O(1)时间的查找
   - 使用双向链表维护访问顺序
   - 每次访问后，将节点移到链表头部
   - 缓存满时，删除链表尾部节点（最久未使用）

   **应用场景**：
   - API响应缓存
   - 组件渲染结果缓存
   - 路由导航状态缓存
   - 图片资源预加载缓存

10. **如何优化链表的查找操作？**

    **答案**：

    链表的查找操作通常需要O(n)时间复杂度，我们可以通过以下几种技术优化：

    **1. 使用跳跃表(Skip List)**：

    ```javascript
    /**
     * 跳跃表节点
     */
    class SkipNode {
      constructor(value, level) {
        this.value = value;
        this.forward = new Array(level + 1).fill(null);
      }
    }

    /**
     * 跳跃表实现 - 带有概率层级的链表结构
     */
    class SkipList {
      constructor() {
        this.MAXLEVEL = 16;       // 最大层数
        this.P = 0.5;             // 层级概率
        this.level = 0;           // 当前层数
        this.header = new SkipNode(-1, this.MAXLEVEL);
      }

      /**
       * 获取随机层级
       * @return {number} 随机层级
       */
      randomLevel() {
        let level = 0;
        while (Math.random() < this.P && level < this.MAXLEVEL) {
          level++;
        }
        return level;
      }

      /**
       * 插入元素
       * @param {number} value 值
       */
      insert(value) {
        const update = new Array(this.MAXLEVEL + 1).fill(null);
        let current = this.header;

        // 从当前最高层开始查找
        for (let i = this.level; i >= 0; i--) {
          while (current.forward[i] && current.forward[i].value < value) {
            current = current.forward[i];
          }
          update[i] = current;
        }

        // 获取新节点的随机层级
        const newLevel = this.randomLevel();

        // 更新当前最大层级
        if (newLevel > this.level) {
          for (let i = this.level + 1; i <= newLevel; i++) {
            update[i] = this.header;
          }
          this.level = newLevel;
        }

        // 创建新节点
        const newNode = new SkipNode(value, newLevel);

        // 插入节点到所有层级
        for (let i = 0; i <= newLevel; i++) {
          newNode.forward[i] = update[i].forward[i];
          update[i].forward[i] = newNode;
        }
      }

      /**
       * 查找元素
       * @param {number} value 值
       * @return {boolean} 是否存在
       */
      search(value) {
        let current = this.header;

        // 从当前最高层开始查找
        for (let i = this.level; i >= 0; i--) {
          while (current.forward[i] && current.forward[i].value < value) {
            current = current.forward[i];
          }
        }

        current = current.forward[0];

        return current && current.value === value;
      }
    }
    ```

    **2. 哈希链表**：

    ```javascript
    /**
     * 哈希链表 - 结合哈希表和链表
     */
    class HashLinkedList {
      constructor() {
        this.hashMap = new Map();  // 哈希表存储节点引用
        this.head = null;          // 链表头
        this.tail = null;          // 链表尾
        this.count = 0;            // 节点计数
      }

      /**
       * 添加节点
       * @param {string} key 键
       * @param {any} value 值
       */
      add(key, value) {
        // 如果已存在，更新值
        if (this.hashMap.has(key)) {
          const node = this.hashMap.get(key);
          node.value = value;
          return;
        }

        // 创建新节点
        const newNode = {
          key,
          value,
          next: null,
          prev: this.tail
        };

        // 更新链表
        if (!this.head) {
          this.head = newNode;
        } else {
          this.tail.next = newNode;
        }

        this.tail = newNode;
        this.hashMap.set(key, newNode);
        this.count++;
      }

      /**
       * 根据键查找节点
       * @param {string} key 键
       * @return {any} 值或undefined
       */
      get(key) {
        const node = this.hashMap.get(key);
        return node ? node.value : undefined;
      }

      /**
       * 根据键删除节点
       * @param {string} key 键
       * @return {boolean} 是否成功删除
       */
      remove(key) {
        const node = this.hashMap.get(key);
        if (!node) return false;

        // 更新相邻节点的指针
        if (node.prev) {
          node.prev.next = node.next;
        } else {
          this.head = node.next;
        }

        if (node.next) {
          node.next.prev = node.prev;
        } else {
          this.tail = node.prev;
        }

        this.hashMap.delete(key);
        this.count--;
        return true;
      }
    }
    ```

    **3. 索引链表**：

    ```javascript
    /**
     * 带索引的链表
     */
    class IndexedLinkedList {
      constructor() {
        this.head = null;
        this.size = 0;
        this.indexMap = new Map(); // 存储位置索引
      }

      /**
       * 添加节点
       * @param {any} data 节点数据
       */
      append(data) {
        const newNode = { data, next: null };

        if (!this.head) {
          this.head = newNode;
        } else {
          let current = this.head;
          while (current.next) {
            current = current.next;
          }
          current.next = newNode;
        }

        // 更新索引
        this.indexMap.set(data, this.size);
        this.size++;
      }

      /**
       * 根据数据查找节点
       * @param {any} data 节点数据
       * @return {Object|null} 节点或null
       */
      find(data) {
        if (this.indexMap.has(data)) {
          const index = this.indexMap.get(data);
          let current = this.head;

          // 直接跳到索引位置
          for (let i = 0; i < index; i++) {
            current = current.next;
          }

          return current;
        }

        return null;
      }
    }
    ```

    **优化方法比较**：

    | 方法 | 查找时间复杂度 | 空间开销 | 适用场景 |
    |------|---------------|---------|---------|
    | 跳跃表 | 平均O(log n) | O(n) | 需要有序集合的场景，Redis中有使用 |
    | 哈希链表 | 平均O(1) | O(n) | 需要快速查找且保持插入顺序的场景，如LRU缓存 |
    | 索引链表 | 平均O(1) | O(n) | 需要通过值快速查找节点位置的场景 |

    **实际应用技巧**：

    1. **缓存热点数据**：将经常访问的节点缓存或移到链表前部
    2. **按频率组织**：将高频访问节点集中放置
    3. **批量操作**：尽可能一次遍历完成多个操作
    4. **延迟加载**：对于大型链表，考虑分段加载
    5. **定期重组**：根据访问模式重新组织链表结构

## 学习资源

- [JavaScript数据结构 - 链表](https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/linked-list) - GitHub上的JS实现
- [LeetCode链表题集](https://leetcode.com/tag/linked-list/) - 相关算法练习
- [前端进阶之道 - 链表](https://juejin.cn/post/6844903498362912775) - 前端视角的链表讲解
- [JavaScript链表实现详解](https://www.freecodecamp.org/news/implementing-a-linked-list-in-javascript/) - FreeCodeCamp上的教程