# 链表

## 基本概念

链表是一种线性数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的引用（指针）。与数组不同，链表中的元素在内存中不是连续存储的。

### 链表的特点

- 动态数据结构，可以根据需要增长或缩小
- 插入和删除操作效率高（不需要移动其他元素）
- 随机访问效率低（需要从头遍历）
- 不需要预先分配内存空间

### 链表的类型

1. **单向链表**：每个节点只有一个指向下一个节点的引用
2. **双向链表**：每个节点有两个引用，分别指向前一个和后一个节点
3. **循环链表**：最后一个节点指向第一个节点，形成一个环
4. **双向循环链表**：结合了双向链表和循环链表的特性

## JavaScript实现

### 单向链表

```javascript
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.size = 0;
  }

  // 在链表末尾添加节点
  append(data) {
    const newNode = new Node(data);

    if (!this.head) {
      this.head = newNode;
    } else {
      let current = this.head;
      while (current.next) {
        current = current.next;
      }
      current.next = newNode;
    }

    this.size++;
  }

  // 在指定位置插入节点
  insert(data, position) {
    if (position < 0 || position > this.size) {
      return false;
    }

    const newNode = new Node(data);

    if (position === 0) {
      newNode.next = this.head;
      this.head = newNode;
    } else {
      let current = this.head;
      let previous = null;
      let index = 0;

      while (index < position) {
        previous = current;
        current = current.next;
        index++;
      }

      newNode.next = current;
      previous.next = newNode;
    }

    this.size++;
    return true;
  }

  // 移除指定位置的节点
  removeAt(position) {
    if (position < 0 || position >= this.size || !this.head) {
      return null;
    }

    let current = this.head;

    if (position === 0) {
      this.head = current.next;
    } else {
      let previous = null;
      let index = 0;

      while (index < position) {
        previous = current;
        current = current.next;
        index++;
      }

      previous.next = current.next;
    }

    this.size--;
    return current.data;
  }

  // 查找元素的索引
  indexOf(data) {
    let current = this.head;
    let index = 0;

    while (current) {
      if (current.data === data) {
        return index;
      }
      current = current.next;
      index++;
    }

    return -1;
  }

  // 移除指定元素
  remove(data) {
    const index = this.indexOf(data);
    return this.removeAt(index);
  }

  // 判断链表是否为空
  isEmpty() {
    return this.size === 0;
  }

  // 获取链表大小
  getSize() {
    return this.size;
  }

  // 获取链表的字符串表示
  toString() {
    if (!this.head) {
      return '';
    }

    let string = `${this.head.data}`;
    let current = this.head.next;

    while (current) {
      string = `${string},${current.data}`;
      current = current.next;
    }

    return string;
  }
}
```

### 双向链表

```javascript
class DoublyNode {
  constructor(data) {
    this.data = data;
    this.prev = null;
    this.next = null;
  }
}

class DoublyLinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.size = 0;
  }

  // 在链表末尾添加节点
  append(data) {
    const newNode = new DoublyNode(data);

    if (!this.head) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      newNode.prev = this.tail;
      this.tail.next = newNode;
      this.tail = newNode;
    }

    this.size++;
  }

  // 在链表开头添加节点
  prepend(data) {
    const newNode = new DoublyNode(data);

    if (!this.head) {
      this.head = newNode;
      this.tail = newNode;
    } else {
      newNode.next = this.head;
      this.head.prev = newNode;
      this.head = newNode;
    }

    this.size++;
  }

  // 其他方法类似单向链表，但需要维护prev引用
  // ...
}
```

## 常见链表操作

### 1. 反转链表

```javascript
function reverseLinkedList(head) {
  let prev = null;
  let current = head;

  while (current) {
    const next = current.next;
    current.next = prev;
    prev = current;
    current = next;
  }

  return prev; // 新的头节点
}
```

### 2. 检测环形链表

```javascript
function hasCycle(head) {
  if (!head || !head.next) {
    return false;
  }

  let slow = head;
  let fast = head;

  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;

    if (slow === fast) {
      return true;
    }
  }

  return false;
}
```

### 3. 查找链表中间节点

```javascript
function findMiddleNode(head) {
  if (!head) {
    return null;
  }

  let slow = head;
  let fast = head;

  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
  }

  return slow;
}
```

### 4. 合并两个有序链表

```javascript
function mergeTwoSortedLists(l1, l2) {
  const dummy = new Node(0);
  let current = dummy;

  while (l1 && l2) {
    if (l1.data < l2.data) {
      current.next = l1;
      l1 = l1.next;
    } else {
      current.next = l2;
      l2 = l2.next;
    }
    current = current.next;
  }

  current.next = l1 || l2;

  return dummy.next;
}
```

### 5. 删除链表倒数第N个节点

```javascript
function removeNthFromEnd(head, n) {
  const dummy = new Node(0);
  dummy.next = head;

  let first = dummy;
  let second = dummy;

  // 先让first前进n+1步
  for (let i = 0; i <= n; i++) {
    first = first.next;
  }

  // 同时移动first和second，直到first到达末尾
  while (first) {
    first = first.next;
    second = second.next;
  }

  // 删除节点
  second.next = second.next.next;

  return dummy.next;
}
```

## 复杂度分析

### 链表操作的时间复杂度

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| 访问元素 | O(n) | 需要从头遍历 |
| 插入元素（头部） | O(1) | 直接修改引用 |
| 插入元素（中间） | O(n) | 需要先找到位置 |
| 插入元素（尾部） | O(n)/O(1) | 单链表O(n)，带尾指针O(1) |
| 删除元素（头部） | O(1) | 直接修改引用 |
| 删除元素（中间） | O(n) | 需要先找到位置 |
| 删除元素（尾部） | O(n) | 需要找到倒数第二个节点 |
| 查找元素 | O(n) | 需要遍历链表 |

### 空间复杂度

链表的空间复杂度为O(n)，其中n是链表的长度。每个节点需要额外的空间来存储指向下一个节点的引用。

## 前端应用场景

1. **撤销/重做功能**：使用双向链表实现操作历史
2. **LRU缓存**：最近最少使用缓存的实现
3. **前端路由**：浏览历史的管理
4. **大文件分片上传**：管理文件分片的顺序和状态
5. **虚拟DOM的Diff算法**：某些实现中使用链表结构
6. **无限滚动列表**：管理动态加载的数据

## 经典算法题

### 1. 判断回文链表

```javascript
function isPalindromeLinkedList(head) {
  if (!head || !head.next) {
    return true;
  }

  // 找到中间节点
  let slow = head;
  let fast = head;

  while (fast.next && fast.next.next) {
    slow = slow.next;
    fast = fast.next.next;
  }

  // 反转后半部分
  let secondHalf = reverseLinkedList(slow.next);
  let firstHalfPointer = head;
  let secondHalfPointer = secondHalf;

  let result = true;

  // 比较前半部分和反转后的后半部分
  while (result && secondHalfPointer) {
    if (firstHalfPointer.data !== secondHalfPointer.data) {
      result = false;
    }
    firstHalfPointer = firstHalfPointer.next;
    secondHalfPointer = secondHalfPointer.next;
  }

  // 恢复链表（可选）
  slow.next = reverseLinkedList(secondHalf);

  return result;
}
```

### 2. 链表排序

```javascript
function sortLinkedList(head) {
  if (!head || !head.next) {
    return head;
  }

  // 找到中间节点
  const middle = findMiddleNode(head);
  const nextOfMiddle = middle.next;
  middle.next = null;

  // 递归排序两半
  const left = sortLinkedList(head);
  const right = sortLinkedList(nextOfMiddle);

  // 合并两个有序链表
  return mergeTwoSortedLists(left, right);
}
```

### 3. 两个链表的第一个公共节点

```javascript
function getIntersectionNode(headA, headB) {
  if (!headA || !headB) {
    return null;
  }

  let pointerA = headA;
  let pointerB = headB;

  while (pointerA !== pointerB) {
    pointerA = pointerA ? pointerA.next : headB;
    pointerB = pointerB ? pointerB.next : headA;
  }

  return pointerA;
}
```

## 面试常见问题

1. 链表和数组的区别是什么？各自的优缺点是什么？
2. 如何判断一个链表中是否有环？如何找到环的入口点？
3. 如何在O(1)时间内删除链表中的一个节点（给定节点的引用，不是位置）？
4. 如何找到两个链表的交点？
5. 如何判断一个链表是否为回文链表？
6. 如何反转链表的一部分（给定起始和结束位置）？
7. 如何在不使用额外空间的情况下，判断链表是否有环？
8. 如何实现链表的深拷贝？
9. 如何在前端实现LRU缓存？
10. 如何优化链表的查找操作？

## 学习资源

- [JavaScript数据结构 - 链表](https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/linked-list) - GitHub上的JS实现
- [LeetCode链表题集](https://leetcode.com/tag/linked-list/) - 相关算法练习
- [前端进阶之道 - 链表](https://juejin.cn/post/6844903498362912775) - 前端视角的链表讲解
- [JavaScript链表实现详解](https://www.freecodecamp.org/news/implementing-a-linked-list-in-javascript/) - FreeCodeCamp上的教程