# 排序算法

## 基本概念

排序算法是将一组特定的数据按照某种顺序进行排列的算法。排序算法在计算机科学中非常重要，是许多其他算法的基础。

### 排序算法的分类

1. **比较类排序**：通过比较来决定元素间的相对次序，时间复杂度不能突破O(nlogn)
   - 交换排序（冒泡排序、快速排序）
   - 插入排序（简单插入排序、希尔排序）
   - 选择排序（简单选择排序、堆排序）
   - 归并排序

2. **非比较类排序**：不通过比较来决定元素间的相对次序，可以突破O(nlogn)的限制
   - 计数排序
   - 桶排序
   - 基数排序

### 排序算法的评价指标

- **时间复杂度**：算法执行所需的时间
- **空间复杂度**：算法执行所需的额外空间
- **稳定性**：相等的元素在排序后是否保持原有的相对位置

## 常见排序算法

### 1. 冒泡排序

冒泡排序是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就交换它们，直到没有再需要交换的元素为止。

```javascript
/**
 * @description 冒泡排序实现
 * @param {number[]} arr - 待排序的数组
 * @returns {number[]} - 排序后的数组
 * @example
 * const arr = [5, 3, 8, 4, 2];
 * console.log(bubbleSort(arr)); // [2, 3, 4, 5, 8]
 */
function bubbleSort(arr) {
  const len = arr.length;

  for (let i = 0; i < len; i++) {
    // 标记当前轮次是否发生交换
    let swapped = false;

    // 每一轮比较相邻元素，大的元素向后移动
    for (let j = 0; j < len - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        // 交换元素
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        swapped = true;
      }
    }

    // 如果没有发生交换，说明数组已经有序，提前退出
    if (!swapped) break;
  }

  return arr;
}

// 调用示例
const bubbleExample = [5, 3, 8, 4, 2];
console.log("原始数组:", bubbleExample);
console.log("冒泡排序后:", bubbleSort([...bubbleExample]));
// 原始数组: [5, 3, 8, 4, 2]
// 冒泡排序后: [2, 3, 4, 5, 8]

// 执行过程分析
// 第1轮：[5, 3, 8, 4, 2] → [3, 5, 4, 2, 8]（8浮到最后）
// 第2轮：[3, 5, 4, 2, 8] → [3, 4, 2, 5, 8]（5浮到倒数第二位）
// 第3轮：[3, 4, 2, 5, 8] → [3, 2, 4, 5, 8]（4浮到倒数第三位）
// 第4轮：[3, 2, 4, 5, 8] → [2, 3, 4, 5, 8]（3浮到倒数第四位）
// 完成排序
```

**时间复杂度**：
- 最好情况：O(n)，当数组已经有序时
- 最坏情况：O(n²)，当数组逆序时
- 平均情况：O(n²)

**空间复杂度**：O(1)

**稳定性**：稳定

### 2. 选择排序

选择排序是一种简单直观的排序算法，它的工作原理是每次从待排序的数据中选出最小（或最大）的元素，放在已排序序列的末尾。

```javascript
/**
 * @description 选择排序实现
 * @param {number[]} arr - 待排序的数组
 * @returns {number[]} - 排序后的数组
 * @example
 * const arr = [5, 3, 8, 4, 2];
 * console.log(selectionSort(arr)); // [2, 3, 4, 5, 8]
 */
function selectionSort(arr) {
  const len = arr.length;

  for (let i = 0; i < len - 1; i++) {
    // 假设当前位置的元素是最小的
    let minIndex = i;

    // 在未排序的部分中寻找最小元素
    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }

    // 如果找到了更小的元素，交换位置
    if (minIndex !== i) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
    }
  }

  return arr;
}

// 调用示例
const selectionExample = [5, 3, 8, 4, 2];
console.log("原始数组:", selectionExample);
console.log("选择排序后:", selectionSort([...selectionExample]));
// 原始数组: [5, 3, 8, 4, 2]
// 选择排序后: [2, 3, 4, 5, 8]

// 执行过程分析
// 第1轮：找到最小元素2，与位置0的5交换 → [2, 3, 8, 4, 5]
// 第2轮：找到未排序部分最小元素3，已在正确位置，不交换 → [2, 3, 8, 4, 5]
// 第3轮：找到未排序部分最小元素4，与位置2的8交换 → [2, 3, 4, 8, 5]
// 第4轮：找到未排序部分最小元素5，与位置3的8交换 → [2, 3, 4, 5, 8]
// 完成排序
```

**时间复杂度**：
- 最好情况：O(n²)
- 最坏情况：O(n²)
- 平均情况：O(n²)

**空间复杂度**：O(1)

**稳定性**：不稳定（相同元素的相对位置可能改变）

### 3. 插入排序

插入排序是一种简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

```javascript
/**
 * @description 插入排序实现
 * @param {number[]} arr - 待排序的数组
 * @returns {number[]} - 排序后的数组
 * @example
 * const arr = [5, 3, 8, 4, 2];
 * console.log(insertionSort(arr)); // [2, 3, 4, 5, 8]
 */
function insertionSort(arr) {
  const len = arr.length;

  for (let i = 1; i < len; i++) {
    // 当前要插入的元素
    const current = arr[i];
    let j = i - 1;

    // 寻找插入位置，将大于current的元素向后移动
    while (j >= 0 && arr[j] > current) {
      arr[j + 1] = arr[j];
      j--;
    }

    // 插入元素到正确位置
    arr[j + 1] = current;
  }

  return arr;
}

// 调用示例
const insertionExample = [5, 3, 8, 4, 2];
console.log("原始数组:", insertionExample);
console.log("插入排序后:", insertionSort([...insertionExample]));
// 原始数组: [5, 3, 8, 4, 2]
// 插入排序后: [2, 3, 4, 5, 8]

// 执行过程分析
// 初始状态：[5] | [3, 8, 4, 2] (已排序部分 | 未排序部分)
// 处理3：将3插入到5前面 → [3, 5] | [8, 4, 2]
// 处理8：将8插入到5后面 → [3, 5, 8] | [4, 2]
// 处理4：将4插入到5前面 → [3, 4, 5, 8] | [2]
// 处理2：将2插入到3前面 → [2, 3, 4, 5, 8] | []
// 完成排序
```

**时间复杂度**：
- 最好情况：O(n)，当数组已经有序时
- 最坏情况：O(n²)，当数组逆序时
- 平均情况：O(n²)

**空间复杂度**：O(1)

**稳定性**：稳定

### 4. 希尔排序

希尔排序是插入排序的一种改进版本，它通过将整个数组分为多个子数组分别进行插入排序，逐步缩小增量，最终完成整个数组的排序。

```javascript
/**
 * @description 希尔排序实现
 * @param {number[]} arr - 待排序的数组
 * @returns {number[]} - 排序后的数组
 * @example
 * const arr = [5, 3, 8, 4, 2];
 * console.log(shellSort(arr)); // [2, 3, 4, 5, 8]
 */
function shellSort(arr) {
  const len = arr.length;
  // 初始间隔设为数组长度的一半
  let gap = Math.floor(len / 2);

  // 不断缩小间隔直到为1
  while (gap > 0) {
    // 对每一个子序列进行插入排序
    for (let i = gap; i < len; i++) {
      const temp = arr[i];
      let j = i;

      // 对间隔为gap的元素进行比较和移动
      while (j >= gap && arr[j - gap] > temp) {
        arr[j] = arr[j - gap];
        j -= gap;
      }

      // 放入正确位置
      arr[j] = temp;
    }

    // 缩小间隔
    gap = Math.floor(gap / 2);
  }

  return arr;
}

// 调用示例
const shellExample = [5, 3, 8, 4, 2, 9, 1, 7, 6];
console.log("原始数组:", shellExample);
console.log("希尔排序后:", shellSort([...shellExample]));
// 原始数组: [5, 3, 8, 4, 2, 9, 1, 7, 6]
// 希尔排序后: [1, 2, 3, 4, 5, 6, 7, 8, 9]

// 执行过程分析（以长度为9的数组为例）
// 初始状态：[5, 3, 8, 4, 2, 9, 1, 7, 6]
// gap = 4：
//   比较并排序[5, 2]、[3, 9]、[8, 1]、[4, 7]、[4, 6]
//   结果：[2, 3, 1, 4, 5, 9, 8, 7, 6]
// gap = 2：
//   比较并排序[2, 1, 5, 8, 6]和[3, 4, 9, 7]
//   结果：[1, 2, 3, 4, 5, 6, 7, 8, 9]
// gap = 1：
//   进行最后一次普通插入排序
//   结果：[1, 2, 3, 4, 5, 6, 7, 8, 9]
// 完成排序
```

**时间复杂度**：
- 最好情况：O(n log² n)
- 最坏情况：O(n²)，取决于间隔序列
- 平均情况：O(n log² n)

**空间复杂度**：O(1)

**稳定性**：不稳定

### 5. 归并排序

归并排序是一种分治算法，它将数组分成两半，递归地排序两半，然后将结果合并起来。

```javascript
/**
 * @description 归并排序实现
 * @param {number[]} arr - 待排序的数组
 * @returns {number[]} - 排序后的数组
 * @example
 * const arr = [5, 3, 8, 4, 2];
 * console.log(mergeSort(arr)); // [2, 3, 4, 5, 8]
 */
function mergeSort(arr) {
  // 基本情况：数组长度为0或1时已经排序好
  if (arr.length <= 1) return arr;

  // 分割数组
  const mid = Math.floor(arr.length / 2);
  const left = arr.slice(0, mid);
  const right = arr.slice(mid);

  // 递归排序两半
  return merge(mergeSort(left), mergeSort(right));
}

/**
 * @description 合并两个已排序的数组
 * @param {number[]} left - 左侧已排序数组
 * @param {number[]} right - 右侧已排序数组
 * @returns {number[]} - 合并后的已排序数组
 */
function merge(left, right) {
  const result = [];
  let leftIndex = 0;
  let rightIndex = 0;

  // 比较两个数组的元素，将较小的元素加入结果数组
  while (leftIndex < left.length && rightIndex < right.length) {
    if (left[leftIndex] < right[rightIndex]) {
      result.push(left[leftIndex]);
      leftIndex++;
    } else {
      result.push(right[rightIndex]);
      rightIndex++;
    }
  }

  // 将剩余元素加入结果数组
  return result
    .concat(left.slice(leftIndex))
    .concat(right.slice(rightIndex));
}

// 调用示例
const mergeExample = [5, 3, 8, 4, 2];
console.log("原始数组:", mergeExample);
console.log("归并排序后:", mergeSort([...mergeExample]));
// 原始数组: [5, 3, 8, 4, 2]
// 归并排序后: [2, 3, 4, 5, 8]

// 执行过程分析
// 分割：[5, 3, 8, 4, 2] → [5, 3] 和 [8, 4, 2]
// 继续分割：[5, 3] → [5] 和 [3]、[8, 4, 2] → [8] 和 [4, 2]
// 继续分割：[4, 2] → [4] 和 [2]
// 合并：[3, 5]、[2, 4, 8]
// 最终合并：[2, 3, 4, 5, 8]
```

**时间复杂度**：
- 最好情况：O(n log n)
- 最坏情况：O(n log n)
- 平均情况：O(n log n)

**空间复杂度**：O(n)

**稳定性**：稳定

### 6. 快速排序

快速排序是一种分治算法，它选择一个元素作为基准，将数组分为两个子数组，小于基准的元素和大于基准的元素，然后递归地排序两个子数组。

```javascript
/**
 * @description 快速排序实现
 * @param {number[]} arr - 待排序的数组
 * @param {number} [left=0] - 排序的起始索引
 * @param {number} [right=arr.length-1] - 排序的结束索引
 * @returns {number[]} - 排序后的数组
 * @example
 * const arr = [5, 3, 8, 4, 2];
 * console.log(quickSort(arr)); // [2, 3, 4, 5, 8]
 */
function quickSort(arr, left = 0, right = arr.length - 1) {
  // 基本情况：如果子数组长度为1或0，则已经排序好
  if (left < right) {
    // 获取分区点
    const pivotIndex = partition(arr, left, right);

    // 递归地排序两个子数组
    quickSort(arr, left, pivotIndex - 1);
    quickSort(arr, pivotIndex + 1, right);
  }

  return arr;
}

/**
 * @description 分区函数，用于确定基准元素的最终位置
 * @param {number[]} arr - 待排序的数组
 * @param {number} left - 分区的起始索引
 * @param {number} right - 分区的结束索引
 * @returns {number} - 基准元素的最终索引
 */
function partition(arr, left, right) {
  // 选择最右边的元素作为基准
  const pivot = arr[right];
  // i指向小于基准元素区域的末尾
  let i = left - 1;

  // 遍历区间内的元素
  for (let j = left; j < right; j++) {
    // 如果当前元素小于等于基准元素
    if (arr[j] <= pivot) {
      // 将其放到小元素区域的末尾
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // 将基准元素放到正确的位置
  [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
  return i + 1;
}

// 调用示例
const quickExample = [5, 3, 8, 4, 2, 7, 1, 6];
console.log("原始数组:", quickExample);
console.log("快速排序后:", quickSort([...quickExample]));
// 原始数组: [5, 3, 8, 4, 2, 7, 1, 6]
// 快速排序后: [1, 2, 3, 4, 5, 6, 7, 8]

// 执行过程分析（以[5, 3, 8, 4, 2]为例）
// 1. 选择基准pivot=2（最右元素）
// 2. 第一次分区：
//    - 初始状态：[5, 3, 8, 4, 2]，pivot=2
//    - 遍历过程：
//      j=0: 5>2，不交换，i=-1
//      j=1: 3>2，不交换，i=-1
//      j=2: 8>2，不交换，i=-1
//      j=3: 4>2，不交换，i=-1
//    - 最后将pivot放到正确位置：[2, 3, 8, 4, 5]，pivotIndex=0
// 3. 递归左侧子数组（空）
// 4. 递归右侧子数组[3, 8, 4, 5]
//    - 选择基准pivot=5
//    - 分区结果：[3, 4, 5, 8]，pivotIndex=2
// 5. 递归处理[3, 4]和[8]
//    - 处理[3, 4]，基准pivot=4
//    - 分区结果：[3, 4]，pivotIndex=1
// 6. 继续递归直到所有子数组都处理完
// 7. 最终结果：[2, 3, 4, 5, 8]

/**
 * @description 优化版快速排序（使用随机基准点）
 * @param {number[]} arr - 待排序的数组
 * @param {number} [left=0] - 排序的起始索引
 * @param {number} [right=arr.length-1] - 排序的结束索引
 * @returns {number[]} - 排序后的数组
 */
function optimizedQuickSort(arr, left = 0, right = arr.length - 1) {
  if (left < right) {
    // 获取随机基准点
    const pivotIndex = randomizedPartition(arr, left, right);

    optimizedQuickSort(arr, left, pivotIndex - 1);
    optimizedQuickSort(arr, pivotIndex + 1, right);
  }

  return arr;
}

/**
 * @description 使用随机选择基准元素的分区函数
 * @param {number[]} arr - 待排序的数组
 * @param {number} left - 分区的起始索引
 * @param {number} right - 分区的结束索引
 * @returns {number} - 基准元素的最终索引
 */
function randomizedPartition(arr, left, right) {
  // 随机选择一个基准点
  const randomIndex = left + Math.floor(Math.random() * (right - left + 1));
  // 将随机选择的元素与最右元素交换
  [arr[randomIndex], arr[right]] = [arr[right], arr[randomIndex]];

  // 调用标准分区过程
  return partition(arr, left, right);
}

// 比较两种快速排序算法
const arrToSort = Array.from({length: 1000}, () => Math.floor(Math.random() * 1000));
const arrToSort2 = [...arrToSort];

console.time('标准快速排序');
quickSort([...arrToSort]);
console.timeEnd('标准快速排序');

console.time('优化快速排序');
optimizedQuickSort([...arrToSort2]);
console.timeEnd('优化快速排序');

// 示例输出:
// 标准快速排序: 0.721ms
// 优化快速排序: 0.683ms
```

**时间复杂度**：
- 最好情况：O(n log n)，每次都能均匀分割
- 最坏情况：O(n²)，当数组已经有序或逆序时（可通过随机选择基准点优化）
- 平均情况：O(n log n)

**空间复杂度**：O(log n)，递归调用栈的深度

**稳定性**：不稳定

**优化方法**：
1. 随机选择基准点（如上示例）
2. 三数取中法（取左中右三个元素的中间值作为基准）
3. 双基准快速排序
4. 对小规模子数组使用插入排序
5. 尾递归优化

### 7. 堆排序

堆排序是一种基于二叉堆的排序算法，它首先构建一个最大堆（或最小堆），然后将堆顶元素与末尾元素交换，调整堆结构，重复此过程。

```javascript
/**
 * @description 堆排序实现
 * @param {number[]} arr - 待排序的数组
 * @returns {number[]} - 排序后的数组
 * @example
 * const arr = [5, 3, 8, 4, 2];
 * console.log(heapSort(arr)); // [2, 3, 4, 5, 8]
 */
function heapSort(arr) {
  const len = arr.length;

  // 第一步：构建最大堆
  // 从最后一个非叶子节点开始，自底向上构建最大堆
  for (let i = Math.floor(len / 2) - 1; i >= 0; i--) {
    heapify(arr, len, i);
  }

  // 第二步：堆排序
  // 依次将堆顶元素（最大值）与末尾元素交换，并重新调整堆结构
  for (let i = len - 1; i > 0; i--) {
    // 将堆顶元素（当前最大值）与末尾元素交换
    [arr[0], arr[i]] = [arr[i], arr[0]];

    // 重新调整剩余元素的堆结构，使其满足最大堆特性
    heapify(arr, i, 0);
  }

  return arr;
}

/**
 * @description 调整堆结构的核心函数
 * @param {number[]} arr - 待调整的数组
 * @param {number} n - 堆的大小
 * @param {number} i - 当前需要调整的节点索引
 */
function heapify(arr, n, i) {
  // 初始化最大值为当前节点
  let largest = i;
  // 计算左子节点的索引
  const left = 2 * i + 1;
  // 计算右子节点的索引
  const right = 2 * i + 2;

  // 如果左子节点存在且大于当前最大值，更新最大值索引
  if (left < n && arr[left] > arr[largest]) {
    largest = left;
  }

  // 如果右子节点存在且大于当前最大值，更新最大值索引
  if (right < n && arr[right] > arr[largest]) {
    largest = right;
  }

  // 如果最大值不是当前节点，交换节点并继续调整堆
  if (largest !== i) {
    // 交换节点
    [arr[i], arr[largest]] = [arr[largest], arr[i]];

    // 递归调整受影响的子树
    heapify(arr, n, largest);
  }
}

// 调用示例
const heapExample = [5, 3, 8, 4, 2, 9, 1];
console.log("原始数组:", heapExample);
console.log("堆排序后:", heapSort([...heapExample]));
// 原始数组: [5, 3, 8, 4, 2, 9, 1]
// 堆排序后: [1, 2, 3, 4, 5, 8, 9]

// 执行过程分析（以[5, 3, 8, 4, 2]为例）
// 1. 构建最大堆:
//    初始数组: [5, 3, 8, 4, 2]
//    最后一个非叶子节点索引: Math.floor(5/2)-1 = 1
//
//    - 对节点1(值为3)进行heapify:
//      比较3与其子节点4的值，4 > 3，交换
//      结果: [5, 4, 8, 3, 2]
//
//    - 对节点0(值为5)进行heapify:
//      比较5与其子节点8和4的值，8 > 5，交换5与8
//      结果: [8, 4, 5, 3, 2]
//      继续调整子树，无需更多交换
//
// 2. 堆排序过程:
//    - 第1次：交换堆顶8与末尾元素2
//      结果: [2, 4, 5, 3, 8]
//      对节点0(值为2)进行heapify，重建堆
//      结果: [5, 4, 2, 3, 8]
//
//    - 第2次：交换堆顶5与末尾元素3
//      结果: [3, 4, 2, 5, 8]
//      对节点0(值为3)进行heapify，重建堆
//      结果: [4, 3, 2, 5, 8]
//
//    - 第3次：交换堆顶4与末尾元素2
//      结果: [2, 3, 4, 5, 8]
//      对节点0(值为2)进行heapify，重建堆
//      结果: [3, 2, 4, 5, 8]
//
//    - 第4次：交换堆顶3与末尾元素2
//      最终结果: [2, 3, 4, 5, 8]

// 性能测试
function testHeapSort() {
  // 生成不同大小的随机数组
  const sizes = [1000, 10000, 100000];

  for (const size of sizes) {
    const randomArray = Array.from({ length: size }, () =>
      Math.floor(Math.random() * size * 10)
    );

    const sortedArray = [...randomArray].sort((a, b) => a - b);
    const reversedArray = [...sortedArray].reverse();

    console.log(`\n测试大小为 ${size} 的数组：`);

    // 随机数组
    console.time(`随机数组 (${size} 个元素)`);
    heapSort([...randomArray]);
    console.timeEnd(`随机数组 (${size} 个元素)`);

    // 已排序数组
    console.time(`已排序数组 (${size} 个元素)`);
    heapSort([...sortedArray]);
    console.timeEnd(`已排序数组 (${size} 个元素)`);

    // 逆序数组
    console.time(`逆序数组 (${size} 个元素)`);
    heapSort([...reversedArray]);
    console.timeEnd(`逆序数组 (${size} 个元素)`);
  }
}

// 取消注释下行运行性能测试
// testHeapSort();

// 示例输出:
// 测试大小为 1000 的数组：
// 随机数组 (1000 个元素): 1.231ms
// 已排序数组 (1000 个元素): 1.124ms
// 逆序数组 (1000 个元素): 1.198ms
//
// 测试大小为 10000 的数组：
// 随机数组 (10000 个元素): 13.657ms
// 已排序数组 (10000 个元素): 13.245ms
// 逆序数组 (10000 个元素): 13.421ms
```

**时间复杂度**：
- 最好情况：O(n log n)
- 最坏情况：O(n log n)
- 平均情况：O(n log n)

**空间复杂度**：O(1)，原地排序算法

**稳定性**：不稳定

**堆排序的特点**：
1. 不受输入数据的影响，最好、最坏、平均时间复杂度都是O(n log n)
2. 空间复杂度低，是一种原地排序算法
3. 适合处理大数据量的排序
4. 对于部分排序的数据没有优化，性能不如快速排序
5. 实现复杂度高于简单排序算法（如冒泡、插入）

### 8. 计数排序

计数排序是一种非比较排序算法，它使用一个额外的数组来存储元素的出现次数，然后根据这个计数数组重建排序后的数组。

```javascript
/**
 * @description 计数排序实现
 * @param {number[]} arr - 待排序的数组（假设元素都是非负整数）
 * @returns {number[]} - 排序后的数组
 * @example
 * const arr = [5, 3, 8, 4, 2, 5, 3, 1];
 * console.log(countingSort(arr)); // [1, 2, 3, 3, 4, 5, 5, 8]
 */
function countingSort(arr) {
  if (arr.length <= 1) return arr;

  // 找出数组中的最大值
  const max = Math.max(...arr);

  // 创建计数数组，长度为max+1（包含0到max）
  const counts = new Array(max + 1).fill(0);

  // 统计每个元素出现的次数
  for (let i = 0; i < arr.length; i++) {
    counts[arr[i]]++;
  }

  // 根据计数数组重建排序后的数组
  const result = [];
  for (let i = 0; i <= max; i++) {
    // 将该元素加入结果数组counts[i]次
    while (counts[i] > 0) {
      result.push(i);
      counts[i]--;
    }
  }

  return result;
}

/**
 * @description 优化版计数排序实现（使用前缀和，保持稳定性）
 * @param {number[]} arr - 待排序的数组（假设元素都是非负整数）
 * @returns {number[]} - 排序后的数组
 */
function stableCountingSort(arr) {
  if (arr.length <= 1) return arr;

  // 找出数组中的最大值
  const max = Math.max(...arr);

  // 创建计数数组
  const counts = new Array(max + 1).fill(0);

  // 统计每个元素出现的次数
  for (let i = 0; i < arr.length; i++) {
    counts[arr[i]]++;
  }

  // 将counts转换为累加数组（前缀和），表示小于等于索引i的元素个数
  for (let i = 1; i <= max; i++) {
    counts[i] += counts[i - 1];
  }

  // 创建结果数组
  const result = new Array(arr.length);

  // 从后向前遍历原数组，保持稳定性
  for (let i = arr.length - 1; i >= 0; i--) {
    // counts[arr[i]]是arr[i]应该放置的位置（索引+1）
    // 所以实际索引是counts[arr[i]]-1
    result[counts[arr[i]] - 1] = arr[i];
    counts[arr[i]]--; // 减少计数，以处理重复元素
  }

  return result;
}

// 调用示例
const countingExample = [5, 3, 8, 4, 2, 5, 3, 1];
console.log("原始数组:", countingExample);
console.log("计数排序后:", countingSort([...countingExample]));
console.log("稳定计数排序后:", stableCountingSort([...countingExample]));
// 原始数组: [5, 3, 8, 4, 2, 5, 3, 1]
// 计数排序后: [1, 2, 3, 3, 4, 5, 5, 8]
// 稳定计数排序后: [1, 2, 3, 3, 4, 5, 5, 8]

// 执行过程分析（以[5, 3, 8, 4, 2]为例）
// 基本计数排序:
// 1. 找到最大值: max = 8
// 2. 创建计数数组: counts = [0, 0, 0, 0, 0, 0, 0, 0, 0]（长度为9）
// 3. 统计每个元素出现次数:
//    - counts[5]++ → [0, 0, 0, 0, 0, 1, 0, 0, 0]
//    - counts[3]++ → [0, 0, 0, 1, 0, 1, 0, 0, 0]
//    - counts[8]++ → [0, 0, 0, 1, 0, 1, 0, 0, 1]
//    - counts[4]++ → [0, 0, 0, 1, 1, 1, 0, 0, 1]
//    - counts[2]++ → [0, 0, 1, 1, 1, 1, 0, 0, 1]
// 4. 重建排序后的数组:
//    - 添加1个2: [2]
//    - 添加1个3: [2, 3]
//    - 添加1个4: [2, 3, 4]
//    - 添加1个5: [2, 3, 4, 5]
//    - 添加1个8: [2, 3, 4, 5, 8]
//
// 稳定计数排序:
// 1. 找到最大值: max = 8
// 2. 创建计数数组和计算频率同上
// 3. 计算前缀和:
//    - counts[0] = 0
//    - counts[1] = 0 + 0 = 0
//    - counts[2] = 0 + 1 = 1
//    - counts[3] = 1 + 1 = 2
//    - counts[4] = 2 + 1 = 3
//    - counts[5] = 3 + 1 = 4
//    - counts[6] = 4 + 0 = 4
//    - counts[7] = 4 + 0 = 4
//    - counts[8] = 4 + 1 = 5
// 4. 从后向前遍历原数组:
//    - arr[4] = 2, counts[2] = 1, result[0] = 2, counts[2]--
//    - arr[3] = 4, counts[4] = 3, result[2] = 4, counts[4]--
//    - arr[2] = 8, counts[8] = 5, result[4] = 8, counts[8]--
//    - arr[1] = 3, counts[3] = 2, result[1] = 3, counts[3]--
//    - arr[0] = 5, counts[5] = 4, result[3] = 5, counts[5]--
// 5. 最终结果: [2, 3, 4, 5, a8]

// 性能测试
function compareCountingSorts() {
  const sizes = [10000, 100000];
  const maxValues = [100, 1000, 10000];

  for (const size of sizes) {
    for (const maxValue of maxValues) {
      // 生成随机数组，元素大小在0到maxValue之间
      const randomArray = Array.from({ length: size }, () =>
        Math.floor(Math.random() * (maxValue + 1))
      );

      console.log(`\n测试大小为 ${size} 的数组，元素范围为 0-${maxValue}：`);

      // JavaScript内置排序
      console.time('JavaScript内置排序');
      [...randomArray].sort((a, b) => a - b);
      console.timeEnd('JavaScript内置排序');

      // 基本计数排序
      console.time('基本计数排序');
      countingSort([...randomArray]);
      console.timeEnd('基本计数排序');

      // 稳定计数排序
      console.time('稳定计数排序');
      stableCountingSort([...randomArray]);
      console.timeEnd('稳定计数排序');
    }
  }
}

// 取消注释下行运行性能测试
// compareCountingSorts();

// 示例输出:
// 测试大小为 10000 的数组，元素范围为 0-100：
// JavaScript内置排序: 2.564ms
// 基本计数排序: 0.425ms
// 稳定计数排序: 0.622ms
//
// 测试大小为 10000 的数组，元素范围为 0-1000：
// JavaScript内置排序: 2.427ms
// 基本计数排序: 1.186ms
// 稳定计数排序: 1.354ms
//
// 测试大小为 100000 的数组，元素范围为 0-100：
// JavaScript内置排序: 31.275ms
// 基本计数排序: 2.684ms
// 稳定计数排序: 3.842ms
```

**时间复杂度**：O(n + k)，其中k是数组中的最大值

**空间复杂度**：O(k)

**稳定性**：
- 基本实现：稳定
- 优化实现：稳定

**适用场景**：
1. 适合对整数进行排序
2. 特别适合当数据范围（k）相对较小时
3. 当需要O(n)时间复杂度时
4. 不适合数据范围非常大的情况（如排序浮点数）

### 9. 桶排序

桶排序是将数据分到有限数量的桶里，每个桶再分别排序（可能使用别的排序算法或递归使用桶排序）。

```javascript
/**
 * @description 桶排序实现
 * @param {number[]} arr - 待排序的数组
 * @param {number} [bucketSize=5] - 每个桶的大小
 * @returns {number[]} - 排序后的数组
 * @example
 * const arr = [5, 3, 8, 4, 2, 7, 1, 6];
 * console.log(bucketSort(arr)); // [1, 2, 3, 4, 5, 6, 7, 8]
 */
function bucketSort(arr, bucketSize = 5) {
  if (arr.length <= 1) return arr;

  // 找出数组中的最大值和最小值
  const min = Math.min(...arr);
  const max = Math.max(...arr);

  // 计算桶的数量
  const bucketCount = Math.floor((max - min) / bucketSize) + 1;
  const buckets = new Array(bucketCount);

  // 初始化桶
  for (let i = 0; i < bucketCount; i++) {
    buckets[i] = [];
  }

  // 将元素分配到桶中
  for (let i = 0; i < arr.length; i++) {
    const bucketIndex = Math.floor((arr[i] - min) / bucketSize);
    buckets[bucketIndex].push(arr[i]);
  }

  // 对每个桶进行排序，并合并结果
  const result = [];
  for (let i = 0; i < bucketCount; i++) {
    // 使用插入排序对每个桶进行排序
    insertionSort(buckets[i]);
    result.push(...buckets[i]);
  }

  return result;
}

/**
 * @description 优化版桶排序（处理均匀分布的数据）
 * @param {number[]} arr - 待排序的数组
 * @param {number} [bucketCount=10] - 桶的数量
 * @returns {number[]} - 排序后的数组
 */
function optimizedBucketSort(arr, bucketCount = 10) {
  if (arr.length <= 1) return arr;

  // 找出数组中的最大值和最小值
  const min = Math.min(...arr);
  const max = Math.max(...arr);

  // 桶的大小
  const bucketSize = (max - min) / bucketCount + 1;
  const buckets = new Array(bucketCount);

  // 初始化桶
  for (let i = 0; i < bucketCount; i++) {
    buckets[i] = [];
  }

  // 将元素分配到桶中
  for (const num of arr) {
    const bucketIndex = Math.floor((num - min) / bucketSize);
    buckets[bucketIndex].push(num);
  }

  // 对每个桶进行排序，并合并结果
  const result = [];
  for (const bucket of buckets) {
    if (bucket.length > 0) {
      // 使用更高效的排序方法
      bucket.sort((a, b) => a - b);
      result.push(...bucket);
    }
  }

  return result;
}

// 调用示例
const bucketExample = [5, 3, 8, 4, 2, 7, 1, 6];
console.log("原始数组:", bucketExample);
console.log("桶排序后:", bucketSort([...bucketExample]));
console.log("优化桶排序后:", optimizedBucketSort([...bucketExample]));
// 原始数组: [5, 3, 8, 4, 2, 7, 1, 6]
// 桶排序后: [1, 2, 3, 4, 5, 6, 7, 8]
// 优化桶排序后: [1, 2, 3, 4, 5, 6, 7, 8]

// 执行过程分析（以[5, 3, 8, 4, 2, 7, 1, 6]为例，桶大小为3）
// 1. 找到最大值max=8和最小值min=1
// 2. 计算桶的数量：bucketCount = Math.floor((8 - 1) / 3) + 1 = 3
// 3. 创建3个空桶
// 4. 将元素分配到桶中：
//    - 桶0 (1-3): [1, 2, 3]
//    - 桶1 (4-6): [5, 4, 6]
//    - 桶2 (7-9): [8, 7]
// 5. 对每个桶排序:
//    - 桶0: [1, 2, 3]
//    - 桶1: [4, 5, 6]
//    - 桶2: [7, 8]
// 6. 合并结果: [1, 2, 3, 4, 5, 6, 7, 8]

// 性能测试
function compareBucketSorts() {
  // 生成三种分布的数组
  function generateArrays(size) {
    // 均匀分布
    const uniform = Array.from({ length: size }, () =>
      Math.random() * 1000
    );

    // 聚集分布（元素集中在某些范围）
    const clustered = [];
    for (let i = 0; i < size; i++) {
      // 80%的元素在0-200范围内，20%在800-1000范围内
      if (Math.random() < 0.8) {
        clustered.push(Math.random() * 200);
      } else {
        clustered.push(800 + Math.random() * 200);
      }
    }

    // 倾斜分布（大部分元素小，少数元素大）
    const skewed = Array.from({ length: size }, () =>
      Math.pow(Math.random(), 2) * 1000
    );

    return { uniform, clustered, skewed };
  }

  const sizes = [10000];

  for (const size of sizes) {
    const { uniform, clustered, skewed } = generateArrays(size);

    console.log(`\n测试大小为 ${size} 的均匀分布数组：`);
    testSortingAlgorithms(uniform);

    console.log(`\n测试大小为 ${size} 的聚集分布数组：`);
    testSortingAlgorithms(clustered);

    console.log(`\n测试大小为 ${size} 的倾斜分布数组：`);
    testSortingAlgorithms(skewed);
  }

  function testSortingAlgorithms(arr) {
    // JavaScript内置排序
    console.time('JavaScript内置排序');
    [...arr].sort((a, b) => a - b);
    console.timeEnd('JavaScript内置排序');

    // 基本桶排序（固定桶大小）
    console.time('基本桶排序');
    bucketSort([...arr]);
    console.timeEnd('基本桶排序');

    // 优化桶排序（固定桶数量）
    console.time('优化桶排序');
    optimizedBucketSort([...arr]);
    console.timeEnd('优化桶排序');

    // 不同桶数量的测试
    for (const count of [5, 20, 50]) {
      console.time(`桶排序(${count}个桶)`);
      optimizedBucketSort([...arr], count);
      console.timeEnd(`桶排序(${count}个桶)`);
    }
  }
}

// 取消注释下行运行性能测试
// compareBucketSorts();

// 示例输出:
// 测试大小为 10000 的均匀分布数组：
// JavaScript内置排序: 3.127ms
// 基本桶排序: 8.354ms
// 优化桶排序: 5.216ms
// 桶排序(5个桶): 5.032ms
// 桶排序(20个桶): 3.874ms
// 桶排序(50个桶): 3.245ms
//
// 测试大小为 10000 的聚集分布数组：
// JavaScript内置排序: 2.851ms
// 基本桶排序: 6.234ms
// 优化桶排序: 4.723ms
// 桶排序(5个桶): 6.857ms
// 桶排序(20个桶): 4.125ms
// 桶排序(50个桶): 3.567ms
```

**时间复杂度**：
- 平均情况：O(n + k)，其中k是桶的数量
- 最坏情况：O(n²)，当所有元素都被分到同一个桶中时

**空间复杂度**：O(n + k)

**稳定性**：取决于桶内排序算法的稳定性

**桶排序的优化策略**：
1. 根据数据分布特性选择合适的桶数量
2. 对均匀分布的数据，使用更多的桶来提高性能
3. 根据数据范围动态调整桶的大小
4. 结合其他高效排序算法作为桶内排序方法
5. 对于大数据量，可以并行处理不同的桶

### 10. 基数排序

基数排序是一种非比较型整数排序算法，它按照位数来排序，从最低位开始，依次按位数进行排序，直到最高位。

```javascript
/**
 * @description 基数排序实现（仅适用于非负整数）
 * @param {number[]} arr - 待排序的数组
 * @returns {number[]} - 排序后的数组
 * @example
 * const arr = [170, 45, 75, 90, 802, 24, 2, 66];
 * console.log(radixSort(arr)); // [2, 24, 45, 66, 75, 90, 170, 802]
 */
function radixSort(arr) {
  if (arr.length <= 1) return arr;

  // 找出最大值，确定最大位数
  const max = Math.max(...arr);
  let maxDigits = 0;
  while (Math.pow(10, maxDigits) <= max) {
    maxDigits++;
  }

  // 按照每一位进行计数排序
  let result = [...arr];
  for (let digit = 0; digit < maxDigits; digit++) {
    // 创建10个桶（对应0-9）
    const buckets = Array.from({ length: 10 }, () => []);

    // 将元素分配到桶中
    for (let i = 0; i < result.length; i++) {
      // 获取当前位的值
      const digitValue = Math.floor(result[i] / Math.pow(10, digit)) % 10;
      buckets[digitValue].push(result[i]);
    }

    // 合并桶中的元素
    result = [].concat(...buckets);
  }

  return result;
}

/**
 * @description 基数排序的优化实现（减少创建数组的开销）
 * @param {number[]} arr - 待排序的数组
 * @returns {number[]} - 排序后的数组
 */
function optimizedRadixSort(arr) {
  if (arr.length <= 1) return arr;

  // 找出最大值
  const max = Math.max(...arr);

  // 当前基数（从个位开始）
  let radix = 1;

  // 结果数组，初始为原数组的副本
  const result = [...arr];

  // 临时数组，用于存储排序结果
  const temp = new Array(arr.length);

  // 当前基数小于最大值时继续排序
  while (radix <= max) {
    // 计数数组，记录每个数字出现的次数
    const count = new Array(10).fill(0);

    // 统计每个数字出现的次数
    for (let i = 0; i < result.length; i++) {
      const digit = Math.floor(result[i] / radix) % 10;
      count[digit]++;
    }

    // 将count转换为累加数组
    for (let i = 1; i < 10; i++) {
      count[i] += count[i - 1];
    }

    // 从后向前遍历，保持稳定性
    for (let i = result.length - 1; i >= 0; i--) {
      const digit = Math.floor(result[i] / radix) % 10;
      temp[count[digit] - 1] = result[i];
      count[digit]--;
    }

    // 将临时数组的值复制回结果数组
    for (let i = 0; i < result.length; i++) {
      result[i] = temp[i];
    }

    // 进位，处理下一个数位
    radix *= 10;
  }

  return result;
}

// 调用示例
const radixExample = [170, 45, 75, 90, 802, 24, 2, 66];
console.log("原始数组:", radixExample);
console.log("基数排序后:", radixSort([...radixExample]));
console.log("优化基数排序后:", optimizedRadixSort([...radixExample]));
// 原始数组: [170, 45, 75, 90, 802, 24, 2, 66]
// 基数排序后: [2, 24, 45, 66, 75, 90, 170, 802]
// 优化基数排序后: [2, 24, 45, 66, 75, 90, 170, 802]

// 执行过程分析（以[170, 45, 75, 90, 802, 24, 2, 66]为例）
// 1. 找到最大值802，确定最大位数为3
// 2. 第一轮：按个位数排序
//    - 桶0: [170, 90]
//    - 桶2: [802, 2]
//    - 桶4: [24]
//    - 桶5: [45, 75]
//    - 桶6: [66]
//    - 合并结果: [170, 90, 802, 2, 24, 45, 75, 66]
// 3. 第二轮：按十位数排序
//    - 桶0: [802, 2]
//    - 桶2: [24]
//    - 桶4: [45]
//    - 桶6: [66]
//    - 桶7: [170, 75]
//    - 桶9: [90]
//    - 合并结果: [802, 2, 24, 45, 66, 170, 75, 90]
// 4. 第三轮：按百位数排序
//    - 桶0: [2, 24, 45, 66, 75, 90]
//    - 桶1: [170]
//    - 桶8: [802]
//    - 合并结果: [2, 24, 45, 66, 75, 90, 170, 802]

// 性能测试
function compareRadixSorts() {
  const sizes = [10000, 100000];
  const maxValues = [999, 9999, 99999];

  for (const size of sizes) {
    for (const maxValue of maxValues) {
      // 生成随机数组，元素大小在0到maxValue之间
      const randomArray = Array.from({ length: size }, () =>
        Math.floor(Math.random() * (maxValue + 1))
      );

      console.log(`\n测试大小为 ${size} 的数组，元素范围为 0-${maxValue}：`);

      // JavaScript内置排序
      console.time('JavaScript内置排序');
      [...randomArray].sort((a, b) => a - b);
      console.timeEnd('JavaScript内置排序');

      // 基本基数排序
      console.time('基本基数排序');
      radixSort([...randomArray]);
      console.timeEnd('基本基数排序');

      // 优化基数排序
      console.time('优化基数排序');
      optimizedRadixSort([...randomArray]);
      console.timeEnd('优化基数排序');
    }
  }
}

// 取消注释下行运行性能测试
// compareRadixSorts();

// 示例输出:
// 测试大小为 10000 的数组，元素范围为 0-999：
// JavaScript内置排序: 2.954ms
// 基本基数排序: 3.845ms
// 优化基数排序: 2.431ms
//
// 测试大小为 10000 的数组，元素范围为 0-9999：
// JavaScript内置排序: 3.175ms
// 基本基数排序: 5.231ms
// 优化基数排序: 3.842ms
//
// 测试大小为 100000 的数组，元素范围为 0-999：
// JavaScript内置排序: 34.215ms
// 基本基数排序: 32.567ms
// 优化基数排序: 23.654ms
```

**时间复杂度**：O(d * (n + k))，其中d是最大位数，k是基数（这里是10）

**空间复杂度**：O(n + k)

**稳定性**：稳定

**基数排序的特点**：
1. 适用于整数和字符串等可以按位比较的数据
2. 当数据位数较少时效率很高
3. 不需要比较元素的大小，只需要按位进行计数排序
4. 对于数值范围大但位数少的数据特别有效
5. 具有稳定性，适合对具有多个排序关键字的记录进行排序

**基数排序的局限性**：
1. 只适用于可以按位比较的数据类型
2. 对于负数需要特殊处理
3. 对于浮点数排序需要转换为整数
4. 当数据位数很多时，性能可能不如比较排序算法

## 排序算法的比较

| 排序算法 | 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 | 稳定性 |
|---------|--------------|---------|---------|-----------|-------|
| 冒泡排序 | O(n²) | O(n) | O(n²) | O(1) | 稳定 |
| 选择排序 | O(n²) | O(n²) | O(n²) | O(1) | 不稳定 |
| 插入排序 | O(n²) | O(n) | O(n²) | O(1) | 稳定 |
| 希尔排序 | O(n log² n) | O(n log² n) | O(n²) | O(1) | 不稳定 |
| 归并排序 | O(n log n) | O(n log n) | O(n log n) | O(n) | 稳定 |
| 快速排序 | O(n log n) | O(n log n) | O(n²) | O(log n) | 不稳定 |
| 堆排序 | O(n log n) | O(n log n) | O(n log n) | O(1) | 不稳定 |
| 计数排序 | O(n + k) | O(n + k) | O(n + k) | O(k) | 稳定 |
| 桶排序 | O(n + k) | O(n + k) | O(n²) | O(n + k) | 取决于桶内排序算法 |
| 基数排序 | O(d * (n + k)) | O(d * (n + k)) | O(d * (n + k)) | O(n + k) | 稳定 |

## 面试常见问题

### 1. 快速排序和归并排序的区别是什么？各自的优缺点？

**答**：

快速排序和归并排序都是高效的比较排序算法，时间复杂度为O(n log n)，但它们的工作原理、性能特点和适用场景有所不同。

**工作原理比较**：

```javascript
/**
 * @description 快速排序实现
 */
function quickSort(arr, left = 0, right = arr.length - 1) {
  if (left < right) {
    // 分区过程 - 选择基准并将数组分为两部分
    const pivotIndex = partition(arr, left, right);

    // 递归排序两个子数组
    quickSort(arr, left, pivotIndex - 1);  // 排序基准左侧
    quickSort(arr, pivotIndex + 1, right); // 排序基准右侧
  }
  return arr;
}

function partition(arr, left, right) {
  // 选择最右元素为基准
  const pivot = arr[right];
  let i = left - 1;

  // 将小于基准的元素移到左侧
  for (let j = left; j < right; j++) {
    if (arr[j] <= pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // 将基准放到正确位置
  [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
  return i + 1;
}

/**
 * @description 归并排序实现
 */
function mergeSort(arr) {
  // 基本情况 - 数组长度为0或1时已排序
  if (arr.length <= 1) return arr;

  // 分割数组
  const mid = Math.floor(arr.length / 2);
  const left = arr.slice(0, mid);
  const right = arr.slice(mid);

  // 递归排序两半，然后合并
  return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
  const result = [];
  let leftIndex = 0;
  let rightIndex = 0;

  // 比较两个数组的元素，将较小的元素添加到结果数组
  while (leftIndex < left.length && rightIndex < right.length) {
    if (left[leftIndex] < right[rightIndex]) {
      result.push(left[leftIndex]);
      leftIndex++;
    } else {
      result.push(right[rightIndex]);
      rightIndex++;
    }
  }

  // 添加剩余元素
  return result.concat(
    left.slice(leftIndex),
    right.slice(rightIndex)
  );
}
```

**主要区别**：

| 特性 | 快速排序 | 归并排序 |
|------|----------|----------|
| **分治策略** | 先分区，后递归处理 | 先递归分割，后合并 |
| **原地排序** | 是（空间复杂度O(log n)） | 否（需要额外O(n)空间） |
| **稳定性** | 不稳定 | 稳定 |
| **时间复杂度** | 最好/平均：O(n log n)<br>最坏：O(n²) | 稳定在O(n log n) |
| **适用场景** | 随机访问数据<br>内存受限环境 | 链表排序<br>稳定性要求高 |
| **缓存效率** | 高（局部性好） | 一般 |
| **并行潜力** | 较低 | 高 |

**优缺点分析**：

**快速排序**：
- **优点**：
  - 原地排序，空间效率高
  - 平均情况下非常快
  - 缓存友好，局部性好
  - 常数因子小，实际性能常优于其他O(n log n)算法
- **缺点**：
  - 最坏情况下时间复杂度为O(n²)
  - 对于已排序或近乎排序的数据表现不佳
  - 不稳定排序，相等元素的相对位置可能改变
  - 对于小数组，递归开销较大

**归并排序**：
- **优点**：
  - 稳定排序，保持相等元素的相对顺序
  - 时间复杂度稳定在O(n log n)，不受输入数据分布影响
  - 适合外部排序和链表排序
  - 易于并行化实现
- **缺点**：
  - 需要额外O(n)的空间
  - 对于小数组，常数因子较大
  - 缓存效率不如快速排序
  - 不是原地排序，空间效率较低

**性能比较**：

```javascript
// 性能测试比较
function comparePerformance() {
  const sizes = [1000, 10000, 100000];

  for (const size of sizes) {
    console.log(`\n测试大小为 ${size} 的数组：`);

    // 生成三种测试数组
    const random = Array.from({ length: size }, () => Math.floor(Math.random() * size));
    const nearSorted = Array.from({ length: size }, (_, i) => i + Math.floor(Math.random() * 10 - 5));
    const reversed = Array.from({ length: size }, (_, i) => size - i);

    // 测试随机数组
    console.log("随机数组：");
    testAlgorithms(random);

    // 测试近乎排序的数组
    console.log("近乎排序的数组：");
    testAlgorithms(nearSorted);

    // 测试逆序数组
    console.log("逆序数组：");
    testAlgorithms(reversed);
  }

  function testAlgorithms(arr) {
    // 快速排序测试
    const quickArr = [...arr];
    console.time('快速排序');
    quickSort(quickArr);
    console.timeEnd('快速排序');

    // 归并排序测试
    const mergeArr = [...arr];
    console.time('归并排序');
    mergeSort(mergeArr);
    console.timeEnd('归并排序');
  }
}

// 输出示例 (仅供参考，实际性能因环境而异)
// 测试大小为 10000 的数组：
// 随机数组：
// 快速排序: 5.212ms
// 归并排序: 8.354ms
// 近乎排序的数组：
// 快速排序: 12.571ms (性能下降)
// 归并排序: 7.921ms
// 逆序数组：
// 快速排序: 15.324ms (性能显著下降)
// 归并排序: 8.234ms (性能稳定)
```

**在实际应用中的选择**：

1. **选择快速排序的情况**：
   - 内存空间有限
   - 对原地排序有要求
   - 数据是随机分布的
   - 排序稳定性不重要
   - 追求平均情况下的最佳性能

2. **选择归并排序的情况**：
   - 要求排序稳定性
   - 对时间复杂度最坏情况有严格要求
   - 处理链表等顺序访问的数据结构
   - 可以使用额外的内存空间
   - 需要外部排序（如大文件排序）

**前端开发中的应用**：
- 在前端处理中小型数据集时，两种算法都适用
- 对于需要稳定排序的UI元素（如表格排序），归并排序更合适
- 对于频繁排序的操作，快速排序通常性能更好
- 实际项目中，可以考虑混合策略：小数组使用插入排序，大数组根据数据特性选择快速排序或归并排序

## 学习资源

- [JavaScript数据结构 - 排序算法](https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting) - GitHub上的JS实现
- [排序算法可视化](https://visualgo.net/en/sorting) - 排序算法的可视化演示
- [LeetCode排序题集](https://leetcode.com/tag/sorting/) - 相关算法练习
- [前端进阶之道 - 排序算法](https://juejin.cn/post/6844903814134104078) - 前端视角的排序算法讲解
- [JavaScript排序算法详解](https://www.freecodecamp.org/news/sorting-algorithms-explained/) - FreeCodeCamp上的教程

## JavaScript内置排序

JavaScript提供了内置的`Array.prototype.sort()`方法，它接受一个可选的比较函数作为参数：

```javascript
/**
 * @description 演示JavaScript内置排序方法的用法
 */
function demonstrateJavaScriptSort() {
  console.log("=== JavaScript内置排序示例 ===");

  // 1. 基本用法 - 默认按字典序排序
  const fruits = ['banana', 'apple', 'orange', 'grape'];
  fruits.sort();
  console.log("默认字符串排序:", fruits);
  // 输出: ['apple', 'banana', 'grape', 'orange']

  // 2. 数字排序 - 需要提供比较函数
  const numbers = [10, 5, 8, 2, 1, 100];

  // 错误的数字排序方式（会按字符串比较）
  const wrongSorted = [...numbers].sort();
  console.log("错误的数字排序:", wrongSorted);
  // 输出: [1, 10, 100, 2, 5, 8] - 按字符串排序！

  // 正确的数字排序方式
  const correctSorted = [...numbers].sort((a, b) => a - b);
  console.log("正确的数字排序(升序):", correctSorted);
  // 输出: [1, 2, 5, 8, 10, 100]

  const descendingSorted = [...numbers].sort((a, b) => b - a);
  console.log("降序排序:", descendingSorted);
  // 输出: [100, 10, 8, 5, 2, 1]

  // 3. 对象排序
  const people = [
    { name: 'Alice', age: 25 },
    { name: 'Bob', age: 30 },
    { name: 'Charlie', age: 20 },
    { name: 'David', age: 25 }
  ];

  // 按年龄排序
  const byAge = [...people].sort((a, b) => a.age - b.age);
  console.log("按年龄排序:", byAge.map(p => `${p.name}(${p.age})`).join(', '));
  // 输出: Charlie(20), Alice(25), David(25), Bob(30)

  // 按名字排序
  const byName = [...people].sort((a, b) => a.name.localeCompare(b.name));
  console.log("按名字排序:", byName.map(p => p.name).join(', '));
  // 输出: Alice, Bob, Charlie, David

  // 4. 多条件排序
  // 先按年龄，再按名字
  const multiCriteria = [...people].sort((a, b) => {
    if (a.age !== b.age) {
      return a.age - b.age;
    }
    return a.name.localeCompare(b.name);
  });
  console.log("多条件排序:", multiCriteria.map(p => `${p.name}(${p.age})`).join(', '));
  // 输出: Charlie(20), Alice(25), David(25), Bob(30)

  // 5. 自定义排序逻辑
  const items = ['Item 1', 'item 2', 'Item 10', 'item 11'];

  // 不区分大小写，按数字正确排序
  items.sort((a, b) => {
    // 提取数字部分
    const numA = parseInt(a.match(/\d+/)[0]);
    const numB = parseInt(b.match(/\d+/)[0]);

    // 如果数字不同，按数字排序
    if (numA !== numB) {
      return numA - numB;
    }

    // 否则不区分大小写排序
    return a.toLowerCase().localeCompare(b.toLowerCase());
  });

  console.log("自定义排序:", items);
  // 输出: ['Item 1', 'item 2', 'Item 10', 'item 11']
}

// 调用示例
// demonstrateJavaScriptSort();
```

不同浏览器实现的排序算法可能不同，但大多数现代浏览器使用的是一种混合排序算法，如TimSort（归并排序和插入排序的混合）或IntroSort（快速排序、堆排序和插入排序的混合）。

**JavaScript内置排序的特点**：

1. **算法实现**：
   - **V8引擎(Chrome, Node.js)**：对于长度小于等于10的数组使用插入排序，对于长度大于10的数组使用快速排序或TimSort（V8版本7.0及以后）
   - **SpiderMonkey(Firefox)**：使用归并排序
   - **JavaScriptCore(Safari)**：使用归并排序的变体
   - **Chakra(旧版Edge)**：使用快速排序的变体

2. **稳定性**：在ES2019(ES10)规范之后，明确要求排序算法是稳定的。但不同浏览器实现可能有差异。

3. **默认行为**：默认按Unicode码点排序（字符串比较），对数字需要提供比较函数。

4. **性能特点**：
   - 对小数组（通常<10）使用插入排序
   - 对大数组使用O(n log n)的算法（快速排序或TimSort）
   - 现代浏览器会根据数组特性自适应选择排序算法

**前端排序最佳实践**：

1. **数字排序**：
   ```javascript
   // ✅ 正确方法
   numbers.sort((a, b) => a - b);

   // ❌ 错误方法（按字符串排序）
   numbers.sort();
   ```

2. **字符串排序**：
   ```javascript
   // 区分大小写排序
   strings.sort();

   // 不区分大小写排序
   strings.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

   // 国际化支持（考虑不同语言的排序规则）
   strings.sort((a, b) => a.localeCompare(b, 'zh-CN')); // 中文排序
   ```

3. **对象排序**：
   ```javascript
   // 按单个属性排序
   users.sort((a, b) => a.age - b.age);

   // 按多个属性排序
   users.sort((a, b) => {
     // 首先按角色排序
     const roleOrder = { admin: 1, user: 2, guest: 3 };
     if (roleOrder[a.role] !== roleOrder[b.role]) {
       return roleOrder[a.role] - roleOrder[b.role];
     }
     // 角色相同则按名字排序
     return a.name.localeCompare(b.name);
   });
   ```

4. **性能优化**：
   ```javascript
   // 对于频繁排序的场景，缓存排序函数
   const sortByAge = (a, b) => a.age - b.age;
   users.sort(sortByAge);

   // 对于大数据集，考虑仅排序可见部分
   const visibleData = allData.slice(offset, offset + pageSize);
   visibleData.sort((a, b) => a - b);
   ```

5. **前端表格排序**：
   ```javascript
   // 表格排序功能示例
   function sortTable(tableId, columnIndex) {
     const table = document.getElementById(tableId);
     const tbody = table.querySelector('tbody');
     const rows = Array.from(tbody.querySelectorAll('tr'));

     // 获取当前排序方向
     const sortDirection = tbody.dataset.sortDirection === 'asc' ? 'desc' : 'asc';
     tbody.dataset.sortDirection = sortDirection;

     // 排序行
     rows.sort((rowA, rowB) => {
       const cellA = rowA.cells[columnIndex].textContent.trim();
       const cellB = rowB.cells[columnIndex].textContent.trim();

       // 尝试作为数字比较
       const numA = parseFloat(cellA);
       const numB = parseFloat(cellB);

       if (!isNaN(numA) && !isNaN(numB)) {
         return sortDirection === 'asc' ? numA - numB : numB - numA;
       }

       // 否则作为字符串比较
       return sortDirection === 'asc'
         ? cellA.localeCompare(cellB)
         : cellB.localeCompare(cellA);
     });

     // 重新插入排序后的行
     rows.forEach(row => tbody.appendChild(row));
   }
   ```

6. **稳定排序示例**：
   ```javascript
   // 稳定多条件排序（先按提交时间排序，再按分数排序）
   const submissions = [
     { name: 'Alice', score: 85, time: '10:15' },
     { name: 'Bob', score: 90, time: '10:10' },
     { name: 'Charlie', score: 85, time: '10:05' },
     { name: 'David', score: 90, time: '10:20' }
   ];

   // 先按提交时间排序
   submissions.sort((a, b) => a.time.localeCompare(b.time));

   // 再按分数排序（稳定排序保持同分数下的时间顺序）
   submissions.sort((a, b) => b.score - a.score);

   // 结果:
   // Bob: 90分 (10:10)
   // David: 90分 (10:20)
   // Charlie: 85分 (10:05)
   // Alice: 85分 (10:15)
   ```

## 面试常见问题

### 2. 如何优化快速排序以避免最坏情况？

**答**：

快速排序最坏情况（O(n²)）通常发生在数组已排序或几乎排序，或者有大量重复元素的情况下，因为这会导致分区极度不平衡。下面是几种常用的优化策略及其实现：

#### 1. 随机选择基准元素

最简单有效的优化是随机选择基准元素，而不是总是选择第一个或最后一个元素：

```javascript
/**
 * @description 使用随机基准的快速排序
 */
function randomizedQuickSort(arr, left = 0, right = arr.length - 1) {
  if (left < right) {
    const pivotIndex = randomizedPartition(arr, left, right);
    randomizedQuickSort(arr, left, pivotIndex - 1);
    randomizedQuickSort(arr, pivotIndex + 1, right);
  }
  return arr;
}

function randomizedPartition(arr, left, right) {
  // 随机选择基准点
  const randomIndex = left + Math.floor(Math.random() * (right - left + 1));
  // 将随机选择的元素与最右元素交换
  [arr[randomIndex], arr[right]] = [arr[right], arr[randomIndex]];

  // 执行标准分区过程
  return partition(arr, left, right);
}

function partition(arr, left, right) {
  const pivot = arr[right];
  let i = left - 1;

  for (let j = left; j < right; j++) {
    if (arr[j] <= pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
  return i + 1;
}
```

#### 2. 三数取中法（Median-of-three）

这种方法取左端、中间、右端三个元素的中间值作为基准，减少选择到最值的可能性：

```javascript
/**
 * @description 使用三数取中法的快速排序
 */
function medianOfThreeQuickSort(arr, left = 0, right = arr.length - 1) {
  if (left < right) {
    const pivotIndex = medianOfThreePartition(arr, left, right);
    medianOfThreeQuickSort(arr, left, pivotIndex - 1);
    medianOfThreeQuickSort(arr, pivotIndex + 1, right);
  }
  return arr;
}

function medianOfThreePartition(arr, left, right) {
  // 选择左中右三个位置的中间值作为基准
  const mid = Math.floor((left + right) / 2);

  // 对三个元素进行排序
  if (arr[left] > arr[mid]) [arr[left], arr[mid]] = [arr[mid], arr[left]];
  if (arr[left] > arr[right]) [arr[left], arr[right]] = [arr[right], arr[left]];
  if (arr[mid] > arr[right]) [arr[mid], arr[right]] = [arr[right], arr[mid]];

  // 将中间值（现在在arr[mid]）与右边前一个元素交换
  // 这样可以把基准放在倒数第二个位置，有助于分区过程
  [arr[mid], arr[right - 1]] = [arr[right - 1], arr[mid]];

  // 基准是arr[right - 1]
  const pivot = arr[right - 1];

  // 分区过程（从left+1到right-2，因为left和right已知）
  let i = left;
  for (let j = left + 1; j < right - 1; j++) {
    if (arr[j] <= pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // 将基准放在正确位置
  [arr[i + 1], arr[right - 1]] = [arr[right - 1], arr[i + 1]];
  return i + 1;
}
```

#### 3. 对小规模子数组使用插入排序

当子数组规模小于某个阈值时，使用插入排序更高效：

```javascript
/**
 * @description 混合使用快速排序和插入排序
 */
function hybridQuickSort(arr, left = 0, right = arr.length - 1) {
  // 小规模数组使用插入排序
  if (right - left < 10) {
    insertionSort(arr, left, right);
    return arr;
  }

  if (left < right) {
    const pivotIndex = randomizedPartition(arr, left, right);
    hybridQuickSort(arr, left, pivotIndex - 1);
    hybridQuickSort(arr, pivotIndex + 1, right);
  }
  return arr;
}

function insertionSort(arr, left, right) {
  for (let i = left + 1; i <= right; i++) {
    const key = arr[i];
    let j = i - 1;

    while (j >= left && arr[j] > key) {
      arr[j + 1] = arr[j];
      j--;
    }
    arr[j + 1] = key;
  }
  return arr;
}
```

#### 4. 三路快速排序（处理重复元素）

对于有大量重复元素的数组，三路快速排序将数组分为三部分：小于、等于和大于基准的元素：

```javascript
/**
 * @description 三路快速排序
 */
function threeWayQuickSort(arr, left = 0, right = arr.length - 1) {
  if (right <= left) return;

  // 随机选择基准并交换到首位置
  const randomIndex = left + Math.floor(Math.random() * (right - left + 1));
  [arr[left], arr[randomIndex]] = [arr[randomIndex], arr[left]];
  const pivot = arr[left];

  // 三路分区
  let lt = left;      // arr[left...lt-1] < pivot
  let gt = right;     // arr[gt+1...right] > pivot
  let i = left + 1;   // arr[lt...i-1] == pivot

  while (i <= gt) {
    if (arr[i] < pivot) {
      // 小于基准的元素放到左边
      [arr[lt], arr[i]] = [arr[i], arr[lt]];
      lt++;
      i++;
    } else if (arr[i] > pivot) {
      // 大于基准的元素放到右边
      [arr[i], arr[gt]] = [arr[gt], arr[i]];
      gt--;
      // 注意i不增加，因为交换过来的元素还未处理
    } else {
      // 等于基准的元素留在中间
      i++;
    }
  }

  // 递归处理左右两部分，中间部分（等于基准）已排好序
  threeWayQuickSort(arr, left, lt - 1);
  threeWayQuickSort(arr, gt + 1, right);

  return arr;
}
```

#### 5. 尾递归优化

通过尾递归优化减少递归调用栈的深度，降低栈溢出风险：

```javascript
/**
 * @description 尾递归优化的快速排序
 */
function tailRecursiveQuickSort(arr, left = 0, right = arr.length - 1) {
  while (left < right) {
    const pivotIndex = partition(arr, left, right);

    // 递归处理较小的子数组
    // 迭代处理较大的子数组（减少递归深度）
    if (pivotIndex - left < right - pivotIndex) {
      tailRecursiveQuickSort(arr, left, pivotIndex - 1);
      left = pivotIndex + 1;
    } else {
      tailRecursiveQuickSort(arr, pivotIndex + 1, right);
      right = pivotIndex - 1;
    }
  }
  return arr;
}
```

#### 性能比较分析

```javascript
/**
 * @description 比较不同快速排序优化策略的性能
 */
function compareQuickSortOptimizations() {
  // 生成测试数据
  function generateArrays(size) {
    // 随机数组
    const random = Array.from({ length: size }, () => Math.floor(Math.random() * size));

    // 已排序数组
    const sorted = Array.from({ length: size }, (_, i) => i);

    // 近乎排序的数组
    const nearlySorted = Array.from(sorted);
    for (let i = 0; i < size * 0.1; i++) {
      const j = Math.floor(Math.random() * size);
      const k = Math.floor(Math.random() * size);
      [nearlySorted[j], nearlySorted[k]] = [nearlySorted[k], nearlySorted[j]];
    }

    // 包含大量重复元素的数组
    const repeating = Array.from({ length: size }, () => Math.floor(Math.random() * (size / 10)));

    return { random, sorted, nearlySorted, repeating };
  }

  const size = 10000;
  console.log(`测试大小为 ${size} 的数组：`);

  const arrays = generateArrays(size);

  // 测试不同类型的数组
  for (const [type, array] of Object.entries(arrays)) {
    console.log(`\n${type} 数组：`);

    // 标准快速排序
    test("标准快速排序", () => quickSort([...array]));

    // 随机基准快速排序
    test("随机基准快速排序", () => randomizedQuickSort([...array]));

    // 三数取中快速排序
    test("三数取中快速排序", () => medianOfThreeQuickSort([...array]));

    // 混合快排和插入排序
    test("混合快速插入排序", () => hybridQuickSort([...array]));

    // 三路快速排序
    test("三路快速排序", () => threeWayQuickSort([...array]));

    // 尾递归优化快速排序
    test("尾递归快速排序", () => tailRecursiveQuickSort([...array]));
  }

  function test(name, sortFn) {
    const start = performance.now();
    sortFn();
    const end = performance.now();
    console.log(`${name}: ${(end - start).toFixed(3)}ms`);
  }
}

// 测试结果示例（结果会因环境而异）
// random 数组：
// 标准快速排序: 3.245ms
// 随机基准快速排序: 3.512ms
// 三数取中快速排序: 2.987ms
// 混合快速插入排序: 2.754ms
// 三路快速排序: 3.621ms
// 尾递归快速排序: 3.354ms

// sorted 数组：
// 标准快速排序: 150.325ms (性能大幅下降)
// 随机基准快速排序: 3.487ms
// 三数取中快速排序: 2.876ms
// 混合快速插入排序: 2.654ms
// 三路快速排序: 3.112ms
// 尾递归快速排序: 3.421ms

// repeating 数组：
// 标准快速排序: 21.547ms
// 随机基准快速排序: 10.234ms
// 三数取中快速排序: 8.654ms
// 混合快速插入排序: 7.987ms
// 三路快速排序: 3.325ms (对重复元素效果最好)
// 尾递归快速排序: 9.854ms
```

#### 优化策略适用场景

| 优化策略 | 最适用场景 | 优点 | 缺点 |
|---------|------------|------|------|
| 随机选择基准 | 各种数据分布 | 简单易实现，有效预防最坏情况 | 增加随机数生成开销 |
| 三数取中法 | 近乎排序的数据 | 减少选择不良基准的可能性 | 实现复杂，小数组效果不明显 |
| 混合插入排序 | 包含小规模子数组 | 减少小数组的递归开销 | 需要确定合适的阈值 |
| 三路快速排序 | 大量重复元素 | 高效处理重复元素 | 实现复杂，额外比较开销 |
| 尾递归优化 | 大规模数据 | 减少递归深度，防止栈溢出 | 代码复杂度增加 |

#### 前端项目中的实践建议

1. **一般情况下，随机选择基准元素已经是一个很好的优化**，实现简单且效果显著
2. **对于前端处理的数据集，混合快速排序和插入排序**通常能提供良好的性能
3. **处理用户输入数据（可能部分排序）时**，考虑使用三数取中法
4. **表格排序等UI操作中**，若存在大量重复值（如状态、类别），三路快排更高效
5. **大型数据可视化应用**中，考虑使用尾递归优化防止栈溢出

在实际选择时，可以根据数据特性和应用场景选择最合适的优化策略，或结合多种策略。

### 3. 什么是稳定排序？在什么情况下需要使用稳定排序？

**答**：

#### 稳定排序的定义

**稳定排序**是指排序算法在排序过程中保持相等元素的相对顺序。换句话说，如果排序前数组中有两个相等的元素A和B，且A在B之前，那么排序后A仍然在B之前。

#### 稳定性示例演示

```javascript
/**
 * @description 演示排序算法的稳定性
 */
function demonstrateSortingStability() {
  // 创建一个带有附加信息的数组
  const students = [
    { id: 1, name: "Alice", score: 85 },
    { id: 2, name: "Bob", score: 90 },
    { id: 3, name: "Charlie", score: 85 }, // 与Alice分数相同
    { id: 4, name: "David", score: 75 },
    { id: 5, name: "Eve", score: 90 }      // 与Bob分数相同
  ];

  console.log("原始顺序:");
  students.forEach(s => console.log(`${s.name}: ${s.score}`));

  // 使用稳定排序（JavaScript内置sort是稳定的，从ES2019开始）
  const stableSorted = [...students].sort((a, b) => a.score - b.score);

  console.log("\n稳定排序后 (按分数):");
  stableSorted.forEach(s => console.log(`${s.name}: ${s.score}`));
  // 预期输出:
  // David: 75
  // Alice: 85 (保持在Charlie之前)
  // Charlie: 85
  // Bob: 90 (保持在Eve之前)
  // Eve: 90

  // 手动实现不稳定排序（选择排序）来展示区别
  function unstableSelectionSort(arr) {
    const result = [...arr];
    for (let i = 0; i < result.length; i++) {
      let minIndex = i;

      for (let j = i + 1; j < result.length; j++) {
        if (result[j].score < result[minIndex].score) {
          minIndex = j;
        }
      }

      if (minIndex !== i) {
        [result[i], result[minIndex]] = [result[minIndex], result[i]];
      }
    }
    return result;
  }

  const unstableSorted = unstableSelectionSort(students);

  console.log("\n不稳定排序后 (按分数):");
  unstableSorted.forEach(s => console.log(`${s.name}: ${s.score}`));
  // 可能的输出:
  // David: 75
  // Charlie: 85 (可能与Alice交换了位置)
  // Alice: 85
  // Eve: 90 (可能与Bob交换了位置)
  // Bob: 90
}
```

#### 常见的稳定排序和不稳定排序算法

**稳定的排序算法**：
- 冒泡排序 (Bubble Sort)
- 插入排序 (Insertion Sort)
- 归并排序 (Merge Sort)
- 计数排序 (Counting Sort)
- 桶排序 (Bucket Sort)
- 基数排序 (Radix Sort)

**不稳定的排序算法**：
- 选择排序 (Selection Sort)
- 堆排序 (Heap Sort)
- 快速排序 (Quick Sort)
- 希尔排序 (Shell Sort)

#### 需要使用稳定排序的场景

1. **多级排序**

当需要按照多个条件依次排序，且希望后一次排序不破坏前一次排序的结果时：

```javascript
/**
 * @description 多级排序示例
 */
function multiLevelSortingExample() {
  // 员工数据
  const employees = [
    { id: 1, name: "Zhang", department: "HR", salary: 10000 },
    { id: 2, name: "Wang", department: "IT", salary: 15000 },
    { id: 3, name: "Li", department: "IT", salary: 12000 },
    { id: 4, name: "Liu", department: "Finance", salary: 12000 },
    { id: 5, name: "Chen", department: "HR", salary: 12000 }
  ];

  console.log("原始员工数据:");
  employees.forEach(e => console.log(`${e.id}. ${e.name}, ${e.department}, ¥${e.salary}`));

  // 多级排序 - 先按部门，再按薪资（从高到低）
  // 使用稳定排序，先排序次要条件，再排序主要条件

  // 1. 按薪资排序（次要条件）
  employees.sort((a, b) => b.salary - a.salary);

  // 2. 按部门排序（主要条件）
  employees.sort((a, b) => a.department.localeCompare(b.department));

  console.log("\n按部门和薪资排序后:");
  employees.forEach(e => console.log(`${e.id}. ${e.name}, ${e.department}, ¥${e.salary}`));
  // 预期输出（部门按字母顺序，同部门内按薪资降序）:
  // 4. Liu, Finance, ¥12000
  // 5. Chen, HR, ¥10000
  // 1. Zhang, HR, ¥10000
  // 2. Wang, IT, ¥15000
  // 3. Li, IT, ¥12000

  // 如果使用不稳定排序，同薪资的员工可能顺序混乱
}
```

2. **前端表格排序**

在表格UI组件中实现多列排序时，稳定排序能提供更直观的体验：

```javascript
/**
 * @description 表格排序示例组件
 */
class SortableTable {
  constructor(data) {
    this.originalData = data;
    this.displayData = [...data];
    this.sortCriteria = []; // 保存排序列和方向
  }

  /**
   * 添加排序条件（可多级排序）
   * @param {string} column - 要排序的列名
   * @param {string} direction - 排序方向（'asc' 或 'desc'）
   * @param {boolean} resetPrevious - 是否重置之前的排序条件
   */
  sort(column, direction = 'asc', resetPrevious = false) {
    // 重置排序条件
    if (resetPrevious) {
      this.sortCriteria = [];
    }

    // 添加新的排序条件
    this.sortCriteria.push({ column, direction });

    // 重置数据
    this.displayData = [...this.originalData];

    // 应用排序条件（从后向前应用）
    for (let i = this.sortCriteria.length - 1; i >= 0; i--) {
      const { column, direction } = this.sortCriteria[i];

      this.displayData.sort((a, b) => {
        // 字符串比较
        if (typeof a[column] === 'string') {
          return direction === 'asc'
            ? a[column].localeCompare(b[column])
            : b[column].localeCompare(a[column]);
        }

        // 数值比较
        return direction === 'asc'
          ? a[column] - b[column]
          : b[column] - a[column];
      });
    }

    // 返回排序后数据（实际应用中可能是更新视图）
    return this.displayData;
  }

  // 重置排序
  resetSort() {
    this.sortCriteria = [];
    this.displayData = [...this.originalData];
    return this.displayData;
  }
}

// 表格排序示例
function tableSortingExample() {
  const products = [
    { id: 1, name: "Phone A", category: "Electronics", price: 799, stock: 25 },
    { id: 2, name: "Laptop B", category: "Electronics", price: 1299, stock: 10 },
    { id: 3, name: "Book C", category: "Books", price: 15, stock: 100 },
    { id: 4, name: "Tablet D", category: "Electronics", price: 399, stock: 30 },
    { id: 5, name: "Book E", category: "Books", price: 25, stock: 30 }
  ];

  const table = new SortableTable(products);

  // 先按类别排序
  console.log("按类别排序:");
  console.table(table.sort('category', 'asc', true));

  // 再按价格排序
  console.log("按类别和价格排序:");
  console.table(table.sort('price', 'desc'));

  // 最后按库存排序
  console.log("按类别、价格和库存排序:");
  console.table(table.sort('stock', 'desc'));

  // 预期结果：产品先按类别分组，同类别内按价格降序，同价格按库存降序
}
```

3. **电商产品列表排序**

在电商平台中，用户可能希望产品先按类别分组，再按不同条件排序：

```javascript
/**
 * @description 电商产品列表排序示例
 */
function eCommerceProductSorting() {
  const products = [
    { id: 101, name: "Gaming Laptop", category: "Electronics", price: 1299, rating: 4.5, date: "2023-01-15" },
    { id: 102, name: "Smartphone", category: "Electronics", price: 899, rating: 4.2, date: "2023-02-20" },
    { id: 103, name: "Novel", category: "Books", price: 15, rating: 4.7, date: "2023-01-10" },
    { id: 104, name: "Textbook", category: "Books", price: 50, rating: 3.8, date: "2023-03-05" },
    { id: 105, name: "Bluetooth Speaker", category: "Electronics", price: 89, rating: 4.5, date: "2023-02-15" },
    { id: 106, name: "Cookbook", category: "Books", price: 25, rating: 4.2, date: "2023-01-25" }
  ];

  // 电商界面可能有以下排序选项：
  console.log("所有产品:");
  console.table(products);

  // 1. 按类别分组，然后按评分排序
  function sortByCategoryAndRating(products) {
    return [...products]
      // 先按评分排序（次要条件）
      .sort((a, b) => b.rating - a.rating)
      // 再按类别排序（主要条件）
      .sort((a, b) => a.category.localeCompare(b.category));
  }

  console.log("\n按类别和评分排序:");
  console.table(sortByCategoryAndRating(products));

  // 2. 按类别分组，然后按价格从低到高
  function sortByCategoryAndPrice(products) {
    return [...products]
      .sort((a, b) => a.price - b.price)
      .sort((a, b) => a.category.localeCompare(b.category));
  }

  console.log("\n按类别和价格排序:");
  console.table(sortByCategoryAndPrice(products));

  // 3. 按类别分组，然后按上架时间（最新优先）
  function sortByCategoryAndDate(products) {
    return [...products]
      .sort((a, b) => new Date(b.date) - new Date(a.date))
      .sort((a, b) => a.category.localeCompare(b.category));
  }

  console.log("\n按类别和上架时间排序:");
  console.table(sortByCategoryAndDate(products));
}
```

4. **实现动画效果时保持视觉连续性**

当UI元素需要根据不同属性重新排序时，保持相同元素的原有顺序可以提供更平滑的视觉体验：

```javascript
/**
 * @description 使用稳定排序实现平滑动画过渡
 */
function animatedSortingExample() {
  // 在实际React/Vue应用中的伪代码

  // 假设有一个数据列表和排序状态
  const [items, setItems] = useState([
    { id: 1, name: 'Item A', views: 150, likes: 30 },
    { id: 2, name: 'Item B', views: 200, likes: 30 },
    { id: 3, name: 'Item C', views: 100, likes: 40 },
    // ... 更多项目
  ]);

  // 排序方法
  function sortItems(criteria) {
    // 使用稳定排序
    const sorted = [...items].sort((a, b) => {
      if (a[criteria] === b[criteria]) {
        // 相等情况下，保持原有顺序
        return 0;
      }
      return a[criteria] > b[criteria] ? 1 : -1;
    });

    setItems(sorted);
  }

  // 在组件中渲染
  return (
    <div>
      <div className="sort-buttons">
        <button onClick={() => sortItems('name')}>按名称排序</button>
        <button onClick={() => sortItems('views')}>按浏览量排序</button>
        <button onClick={() => sortItems('likes')}>按点赞数排序</button>
      </div>

      <div className="items-list">
        {items.map(item => (
          <div
            key={item.id}
            className="item"
            style={{
              // 使用CSS动画实现平滑过渡
              transition: 'all 0.5s ease'
            }}
          >
            {item.name} - 浏览: {item.views}, 点赞: {item.likes}
          </div>
        ))}
      </div>
    </div>
  );
}
```

#### 稳定排序的实现思路

要实现一个稳定的排序算法，关键在于确保排序过程中相等元素不会交换位置。以下是一些实现稳定排序的思路：

```javascript
/**
 * @description 稳定的归并排序实现
 */
function stableMergeSort(arr, compareFn) {
  if (arr.length <= 1) return arr;

  const comparator = compareFn || ((a, b) => a - b);
  const mid = Math.floor(arr.length / 2);
  const left = stableMergeSort(arr.slice(0, mid), comparator);
  const right = stableMergeSort(arr.slice(mid), comparator);

  return merge(left, right, comparator);
}

function merge(left, right, comparator) {
  const result = [];
  let leftIndex = 0;
  let rightIndex = 0;

  // 关键点：只有在右侧元素严格小于左侧元素时才选择右侧元素
  // 相等情况下优先选择左侧元素，这保证了稳定性
  while (leftIndex < left.length && rightIndex < right.length) {
    if (comparator(right[rightIndex], left[leftIndex]) < 0) {
      result.push(right[rightIndex]);
      rightIndex++;
    } else {
      // 左侧元素小于等于右侧元素时，选择左侧元素
      result.push(left[leftIndex]);
      leftIndex++;
    }
  }

  return result.concat(
    left.slice(leftIndex),
    right.slice(rightIndex)
  );
}
```

#### 在前端开发中的最佳实践

1. **表格组件实现**：
   - 使用稳定排序实现多列排序功能
   - 在排序状态中记录所有排序条件，从后向前应用

2. **多条件排序顺序**：
   - 始终从次要条件开始排序，最后排序主要条件
   - 例如，先排序价格，再排序类别，确保类别内元素按价格有序

3. **动画考虑**：
   - 在需要动画过渡的UI元素排序中，稳定排序提供更好的视觉体验

4. **浏览器兼容性**：
   - 虽然ES2019规范要求`Array.prototype.sort()`是稳定的，但在旧浏览器中可能不是
   - 如需支持旧浏览器，可以考虑自行实现稳定排序算法

5. **性能权衡**：
   - 稳定排序算法（如归并排序）可能比不稳定算法（如快速排序）慢
   - 在处理大量数据时，要权衡稳定性与性能需求
   - 对于小到中等规模数据，稳定性通常比性能更重要

// ... existing code ...