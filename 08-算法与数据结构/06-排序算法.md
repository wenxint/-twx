# 排序算法

## 基本概念

排序算法是将一组特定的数据按照某种顺序进行排列的算法。排序算法在计算机科学中非常重要，是许多其他算法的基础。

### 排序算法的分类

1. **比较类排序**：通过比较来决定元素间的相对次序，时间复杂度不能突破O(nlogn)
   - 交换排序（冒泡排序、快速排序）
   - 插入排序（简单插入排序、希尔排序）
   - 选择排序（简单选择排序、堆排序）
   - 归并排序

2. **非比较类排序**：不通过比较来决定元素间的相对次序，可以突破O(nlogn)的限制
   - 计数排序
   - 桶排序
   - 基数排序

### 排序算法的评价指标

- **时间复杂度**：算法执行所需的时间
- **空间复杂度**：算法执行所需的额外空间
- **稳定性**：相等的元素在排序后是否保持原有的相对位置

## 常见排序算法

### 1. 冒泡排序

冒泡排序是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就交换它们，直到没有再需要交换的元素为止。

```javascript
function bubbleSort(arr) {
  const len = arr.length;

  for (let i = 0; i < len; i++) {
    // 标记当前轮次是否发生交换
    let swapped = false;

    for (let j = 0; j < len - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        // 交换元素
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        swapped = true;
      }
    }

    // 如果没有发生交换，说明数组已经有序，提前退出
    if (!swapped) break;
  }

  return arr;
}
```

**时间复杂度**：
- 最好情况：O(n)，当数组已经有序时
- 最坏情况：O(n²)，当数组逆序时
- 平均情况：O(n²)

**空间复杂度**：O(1)

**稳定性**：稳定

### 2. 选择排序

选择排序是一种简单直观的排序算法，它的工作原理是每次从待排序的数据中选出最小（或最大）的元素，放在已排序序列的末尾。

```javascript
function selectionSort(arr) {
  const len = arr.length;

  for (let i = 0; i < len - 1; i++) {
    // 假设当前位置的元素是最小的
    let minIndex = i;

    // 在未排序的部分中寻找最小元素
    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }

    // 如果找到了更小的元素，交换位置
    if (minIndex !== i) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
    }
  }

  return arr;
}
```

**时间复杂度**：
- 最好情况：O(n²)
- 最坏情况：O(n²)
- 平均情况：O(n²)

**空间复杂度**：O(1)

**稳定性**：不稳定

### 3. 插入排序

插入排序是一种简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

```javascript
function insertionSort(arr) {
  const len = arr.length;

  for (let i = 1; i < len; i++) {
    // 当前要插入的元素
    const current = arr[i];
    let j = i - 1;

    // 寻找插入位置
    while (j >= 0 && arr[j] > current) {
      arr[j + 1] = arr[j];
      j--;
    }

    // 插入元素
    arr[j + 1] = current;
  }

  return arr;
}
```

**时间复杂度**：
- 最好情况：O(n)，当数组已经有序时
- 最坏情况：O(n²)，当数组逆序时
- 平均情况：O(n²)

**空间复杂度**：O(1)

**稳定性**：稳定

### 4. 希尔排序

希尔排序是插入排序的一种改进版本，它通过将整个数组分为多个子数组分别进行插入排序，逐步缩小增量，最终完成整个数组的排序。

```javascript
function shellSort(arr) {
  const len = arr.length;
  let gap = Math.floor(len / 2);

  while (gap > 0) {
    for (let i = gap; i < len; i++) {
      const temp = arr[i];
      let j = i;

      while (j >= gap && arr[j - gap] > temp) {
        arr[j] = arr[j - gap];
        j -= gap;
      }

      arr[j] = temp;
    }

    gap = Math.floor(gap / 2);
  }

  return arr;
}
```

**时间复杂度**：
- 最好情况：O(n log n)
- 最坏情况：O(n²)，取决于间隔序列
- 平均情况：O(n log² n)

**空间复杂度**：O(1)

**稳定性**：不稳定

### 5. 归并排序

归并排序是一种分治算法，它将数组分成两半，递归地排序两半，然后将结果合并起来。

```javascript
function mergeSort(arr) {
  if (arr.length <= 1) return arr;

  // 分割数组
  const mid = Math.floor(arr.length / 2);
  const left = arr.slice(0, mid);
  const right = arr.slice(mid);

  // 递归排序两半
  return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
  const result = [];
  let leftIndex = 0;
  let rightIndex = 0;

  // 比较两个数组的元素，将较小的元素加入结果数组
  while (leftIndex < left.length && rightIndex < right.length) {
    if (left[leftIndex] < right[rightIndex]) {
      result.push(left[leftIndex]);
      leftIndex++;
    } else {
      result.push(right[rightIndex]);
      rightIndex++;
    }
  }

  // 将剩余元素加入结果数组
  return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));
}
```

**时间复杂度**：
- 最好情况：O(n log n)
- 最坏情况：O(n log n)
- 平均情况：O(n log n)

**空间复杂度**：O(n)

**稳定性**：稳定

### 6. 快速排序

快速排序是一种分治算法，它选择一个元素作为基准，将数组分为两个子数组，小于基准的元素和大于基准的元素，然后递归地排序两个子数组。

```javascript
function quickSort(arr, left = 0, right = arr.length - 1) {
  if (left < right) {
    const pivotIndex = partition(arr, left, right);
    quickSort(arr, left, pivotIndex - 1);
    quickSort(arr, pivotIndex + 1, right);
  }

  return arr;
}

function partition(arr, left, right) {
  // 选择最右边的元素作为基准
  const pivot = arr[right];
  let i = left - 1;

  for (let j = left; j < right; j++) {
    if (arr[j] <= pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];
  return i + 1;
}
```

**时间复杂度**：
- 最好情况：O(n log n)，每次都能均匀分割
- 最坏情况：O(n²)，当数组已经有序或逆序时
- 平均情况：O(n log n)

**空间复杂度**：O(log n)，递归调用栈的深度

**稳定性**：不稳定

### 7. 堆排序

堆排序是一种基于二叉堆的排序算法，它首先构建一个最大堆（或最小堆），然后将堆顶元素与末尾元素交换，调整堆结构，重复此过程。

```javascript
function heapSort(arr) {
  const len = arr.length;

  // 构建最大堆
  for (let i = Math.floor(len / 2) - 1; i >= 0; i--) {
    heapify(arr, len, i);
  }

  // 一个个交换元素
  for (let i = len - 1; i > 0; i--) {
    [arr[0], arr[i]] = [arr[i], arr[0]];
    heapify(arr, i, 0);
  }

  return arr;
}

function heapify(arr, n, i) {
  let largest = i;
  const left = 2 * i + 1;
  const right = 2 * i + 2;

  if (left < n && arr[left] > arr[largest]) {
    largest = left;
  }

  if (right < n && arr[right] > arr[largest]) {
    largest = right;
  }

  if (largest !== i) {
    [arr[i], arr[largest]] = [arr[largest], arr[i]];
    heapify(arr, n, largest);
  }
}
```

**时间复杂度**：
- 最好情况：O(n log n)
- 最坏情况：O(n log n)
- 平均情况：O(n log n)

**空间复杂度**：O(1)

**稳定性**：不稳定

### 8. 计数排序

计数排序是一种非比较排序算法，它使用一个额外的数组来存储元素的出现次数，然后根据这个计数数组重建排序后的数组。

```javascript
function countingSort(arr) {
  if (arr.length <= 1) return arr;

  // 找出数组中的最大值
  const max = Math.max(...arr);

  // 创建计数数组
  const counts = new Array(max + 1).fill(0);

  // 统计每个元素出现的次数
  for (let i = 0; i < arr.length; i++) {
    counts[arr[i]]++;
  }

  // 根据计数数组重建排序后的数组
  const result = [];
  for (let i = 0; i <= max; i++) {
    while (counts[i] > 0) {
      result.push(i);
      counts[i]--;
    }
  }

  return result;
}
```

**时间复杂度**：O(n + k)，其中k是数组中的最大值

**空间复杂度**：O(k)

**稳定性**：稳定

### 9. 桶排序

桶排序是将数据分到有限数量的桶里，每个桶再分别排序（可能使用别的排序算法或递归使用桶排序）。

```javascript
function bucketSort(arr, bucketSize = 5) {
  if (arr.length <= 1) return arr;

  // 找出数组中的最大值和最小值
  const min = Math.min(...arr);
  const max = Math.max(...arr);

  // 计算桶的数量
  const bucketCount = Math.floor((max - min) / bucketSize) + 1;
  const buckets = new Array(bucketCount);
  for (let i = 0; i < bucketCount; i++) {
    buckets[i] = [];
  }

  // 将元素分配到桶中
  for (let i = 0; i < arr.length; i++) {
    const bucketIndex = Math.floor((arr[i] - min) / bucketSize);
    buckets[bucketIndex].push(arr[i]);
  }

  // 对每个桶进行排序，并合并结果
  const result = [];
  for (let i = 0; i < bucketCount; i++) {
    // 使用插入排序对每个桶进行排序
    insertionSort(buckets[i]);
    result.push(...buckets[i]);
  }

  return result;
}
```

**时间复杂度**：
- 平均情况：O(n + k)，其中k是桶的数量
- 最坏情况：O(n²)，当所有元素都被分到同一个桶中时

**空间复杂度**：O(n + k)

**稳定性**：取决于桶内排序算法的稳定性

### 10. 基数排序

基数排序是一种非比较型整数排序算法，它按照位数来排序，从最低位开始，依次按位数进行排序，直到最高位。

```javascript
function radixSort(arr) {
  if (arr.length <= 1) return arr;

  // 找出最大值，确定最大位数
  const max = Math.max(...arr);
  let maxDigits = 0;
  while (max / Math.pow(10, maxDigits) >= 1) {
    maxDigits++;
  }

  // 按照每一位进行计数排序
  for (let digit = 0; digit < maxDigits; digit++) {
    // 创建10个桶（对应0-9）
    const buckets = Array.from({ length: 10 }, () => []);

    // 将元素分配到桶中
    for (let i = 0; i < arr.length; i++) {
      const digitValue = Math.floor(arr[i] / Math.pow(10, digit)) % 10;
      buckets[digitValue].push(arr[i]);
    }

    // 合并桶中的元素
    arr = [].concat(...buckets);
  }

  return arr;
}
```

**时间复杂度**：O(d * (n + k))，其中d是最大位数，k是基数（这里是10）

**空间复杂度**：O(n + k)

**稳定性**：稳定

## 排序算法的比较

| 排序算法 | 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 | 稳定性 |
|---------|--------------|---------|---------|-----------|-------|
| 冒泡排序 | O(n²) | O(n) | O(n²) | O(1) | 稳定 |
| 选择排序 | O(n²) | O(n²) | O(n²) | O(1) | 不稳定 |
| 插入排序 | O(n²) | O(n) | O(n²) | O(1) | 稳定 |
| 希尔排序 | O(n log² n) | O(n log n) | O(n²) | O(1) | 不稳定 |
| 归并排序 | O(n log n) | O(n log n) | O(n log n) | O(n) | 稳定 |
| 快速排序 | O(n log n) | O(n log n) | O(n²) | O(log n) | 不稳定 |
| 堆排序 | O(n log n) | O(n log n) | O(n log n) | O(1) | 不稳定 |
| 计数排序 | O(n + k) | O(n + k) | O(n + k) | O(k) | 稳定 |
| 桶排序 | O(n + k) | O(n + k) | O(n²) | O(n + k) | 稳定* |
| 基数排序 | O(d * (n + k)) | O(d * (n + k)) | O(d * (n + k)) | O(n + k) | 稳定 |

*注：桶排序的稳定性取决于桶内排序算法的稳定性

## 前端应用场景

1. **数据可视化**：对数据进行排序后再展示，如表格、图表等
2. **搜索结果排序**：根据相关性、时间、价格等对搜索结果进行排序
3. **文件列表排序**：根据文件名、大小、修改日期等对文件列表进行排序
4. **任务优先级排序**：根据优先级对任务队列进行排序
5. **虚拟列表优化**：对大量数据进行排序后再渲染
6. **自动补全功能**：对补全结果按相关性排序
7. **前端路由匹配**：对路由规则按特定顺序排序以确保正确匹配

## 排序算法的选择

在实际应用中，选择合适的排序算法需要考虑以下因素：

1. **数据规模**：对于小规模数据，简单算法如插入排序可能更高效；对于大规模数据，应选择时间复杂度为O(n log n)的算法
2. **数据特征**：数据是否接近有序、是否有大量重复元素等
3. **稳定性要求**：是否需要保持相等元素的相对顺序
4. **空间限制**：是否有额外空间使用的限制
5. **原地排序需求**：是否需要在原数组上进行排序

## JavaScript内置排序

JavaScript提供了内置的`Array.prototype.sort()`方法，它接受一个可选的比较函数作为参数：

```javascript
// 默认按字典序排序
const fruits = ['banana', 'apple', 'orange', 'grape'];
fruits.sort(); // ['apple', 'banana', 'grape', 'orange']

// 数字排序需要提供比较函数
const numbers = [10, 5, 8, 2, 1];
numbers.sort((a, b) => a - b); // [1, 2, 5, 8, 10]

// 对象排序
const people = [
  { name: 'Alice', age: 25 },
  { name: 'Bob', age: 30 },
  { name: 'Charlie', age: 20 }
];

// 按年龄排序
people.sort((a, b) => a.age - b.age);

// 按名字排序
people.sort((a, b) => a.name.localeCompare(b.name));
```

不同浏览器实现的排序算法可能不同，但大多数现代浏览器使用的是一种混合排序算法，如TimSort（归并排序和插入排序的混合）或IntroSort（快速排序、堆排序和插入排序的混合）。

## 面试常见问题

1. 快速排序和归并排序的区别是什么？各自的优缺点？
2. 如何优化快速排序以避免最坏情况？
3. 为什么快速排序在实际应用中通常比其他O(n log n)的排序算法更快？
4. 什么是稳定排序？在什么情况下需要使用稳定排序？
5. 如何实现一个时间复杂度为O(n)的排序算法？（提示：计数排序、桶排序、基数排序）
6. JavaScript的`Array.prototype.sort()`方法使用的是什么排序算法？
7. 如何对链表进行排序？
8. 如何对几乎已经排序的数组进行排序？哪种算法最适合？
9. 如何对大文件进行外部排序？
10. 如何在前端实现一个高效的表格排序功能？

## 学习资源

- [JavaScript数据结构 - 排序算法](https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting) - GitHub上的JS实现
- [排序算法可视化](https://visualgo.net/en/sorting) - 排序算法的可视化演示
- [LeetCode排序题集](https://leetcode.com/tag/sorting/) - 相关算法练习
- [前端进阶之道 - 排序算法](https://juejin.cn/post/6844903814134104078) - 前端视角的排序算法讲解
- [JavaScript排序算法详解](https://www.freecodecamp.org/news/sorting-algorithms-explained/) - FreeCodeCamp上的教程
