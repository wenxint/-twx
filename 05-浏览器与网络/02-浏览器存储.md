# 浏览器存储

## 前言

浏览器存储是前端开发中不可或缺的一部分，它允许网页应用在客户端保存数据，提高用户体验并减轻服务器负担。本文将详细介绍各种浏览器存储机制，包括它们的特点、适用场景、API使用方法以及注意事项。

## 目录

- [Cookie](#cookie)
- [Web Storage](#web-storage)
  - [localStorage](#localstorage)
  - [sessionStorage](#sessionstorage)
- [IndexedDB](#indexeddb)
- [Web SQL Database](#web-sql-database)
- [Cache API](#cache-api)
- [Application Cache (已废弃)](#application-cache-已废弃)
- [File System API](#file-system-api)
- [存储方案对比](#存储方案对比)
- [最佳实践](#最佳实践)
- [面试常见问题](#面试常见问题)

## Cookie

Cookie 是最早的浏览器存储方案，至今仍被广泛使用。

### 基本概念

Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。

### 特点

- **容量限制**：单个 Cookie 容量不超过 4KB
- **数量限制**：每个域名下 Cookie 数量有限（一般为 20-50 个）
- **自动附加**：HTTP 请求会自动附加域名相关的 Cookie
- **过期时间**：可设置过期时间或会话结束后过期
- **作用域**：可限定为特定域名和路径

### 创建和读取 Cookie

```javascript
// 设置 Cookie
document.cookie = "username=John; expires=Thu, 18 Dec 2023 12:00:00 UTC; path=/";

// 读取 Cookie
const cookies = document.cookie;
console.log(cookies); // 格式如: "username=John; theme=dark"

// 解析 Cookie
function getCookie(name) {
  const cookieArr = document.cookie.split(';');
  for (let i = 0; i < cookieArr.length; i++) {
    const cookiePair = cookieArr[i].split('=');
    const cookieName = cookiePair[0].trim();
    if (cookieName === name) {
      return decodeURIComponent(cookiePair[1]);
    }
  }
  return null;
}

// 删除 Cookie（通过设置过期时间为过去时间）
document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
```

### Cookie 属性

| 属性       | 描述                                                     |
|------------|----------------------------------------------------------|
| `name=value` | Cookie 的名称和值                                       |
| `expires`    | Cookie 的过期时间（GMT/UTC 格式）                       |
| `max-age`    | Cookie 生存的秒数                                       |
| `path`       | Cookie 的可用路径（默认为当前文档位置的路径）         |
| `domain`     | Cookie 的可用域（默认为创建 Cookie 的页面域名）       |
| `secure`     | 是否只在 HTTPS 连接中传输                               |
| `HttpOnly`   | 是否禁止 JavaScript 访问                                |
| `SameSite`   | 控制跨站请求时发送（None/Strict/Lax）                   |

### 适用场景

- 会话管理（登录状态、购物车等）
- 用户偏好设置（主题、字体大小等）
- 追踪分析用户行为

### 注意事项

- Cookie 会在每次 HTTP 请求中发送，增加网络开销
- 存在安全风险，如 CSRF、XSS 攻击
- 现代浏览器对第三方 Cookie 限制日益严格
- 不适合存储大量数据

## Web Storage

Web Storage 是 HTML5 引入的客户端存储技术，分为 localStorage 和 sessionStorage。

### localStorage

永久性存储，除非手动删除，否则数据将一直保存。

#### 特点

- **容量**：一般为 5-10MB（各浏览器有差异）
- **作用域**：同源策略限制，仅同一域名下可访问
- **生命周期**：永久，除非手动清除
- **存储方式**：键值对形式，仅支持字符串

#### API 使用

```javascript
// 存储数据
localStorage.setItem('username', 'John');

// 读取数据
const username = localStorage.getItem('username');
console.log(username); // "John"

// 删除特定数据
localStorage.removeItem('username');

// 清空所有数据
localStorage.clear();

// 获取所有键名
for (let i = 0; i < localStorage.length; i++) {
  const key = localStorage.key(i);
  console.log(`${key}: ${localStorage.getItem(key)}`);
}

// 存储对象（需转换为字符串）
const user = { name: 'John', age: 30 };
localStorage.setItem('user', JSON.stringify(user));

// 读取对象
const storedUser = JSON.parse(localStorage.getItem('user'));
console.log(storedUser); // { name: 'John', age: 30 }
```

#### 适用场景

- 网站主题、字体等设置
- 购物车信息
- 表单数据自动保存
- 文章阅读位置记录

### sessionStorage

临时性存储，仅在会话期间有效，关闭页面或浏览器后数据自动清除。

#### 特点

- **容量**：一般为 5-10MB（与 localStorage 相同）
- **作用域**：同源且同一浏览器标签页
- **生命周期**：会话级别，关闭标签页后清除
- **存储方式**：键值对形式，仅支持字符串

#### API 使用

与 localStorage 完全相同。

```javascript
// 存储数据
sessionStorage.setItem('tempData', 'Some temporary data');

// 读取数据
const data = sessionStorage.getItem('tempData');

// 删除数据
sessionStorage.removeItem('tempData');

// 清空所有数据
sessionStorage.clear();
```

#### 适用场景

- 单页应用的表单临时数据
- 限制在单个会话内的配置
- 敏感信息临时存储

### 存储事件监听

当 localStorage 或 sessionStorage 发生变化时，可以通过 storage 事件来捕获变化。

```javascript
// 监听存储变化（在其他窗口/标签页中修改 localStorage 时触发）
window.addEventListener('storage', (event) => {
  console.log('Storage changed:', {
    key: event.key,
    oldValue: event.oldValue,
    newValue: event.newValue,
    url: event.url,
    storageArea: event.storageArea
  });
});
```

**注意**：storage 事件只在其他页面修改存储时触发，当前页面修改不会触发。

## IndexedDB

IndexedDB 是一个事务型数据库系统，允许存储大量结构化数据，包括文件和二进制对象（Blob）。

### 特点

- **容量**：通常可用空间为设备可用磁盘空间的 50%（远大于 Web Storage）
- **存储类型**：支持任何类型的数据（包括文件、二进制对象）
- **事务型**：提供完整的事务支持，保证数据一致性
- **索引**：支持索引，可高效检索数据
- **异步 API**：使用基于 Promise 或回调的异步 API，不会阻塞主线程

### 基本用法

```javascript
// 打开/创建数据库
const dbRequest = indexedDB.open('MyDatabase', 1);

// 处理数据库升级事件（首次创建或版本升级时触发）
dbRequest.onupgradeneeded = (event) => {
  const db = event.target.result;

  // 创建对象仓库（相当于表）
  const store = db.createObjectStore('users', { keyPath: 'id' });

  // 创建索引
  store.createIndex('name', 'name', { unique: false });
  store.createIndex('email', 'email', { unique: true });
};

// 数据库打开成功
dbRequest.onsuccess = (event) => {
  const db = event.target.result;

  // 新增数据（在事务中进行）
  const transaction = db.transaction(['users'], 'readwrite');
  const store = transaction.objectStore('users');

  store.add({
    id: 1,
    name: 'John Doe',
    email: 'john@example.com',
    age: 30
  });

  // 事务完成
  transaction.oncomplete = () => {
    console.log('Transaction completed');
  };

  // 事务失败
  transaction.onerror = (event) => {
    console.error('Transaction error:', event.target.error);
  };
};

// 数据库打开失败
dbRequest.onerror = (event) => {
  console.error('Database error:', event.target.error);
};
```

### 数据查询

```javascript
// 读取数据
function getUserById(id) {
  return new Promise((resolve, reject) => {
    const dbRequest = indexedDB.open('MyDatabase', 1);

    dbRequest.onsuccess = (event) => {
      const db = event.target.result;
      const transaction = db.transaction(['users'], 'readonly');
      const store = transaction.objectStore('users');
      const request = store.get(id);

      request.onsuccess = () => {
        resolve(request.result);
      };

      request.onerror = (event) => {
        reject(event.target.error);
      };
    };

    dbRequest.onerror = (event) => {
      reject(event.target.error);
    };
  });
}

// 使用索引查询
function getUsersByName(name) {
  return new Promise((resolve, reject) => {
    const dbRequest = indexedDB.open('MyDatabase', 1);

    dbRequest.onsuccess = (event) => {
      const db = event.target.result;
      const transaction = db.transaction(['users'], 'readonly');
      const store = transaction.objectStore('users');
      const index = store.index('name');
      const request = index.getAll(name);

      request.onsuccess = () => {
        resolve(request.result);
      };

      request.onerror = (event) => {
        reject(event.target.error);
      };
    };

    dbRequest.onerror = (event) => {
      reject(event.target.error);
    };
  });
}
```

### 数据更新和删除

```javascript
// 更新数据
function updateUser(user) {
  return new Promise((resolve, reject) => {
    const dbRequest = indexedDB.open('MyDatabase', 1);

    dbRequest.onsuccess = (event) => {
      const db = event.target.result;
      const transaction = db.transaction(['users'], 'readwrite');
      const store = transaction.objectStore('users');
      const request = store.put(user); // 更新现有记录或添加新记录

      request.onsuccess = () => {
        resolve();
      };

      request.onerror = (event) => {
        reject(event.target.error);
      };
    };
  });
}

// 删除数据
function deleteUser(id) {
  return new Promise((resolve, reject) => {
    const dbRequest = indexedDB.open('MyDatabase', 1);

    dbRequest.onsuccess = (event) => {
      const db = event.target.result;
      const transaction = db.transaction(['users'], 'readwrite');
      const store = transaction.objectStore('users');
      const request = store.delete(id);

      request.onsuccess = () => {
        resolve();
      };

      request.onerror = (event) => {
        reject(event.target.error);
      };
    };
  });
}
```

### 适用场景

- 离线应用和 PWA（Progressive Web Apps）
- 大数据集的存储和查询
- 文件和媒体内容缓存
- 需要复杂查询的客户端数据

### 注意事项

- API 较为复杂，学习曲线陡峭
- 异步 API 需要正确处理回调或 Promise
- 不同浏览器实现可能有细微差异
- 需要处理版本升级

## Web SQL Database

Web SQL Database 提供了一个类似 SQL 的结构化数据库环境。

**注意**：Web SQL Database 已被废弃，W3C 不再维护此规范。新项目应使用 IndexedDB。

### 基本用法

```javascript
// 打开数据库
const db = openDatabase('mydb', '1.0', 'My Database', 2 * 1024 * 1024);

// 执行 SQL
db.transaction(function (tx) {
  // 创建表
  tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id INTEGER PRIMARY KEY, log TEXT, timestamp DATETIME)');

  // 插入数据
  tx.executeSql('INSERT INTO LOGS (log, timestamp) VALUES (?, ?)', ['Entry 1', new Date().toString()]);

  // 查询数据
  tx.executeSql('SELECT * FROM LOGS', [], function (tx, results) {
    const len = results.rows.length;
    for (let i = 0; i < len; i++) {
      console.log(results.rows.item(i).log);
    }
  });
});
```

### 特点

- 基于 SQL 的 API，熟悉 SQL 的开发者容易上手
- 支持事务
- 通常限制为 5MB 左右
- 不被所有现代浏览器支持（如 Firefox 和新版 Edge）

## Cache API

Cache API 是 Service Worker API 的一部分，用于缓存网络请求和响应，是 PWA 的核心组件之一。

### 基本用法

```javascript
// 打开缓存
caches.open('my-cache-v1')
  .then(cache => {
    // 缓存资源
    return cache.addAll([
      '/index.html',
      '/styles/main.css',
      '/scripts/main.js',
      '/images/logo.png'
    ]);
  })
  .then(() => {
    console.log('Resources cached successfully');
  })
  .catch(error => {
    console.error('Caching failed:', error);
  });

// 检索缓存资源
caches.match('/index.html')
  .then(response => {
    if (response) {
      return response;
    }
    return fetch('/index.html');
  })
  .then(response => {
    console.log('Resource fetched:', response);
  });
```

### 特点

- 专为离线访问和资源缓存设计
- 与 Service Worker 结合使用效果最佳
- 支持复杂的缓存策略（如 cache-first, network-first）
- 适用于 PWA 开发

## Application Cache (已废弃)

Application Cache（AppCache）允许开发者指定要缓存的文件，以便在离线时使用。

**注意**：此 API 已被废弃，新项目应使用 Service Worker 和 Cache API。

### 使用方法

```html
<!DOCTYPE html>
<html manifest="example.appcache">
<head>
  <title>AppCache Example</title>
</head>
<body>
  <!-- 内容 -->
</body>
</html>
```

```
# example.appcache 文件
CACHE MANIFEST
# version 1.0

CACHE:
index.html
styles.css
script.js
logo.png

NETWORK:
*

FALLBACK:
/ offline.html
```

## File System API

File System Access API 允许网页应用直接访问用户文件系统中的文件和目录。

**注意**：此 API 相对较新，浏览器支持有限。

### 基本用法

```javascript
// 选择要打开的文件
async function getFile() {
  try {
    // 显示文件选择器
    const [fileHandle] = await window.showOpenFilePicker();
    // 获取文件
    const file = await fileHandle.getFile();
    // 读取文件内容
    const contents = await file.text();
    console.log(contents);
  } catch (err) {
    console.error(err);
  }
}

// 保存文件
async function saveFile() {
  try {
    // 显示文件保存对话框
    const fileHandle = await window.showSaveFilePicker({
      types: [{
        description: 'Text Files',
        accept: { 'text/plain': ['.txt'] }
      }]
    });
    // 创建可写流
    const writable = await fileHandle.createWritable();
    // 写入内容
    await writable.write('Hello, world!');
    // 关闭流
    await writable.close();
  } catch (err) {
    console.error(err);
  }
}
```

### 特点

- 允许读写用户文件系统中的文件
- 需要用户显式授权
- 主要用于创建类桌面应用的 Web 应用
- 浏览器支持有限

## 存储方案对比

| 特性 | Cookie | localStorage | sessionStorage | IndexedDB | Web SQL | Cache API |
|------|--------|--------------|----------------|-----------|---------|-----------|
| 容量 | ~4KB | 5-10MB | 5-10MB | 50%设备存储 | ~5MB | 取决于设备 |
| 生命周期 | 可设置 | 永久 | 会话期间 | 永久 | 永久 | 永久 |
| 作用域 | 域名+路径 | 域名 | 域名+标签页 | 域名 | 域名 | 域名 |
| 数据类型 | 字符串 | 字符串 | 字符串 | 任何类型 | 结构化数据 | Response 对象 |
| 同步/异步 | 同步 | 同步 | 同步 | 异步 | 异步 | 异步 |
| 索引支持 | 无 | 无 | 无 | 支持 | 支持 | 无 |
| HTTP请求 | 自动发送 | 不发送 | 不发送 | 不发送 | 不发送 | 不发送 |
| 主要用途 | 会话管理 | 持久化设置 | 临时存储 | 大量结构化数据 | 结构化数据(已废弃) | 资源缓存 |
| 复杂度 | 低 | 低 | 低 | 中-高 | 中 | 中 |
| 浏览器支持 | 全部 | 全部(IE8+) | 全部(IE8+) | 全部现代浏览器 | 部分 | 现代浏览器 |

## 最佳实践

### 选择合适的存储方式

- **小数据量、需要随请求发送**：Cookie
- **中等数据量、设置类信息**：localStorage
- **会话级别数据**：sessionStorage
- **大量结构化数据**：IndexedDB
- **资源缓存**：Cache API

### 安全考虑

1. **避免存储敏感信息**
   客户端存储不适合保存密码、信用卡等敏感信息。

2. **设置 Cookie 安全属性**
   ```javascript
   document.cookie = "sensitive=value; Secure; HttpOnly; SameSite=Strict";
   ```

3. **防止 XSS 攻击**
   在存储用户生成的内容前进行严格过滤。

4. **数据验证**
   从存储中读取数据后，在使用前进行验证。

### 性能考虑

1. **限制 Cookie 大小和数量**
   减少每次请求的额外开销。

2. **批量操作 IndexedDB**
   使用事务批量处理数据操作。

3. **使用合适的序列化方式**
   选择高效的 JSON 序列化/反序列化方法。

4. **避免频繁存储操作**
   实现节流或防抖机制，减少写入操作。

### 使用 Wrapper 库

对于复杂存储需求，可以考虑使用以下库：

- **localForage**：提供简单异步 API，在后台使用 IndexedDB、WebSQL 或 localStorage
- **Dexie.js**：IndexedDB 的轻量级封装
- **PouchDB**：支持离线同步的客户端数据库

```javascript
// localForage 使用示例
import localforage from 'localforage';

// 配置
localforage.config({
  name: 'myApp',
  storeName: 'myStore'
});

// 存储数据
localforage.setItem('user', { id: 1, name: 'John' })
  .then(() => console.log('Stored user'))
  .catch(err => console.error('Error storing user', err));

// 读取数据
localforage.getItem('user')
  .then(value => console.log('Retrieved user:', value))
  .catch(err => console.error('Error retrieving user', err));
```

## 面试常见问题

### 1. localStorage 和 sessionStorage 的区别？

**答案**：主要区别在于数据的生命周期和作用域。localStorage 存储的数据没有过期时间，除非手动删除，否则永久保存；而 sessionStorage 中的数据仅在当前会话（浏览器标签页）有效，关闭标签页后数据会被清除。另外，localStorage 在同源的所有标签页和窗口之间共享，而 sessionStorage 仅在创建它的标签页中可用。

### 2. Cookie、localStorage 和 IndexedDB 各适用于什么场景？

**答案**：
- **Cookie** 适用于需要在客户端和服务器之间传递的小量数据，如身份验证令牌、会话标识等。
- **localStorage** 适用于需要长期保存且不经常变化的中等大小数据，如用户偏好设置、主题选择等。
- **IndexedDB** 适用于存储大量结构化数据，支持高级查询和全文索引，适合离线应用、大型数据集和需要复杂查询的场景。

### 3. 如何在 localStorage 中存储对象？

**答案**：localStorage 只能存储字符串，因此需要使用 JSON.stringify() 将对象转换为字符串，读取时再用 JSON.parse() 转回对象：

```javascript
// 存储对象
const user = { name: 'John', age: 30 };
localStorage.setItem('user', JSON.stringify(user));

// 读取对象
const storedUser = JSON.parse(localStorage.getItem('user'));
```

### 4. Cookie 的 SameSite 属性有什么作用？

**答案**：SameSite 属性用于控制是否发送 Cookie 到第三方站点，有三个可能的值：
- **Strict**：仅在同一站点请求时发送 Cookie
- **Lax**：在同一站点请求和从其他站点导航到本站点时发送 Cookie（现代浏览器的默认值）
- **None**：允许跨站点发送 Cookie，但必须同时设置 Secure 属性（即只在 HTTPS 连接中发送）

这主要用于防止 CSRF（跨站请求伪造）攻击。

### 5. 如何处理浏览器存储的限制和容量问题？

**答案**：处理存储限制的策略包括：
1. 实现数据过期机制，定期清理旧数据
2. 使用 LRU（最近最少使用）算法管理缓存
3. 对大型数据进行分片存储
4. 在达到存储限制前，提示用户清理数据
5. 监听存储事件，处理存储失败的情况：

```javascript
try {
  // 尝试存储大量数据
  localStorage.setItem('bigData', JSON.stringify(largeObject));
} catch (e) {
  if (e.name === 'QuotaExceededError') {
    // 清理不必要的数据
    localStorage.removeItem('cacheData');
    // 重试
    localStorage.setItem('bigData', JSON.stringify(largeObject));
  }
}
```

### 6. Service Worker 和 Cache API 如何配合实现离线应用？

**答案**：Service Worker 作为网页和网络之间的代理，可以拦截网络请求并使用 Cache API 缓存响应。基本流程是：
1. 注册 Service Worker
2. 在安装事件中预缓存关键资源
3. 在 fetch 事件中实现缓存策略（如 Cache First、Network First 等）
4. 定期更新缓存

这样即使在离线状态下，应用也能正常工作，是 PWA（渐进式 Web 应用）的核心技术。

```javascript
// 注册 Service Worker
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js')
    .then(reg => console.log('SW registered:', reg))
    .catch(err => console.error('SW registration failed:', err));
}

// Service Worker 代码 (sw.js)
const CACHE_NAME = 'my-site-cache-v1';
const urlsToCache = [
  '/',
  '/styles/main.css',
  '/scripts/main.js'
];

// 安装并缓存
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  );
});

// 网络请求拦截
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        if (response) {
          return response; // 返回缓存的响应
        }
        return fetch(event.request) // 发起网络请求
          .then(response => {
            // 缓存新请求的响应
            if (response && response.status === 200) {
              const responseToCache = response.clone();
              caches.open(CACHE_NAME)
                .then(cache => {
                  cache.put(event.request, responseToCache);
                });
            }
            return response;
          });
      })
  );
});
```

---

浏览器存储技术构成了现代 Web 应用的重要基础，选择合适的存储方案对于构建高性能、响应迅速的 Web 应用至关重要。通过了解各种技术的特点、适用场景和最佳实践，开发者可以更好地设计和实现前端存储策略。