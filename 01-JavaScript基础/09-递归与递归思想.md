# 递归与递归思想

> 递归是一种强大的编程技术，指函数在执行过程中直接或间接地调用自身。掌握递归思想对解决复杂问题、处理树形结构和多维数据有着至关重要的作用。

## 概念介绍

递归是一种将复杂问题分解为更简单的相同类型子问题的方法。递归函数通过调用自身来解决这些子问题，直到达到基本情况（也称为"边界条件"或"终止条件"），此时函数可以不再调用自身而直接返回结果。

递归思想的核心要素：
1. **基本情况（Base Case）**：递归终止的条件，防止无限递归
2. **递归情况（Recursive Case）**：将问题分解为更小的相同问题
3. **收敛性**：确保每次递归调用都在向基本情况靠近

## 基本语法

JavaScript中的递归函数通常遵循以下结构：

```javascript
/**
 * @description 递归函数基本结构
 * @param {any} input - 输入参数
 * @return {any} 递归处理结果
 */
function recursiveFunction(input) {
  // 1. 基本情况（终止条件）
  if (终止条件) {
    return 基本情况的结果;
  }

  // 2. 处理当前层级的逻辑
  // ...处理代码...

  // 3. 递归调用，通常使用更小/更简单的输入
  return recursiveFunction(更小的问题);
}
```

## 核心特性

### 1. 递归与迭代的比较

递归和迭代（循环）通常可以互相转换，但各有优缺点：

```javascript
/**
 * @description 计算阶乘的递归实现
 * @param {number} n - 需要计算阶乘的非负整数
 * @return {number} n的阶乘
 */
function factorialRecursive(n) {
  // 基本情况
  if (n === 0 || n === 1) {
    return 1;
  }
  // 递归情况
  return n * factorialRecursive(n - 1);
}

/**
 * @description 计算阶乘的迭代实现
 * @param {number} n - 需要计算阶乘的非负整数
 * @return {number} n的阶乘
 */
function factorialIterative(n) {
  let result = 1;
  for (let i = 2; i <= n; i++) {
    result *= i;
  }
  return result;
}

// 测试
console.log(factorialRecursive(5)); // 输出: 120
console.log(factorialIterative(5)); // 输出: 120
```

**递归 vs 迭代比较：**

| 特性 | 递归 | 迭代 |
|------|------|------|
| 代码可读性 | 通常更简洁清晰，特别是处理树形结构 | 对简单问题可能更直观 |
| 性能 | 可能存在栈溢出风险，有额外的函数调用开销 | 通常性能更好，无栈溢出风险 |
| 内存使用 | 每次函数调用会占用栈空间 | 通常内存占用更少 |
| 适用场景 | 树形结构、分治算法、嵌套数据处理 | 线性问题、简单循环 |

### 2. 递归的优化

#### 尾递归优化

尾递归是指递归调用是函数体中最后执行的语句，且不在表达式中。尾递归可以被编译器或解释器优化，避免栈溢出：

```javascript
/**
 * @description 阶乘的尾递归实现
 * @param {number} n - 需要计算阶乘的非负整数
 * @param {number} [accumulator=1] - 累积的计算结果
 * @return {number} n的阶乘
 */
function factorialTailRecursive(n, accumulator = 1) {
  // 基本情况
  if (n === 0 || n === 1) {
    return accumulator;
  }
  // 尾递归调用，结果通过参数传递
  return factorialTailRecursive(n - 1, n * accumulator);
}

console.log(factorialTailRecursive(5)); // 输出: 120
```

> 注意：虽然ES6规范支持尾调用优化(TCO)，但目前只有Safari浏览器实现了这一特性。

#### 记忆化递归

使用缓存存储已计算结果，避免重复计算：

```javascript
/**
 * @description 带记忆功能的斐波那契数列实现
 * @param {number} n - 需要计算的斐波那契数列位置
 * @return {number} 斐波那契数列第n项的值
 */
function fibonacciMemoized() {
  // 创建缓存对象
  const cache = {};

  // 内部递归函数
  function fib(n) {
    // 检查缓存中是否已有计算结果
    if (n in cache) {
      return cache[n];
    }

    // 基本情况
    if (n <= 1) {
      return n;
    }

    // 计算结果并存入缓存
    cache[n] = fib(n - 1) + fib(n - 2);
    return cache[n];
  }

  // 返回内部函数
  return fib;
}

const fib = fibonacciMemoized();
console.log(fib(40)); // 输出: 102334155 (计算非常快)

// 未优化的递归版本对比
function fibonacciSlow(n) {
  if (n <= 1) return n;
  return fibonacciSlow(n - 1) + fibonacciSlow(n - 2);
}
// console.log(fibonacciSlow(40)); // 非常慢，不建议尝试
```

## 实战案例

### 1. 树形结构操作

树形结构是递归的典型应用场景，包括DOM树、文件系统、组织架构等。

#### 树的遍历

```javascript
/**
 * @description 树节点构造函数
 * @param {any} value - 节点值
 */
function TreeNode(value) {
  this.value = value;
  this.children = [];
}

/**
 * @description 深度优先遍历（DFS）
 * @param {TreeNode} node - 树节点
 * @param {function} callback - 处理节点的回调函数
 */
function depthFirstTraversal(node, callback) {
  // 基本情况：节点为null
  if (!node) return;

  // 处理当前节点
  callback(node.value);

  // 递归遍历所有子节点
  for (const child of node.children) {
    depthFirstTraversal(child, callback);
  }
}

/**
 * @description 广度优先遍历（BFS，使用队列，非递归实现）
 * @param {TreeNode} root - 根节点
 * @param {function} callback - 处理节点的回调函数
 */
function breadthFirstTraversal(root, callback) {
  if (!root) return;

  const queue = [root];

  while (queue.length > 0) {
    const node = queue.shift();
    callback(node.value);

    for (const child of node.children) {
      queue.push(child);
    }
  }
}

// 创建一个示例树
const root = new TreeNode('A');
const nodeB = new TreeNode('B');
const nodeC = new TreeNode('C');
const nodeD = new TreeNode('D');
const nodeE = new TreeNode('E');
const nodeF = new TreeNode('F');

root.children.push(nodeB, nodeC);
nodeB.children.push(nodeD, nodeE);
nodeC.children.push(nodeF);

// 测试遍历
console.log("DFS遍历结果:");
depthFirstTraversal(root, value => console.log(value));
// 输出: A B D E C F

console.log("BFS遍历结果:");
breadthFirstTraversal(root, value => console.log(value));
// 输出: A B C D E F
```

#### DOM树操作

```javascript
/**
 * @description 递归查找DOM树中所有符合选择器的元素
 * @param {Element} element - 起始DOM元素
 * @param {string} selector - CSS选择器
 * @return {Element[]} 符合选择器的元素数组
 */
function findAllElements(element, selector) {
  // 基本情况：不是元素节点
  if (!element || element.nodeType !== 1) return [];

  let result = [];

  // 检查当前元素是否匹配
  if (element.matches(selector)) {
    result.push(element);
  }

  // 递归检查所有子元素
  for (const child of element.children) {
    result = result.concat(findAllElements(child, selector));
  }

  return result;
}

// 使用示例（浏览器环境）
// const divs = findAllElements(document.body, 'div.highlight');
// console.log(divs);
```

### 2. 深拷贝实现

递归是实现深拷贝的标准方法，可以处理嵌套对象：

```javascript
/**
 * @description 对象深拷贝实现
 * @param {any} obj - 需要深拷贝的对象
 * @return {any} 深拷贝后的新对象
 */
function deepClone(obj) {
  // 基本情况：null或非对象类型
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }

  // 处理日期对象
  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }

  // 处理正则对象
  if (obj instanceof RegExp) {
    return new RegExp(obj);
  }

  // 处理数组
  if (Array.isArray(obj)) {
    return obj.map(item => deepClone(item));
  }

  // 处理普通对象
  const clonedObj = {};
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      clonedObj[key] = deepClone(obj[key]);
    }
  }

  return clonedObj;
}

// 测试深拷贝
const original = {
  name: "测试对象",
  info: {
    age: 25,
    address: {
      city: "北京",
      district: "海淀"
    }
  },
  hobbies: ["读书", "旅游", { type: "运动", detail: "篮球" }],
  sayHello: function() { return "你好"; },
  birthday: new Date('1998-01-01')
};

const cloned = deepClone(original);
cloned.info.address.city = "上海";
cloned.hobbies[2].detail = "足球";

console.log(original.info.address.city); // 输出: 北京 (未受影响)
console.log(cloned.info.address.city);   // 输出: 上海
console.log(original.hobbies[2].detail); // 输出: 篮球 (未受影响)
console.log(cloned.hobbies[2].detail);   // 输出: 足球
```

### 3. 数组扁平化

将多维数组转换为一维数组是递归的经典应用：

```javascript
/**
 * @description 数组扁平化函数
 * @param {Array} arr - 需要扁平化的数组
 * @param {number} [depth=Infinity] - 扁平化的深度，默认为无限深度
 * @return {Array} 扁平化后的数组
 */
function flattenArray(arr, depth = Infinity) {
  // 基本情况：深度为0或非数组
  if (depth <= 0 || !Array.isArray(arr)) {
    return arr;
  }

  return arr.reduce((result, item) => {
    if (Array.isArray(item)) {
      // 递归扁平化子数组，深度减1
      result.push(...flattenArray(item, depth - 1));
    } else {
      // 非数组元素直接添加
      result.push(item);
    }
    return result;
  }, []);
}

// 测试数组扁平化
const nestedArray = [1, [2, [3, 4], 5], [6, [7, 8, [9, 10]]]];
console.log(flattenArray(nestedArray));       // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
console.log(flattenArray(nestedArray, 1));    // [1, 2, [3, 4], 5, 6, [7, 8, [9, 10]]]
console.log(flattenArray(nestedArray, 2));    // [1, 2, 3, 4, 5, 6, 7, 8, [9, 10]]

// ES6原生方法对比
console.log([1, [2, [3, 4]]].flat(2));        // [1, 2, 3, 4]
```

## 面试常见问题

### 问题1：请解释递归的原理，并说明什么时候应该使用递归而不是迭代？

**答**：
递归是一种函数调用自身的编程技术。它将一个复杂问题分解为具有相同形式的更简单子问题，直到达到一个可以直接解决的基本情况。

递归函数通常包含两个关键部分：
1. **基本情况（终止条件）**：当问题简单到可以直接解决时，不再需要递归调用
2. **递归情况**：将问题分解为更小的子问题，并递归调用自身解决这些子问题

```javascript
/**
 * @description 阶乘函数的递归实现
 * @param {number} n - 需要计算阶乘的数
 * @return {number} 阶乘结果
 */
function factorial(n) {
  // 基本情况（终止条件）
  if (n <= 1) return 1;

  // 递归情况
  return n * factorial(n - 1);
}

console.log(factorial(5)); // 输出: 120
```

**适合使用递归的场景**：
1. 问题可以自然地分解为相似的子问题，如树形结构遍历、图形绘制算法（分形）
2. 数据结构天然具有递归性质，如树、图的操作
3. 问题使用递归描述比迭代更清晰、简洁
4. 分治算法场景，如快速排序、归并排序

**不适合使用递归的场景**：
1. 性能是关键考虑因素的场景，因为递归通常比迭代慢
2. 可能导致栈溢出的深层递归（JS引擎对调用栈有限制）
3. 较简单的线性问题，如简单的循环计数
4. 空间复杂度敏感的场景

**递归与迭代选择的权衡**：
- 选择递归：当代码可读性和维护性比性能更重要，且问题具有递归结构
- 选择迭代：当性能和内存使用是关键考虑因素，或问题是简单线性的

尾递归是一种特殊形式的递归，其递归调用是函数的最后一个操作，这种递归在某些语言环境中可以被优化，但在大多数JavaScript环境中仍有调用栈限制。