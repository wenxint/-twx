# 对象的常用方法

## 概念介绍
JavaScript对象是动态的键控集合，其内置的`Object`构造函数提供了一系列操作对象的静态方法。掌握这些方法能高效处理对象属性的枚举、合并、冻结等常见需求，是前端开发的基础技能。

## 核心方法
### 1. Object.keys(obj)
**作用**：返回对象自身可枚举属性的键名数组。
**语法**：`Object.keys(obj)`

### 2. Object.values(obj)
**作用**：返回对象自身可枚举属性的键值数组。
**语法**：`Object.values(obj)`

### 3. Object.assign(target, ...sources)
**作用**：将源对象的可枚举属性复制到目标对象（浅拷贝）。
**语法**：`Object.assign(target, ...sources)`

### 4. Object.entries(obj)
**作用**：返回对象自身可枚举属性的`[key, value]`数组。
**语法**：`Object.entries(obj)`

### 5. Object.freeze(obj)
**作用**：冻结对象，使其属性不可修改、添加或删除。
**语法**：`Object.freeze(obj)`

## 代码示例
```javascript
// 示例对象
const user = {
  name: 'Alice',
  age: 25,
  isAdmin: true
};

// Object.keys
console.log(Object.keys(user)); // ['name', 'age', 'isAdmin']

// Object.values
console.log(Object.values(user)); // ['Alice', 25, true]

// Object.assign（合并配置）
const defaultConfig = { theme: 'light', lang: 'en' };
const userConfig = { theme: 'dark' };
const finalConfig = Object.assign({}, defaultConfig, userConfig);
console.log(finalConfig); // { theme: 'dark', lang: 'en' }

// Object.entries
console.log(Object.entries(user)); // [['name','Alice'], ['age',25], ['isAdmin',true]]

// Object.freeze
const frozenObj = { x: 1 };
Object.freeze(frozenObj);
frozenObj.x = 2; // 严格模式下会报错，非严格模式静默失败
console.log(frozenObj.x); // 1
```

## 实战案例
**场景**：动态生成对象属性的表格
```javascript
function generateTable(obj) {
  const keys = Object.keys(obj);
  const values = Object.values(obj);
  return `
    <table>
      <tr>${keys.map(key => `<th>${key}</th>`).join('')}</tr>
      <tr>${values.map(val => `<td>${val}</td>`).join('')}</tr>
    </table>
  `;
}
console.log(generateTable(user)); // 生成包含name/age/isAdmin的表格HTML
```

## 兼容性说明
- `Object.keys`/`values`/`entries`：IE9+、Chrome 5+、Firefox 4+（需注意旧浏览器可能存在的polyfill需求）
- `Object.assign`：IE不支持（需polyfill），Chrome 45+、Firefox 34+
- `Object.freeze`：IE8仅支持DOM对象，现代浏览器（Chrome 6+、Firefox 3.5+）完整支持

## 面试常见问题
### 1. Object.assign是深拷贝还是浅拷贝？如何实现深拷贝？
**答案**：浅拷贝。若源对象属性值为引用类型（如数组、对象），目标对象将共享同一引用。深拷贝可通过`JSON.parse(JSON.stringify(obj))`（忽略函数/undefined/循环引用）或递归复制实现。

### 2. 如何遍历对象的所有属性（包括不可枚举属性）？
**答案**：使用`Object.getOwnPropertyNames(obj)`获取所有自身属性（包括不可枚举），结合`Object.getPrototypeOf(obj)`递归遍历原型链。

### 3. 冻结对象和密封对象有什么区别？
**答案**：`Object.freeze`使对象属性不可修改、添加、删除，且属性描述符不可配置；`Object.seal`允许修改现有属性值，但禁止添加/删除属性。