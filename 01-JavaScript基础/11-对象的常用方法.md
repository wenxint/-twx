# 对象的常用方法

## 概念介绍
JavaScript对象是动态的键控集合，其内置的`Object`构造函数提供了一系列操作对象的静态方法。掌握这些方法能高效处理对象属性的枚举、合并、冻结等常见需求，是前端开发的基础技能。

## 核心方法
### 1. Object.keys(obj)
**作用**：返回对象自身可枚举属性的键名数组。
**语法**：`Object.keys(obj)`

### 2. Object.values(obj)
**作用**：返回对象自身可枚举属性的键值数组。
**语法**：`Object.values(obj)`

### 3. Object.assign(target, ...sources)
**作用**：将源对象的可枚举属性复制到目标对象（浅拷贝）。
**语法**：`Object.assign(target, ...sources)`

### 4. Object.entries(obj)
**作用**：返回对象自身可枚举属性的`[key, value]`数组。
**语法**：`Object.entries(obj)`

### 5. Object.freeze(obj)
**作用**：冻结对象，使其属性不可修改、添加或删除。
**语法**：`Object.freeze(obj)`

### 6. Object.create(obj[, propertiesObject])
**作用**：使用指定的原型对象和可选的属性描述符创建一个新对象。这是实现原型继承的常用方法，相比`new`操作符更灵活，允许直接指定新对象的原型。
**语法**：`Object.create(proto[, propertiesObject])`
- `proto`：新对象的原型对象（必须是对象或`null`）
- `propertiesObject`（可选）：新对象的属性描述符对象，用于定义新对象的自身属性

### 代码示例
```javascript
// 创建一个以空对象为原型的新对象（无原型链）
const obj1 = Object.create(null);
console.log(obj1.__proto__); // undefined（因为null没有原型）

// 创建一个继承自person原型的对象
const person = {
  sayHello() {
    console.log(`Hello, my name is ${this.name}`);
  }
};
const student = Object.create(person, {
  name: {
    value: 'Alice', // 属性值
    writable: true, // 可修改
    enumerable: true, // 可枚举
    configurable: true // 可配置
  }
});

student.sayHello(); // 输出: Hello, my name is Alice
```

### 实战案例
在需要实现对象继承时，`Object.create`比`new`更灵活，例如：
```javascript
// 定义动物原型
const animalPrototype = {
  makeSound() {
    console.log(`${this.name} makes a sound`);
  }
};

// 创建具体动物对象（继承自动物原型）
const dog = Object.create(animalPrototype, {
  name: { value: 'Dog', enumerable: true }
});
dog.makeSound(); // 输出: Dog makes a sound
```

### 兼容性说明
- 现代浏览器（Chrome 5+、Firefox 4+、Safari 5+、Edge）均支持
- IE9+开始支持，IE8及以下不支持（需使用polyfill）

### 面试常见问题
1. **`Object.create(null)`和`{}`有什么区别？**  
答：`{}`创建的对象原型是`Object.prototype`，包含`toString`、`hasOwnProperty`等方法；而`Object.create(null)`创建的对象没有原型（`__proto__`为`null`），是一个“纯粹”的字典对象，适合作为哈希表使用，避免属性名与原型方法冲突。

2. **如何用`Object.create`实现类的继承？**  
答：可以通过将子类的原型设置为父类的实例来实现继承。例如：  
```javascript
function Parent() {}
Parent.prototype.sayHi = function() { console.log('Hi'); };

function Child() {}
Child.prototype = Object.create(Parent.prototype); // 继承父类原型
Child.prototype.constructor = Child; // 修正constructor指向
```

3. **`Object.create`的第二个参数有什么作用？**  
答：用于定义新对象的自身属性，每个属性通过属性描述符对象配置（如`value`、`writable`、`enumerable`、`configurable`），与`Object.defineProperty`的参数格式相同。

## 代码示例
```javascript
// 示例对象
const user = {
  name: 'Alice',
  age: 25,
  isAdmin: true
};

// Object.keys
console.log(Object.keys(user)); // ['name', 'age', 'isAdmin']

// Object.values
console.log(Object.values(user)); // ['Alice', 25, true]

// Object.assign（合并配置）
const defaultConfig = { theme: 'light', lang: 'en' };
const userConfig = { theme: 'dark' };
const finalConfig = Object.assign({}, defaultConfig, userConfig);
console.log(finalConfig); // { theme: 'dark', lang: 'en' }

// Object.entries
console.log(Object.entries(user)); // [['name','Alice'], ['age',25], ['isAdmin',true]]

// Object.freeze
const frozenObj = { x: 1 };
Object.freeze(frozenObj);
frozenObj.x = 2; // 严格模式下会报错，非严格模式静默失败
console.log(frozenObj.x); // 1
```

## 实战案例
**场景**：动态生成对象属性的表格
```javascript
function generateTable(obj) {
  const keys = Object.keys(obj);
  const values = Object.values(obj);
  return `
    <table>
      <tr>${keys.map(key => `<th>${key}</th>`).join('')}</tr>
      <tr>${values.map(val => `<td>${val}</td>`).join('')}</tr>
    </table>
  `;
}
console.log(generateTable(user)); // 生成包含name/age/isAdmin的表格HTML
```

## 兼容性说明
- `Object.keys`/`values`/`entries`：IE9+、Chrome 5+、Firefox 4+（需注意旧浏览器可能存在的polyfill需求）
- `Object.assign`：IE不支持（需polyfill），Chrome 45+、Firefox 34+
- `Object.freeze`：IE8仅支持DOM对象，现代浏览器（Chrome 6+、Firefox 3.5+）完整支持

## 面试常见问题
### 1. Object.assign是深拷贝还是浅拷贝？如何实现深拷贝？
**答案**：浅拷贝。若源对象属性值为引用类型（如数组、对象），目标对象将共享同一引用。深拷贝可通过`JSON.parse(JSON.stringify(obj))`（忽略函数/undefined/循环引用）或递归复制实现。

### 2. 如何遍历对象的所有属性（包括不可枚举属性）？
**答案**：使用`Object.getOwnPropertyNames(obj)`获取所有自身属性（包括不可枚举），结合`Object.getPrototypeOf(obj)`递归遍历原型链。

### 3. 冻结对象和密封对象有什么区别？
**答案**：`Object.freeze`使对象属性不可修改、添加、删除，且属性描述符不可配置；`Object.seal`允许修改现有属性值，但禁止添加/删除属性。