# 作用域与闭包

## 作用域

### 问题：什么是JavaScript中的作用域？有哪些作用域类型？

**答案：**
作用域是指在程序中定义变量的区域，该区域决定了变量的可访问性与生命周期。在JavaScript中，主要有以下几种作用域：

1. **全局作用域（Global Scope）**：
   - 在代码的最外层定义的变量
   - 未使用var/let/const声明但被赋值的变量（非严格模式下）
   - 在浏览器环境中，全局作用域中声明的变量挂载在window对象上

2. **函数作用域（Function Scope）**：
   - 在函数内部定义的变量只能在该函数内部访问
   - 使用var关键字声明的变量属于函数作用域

3. **块级作用域（Block Scope）**：
   - ES6引入的概念，使用let和const关键字声明的变量
   - 这些变量只能在最近的一对花括号{}内部访问

4. **词法作用域/静态作用域**：
   - JavaScript采用的是词法作用域，即变量的作用域在定义时就已确定
   - 与之相对的是动态作用域，变量的作用域在函数调用时确定

**作用域示例：**

```javascript
// 全局作用域
var globalVar = 'I am global';
let globalLet = 'I am also global';

function testScope() {
  // 函数作用域
  var functionVar = 'I am function-scoped';

  if (true) {
    // 块级作用域
    let blockLet = 'I am block-scoped';
    var blockVar = 'I am still function-scoped';

    console.log(globalVar); // 'I am global'
    console.log(functionVar); // 'I am function-scoped'
    console.log(blockLet); // 'I am block-scoped'
  }

  console.log(blockVar); // 'I am still function-scoped'
  console.log(blockLet); // ReferenceError: blockLet is not defined
}
```

> **经验分享**：在实际开发中，我建议尽量使用let和const代替var，以避免变量提升和意外的全局污染。全局变量应当谨慎使用，可以通过模块化方式或IIFE（立即执行函数表达式）来避免全局污染。在处理大型项目时，良好的作用域管理能有效减少命名冲突和内存泄漏问题。

## 闭包

### 问题：什么是闭包？闭包有哪些应用场景？可能引起的问题？

**答案：**
闭包是指函数和其周围的词法环境（lexical environment）的组合。简单来说，闭包是一个函数在创建时保留了当时创建环境中的变量的引用。

**闭包的本质特征：**
1. 内部函数可以访问外部函数的变量
2. 即使外部函数已经执行完毕，内部函数仍能访问这些变量
3. 这些变量不会被垃圾回收机制回收

**闭包示例：**

```javascript
function createCounter() {
  let count = 0;  // 私有变量

  return function() {
    count++;
    return count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

在上面的例子中，`createCounter`函数执行后返回一个匿名函数。这个匿名函数形成了一个闭包，它可以访问和操作`createCounter`函数内部的`count`变量，即使`createCounter`函数已经执行完毕。

**闭包的主要应用场景：**

1. **数据私有化/模块化**
```javascript
const module = (function() {
  let privateVar = 'I am private';

  function privateMethod() {
    return 'This is private';
  }

  return {
    publicMethod: function() {
      return privateVar;
    }
  };
})();

console.log(module.publicMethod()); // 'I am private'
console.log(module.privateVar); // undefined
```

2. **函数工厂/创建特定环境**
```javascript
function makeMultiplier(multiplier) {
  return function(x) {
    return x * multiplier;
  };
}

const double = makeMultiplier(2);
const triple = makeMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

3. **延迟执行/回调函数**
```javascript
function delayedGreeting(name) {
  return function() {
    console.log(`Hello, ${name}!`);
  };
}

const greetJohn = delayedGreeting('John');
// 可以在之后的某个时间点调用
setTimeout(greetJohn, 1000); // 1秒后输出: Hello, John!
```

4. **循环中的事件绑定**
```javascript
// 错误的方式
for (var i = 0; i < 3; i++) {
  document.getElementById('btn' + i).addEventListener('click', function() {
    console.log('Button ' + i + ' clicked'); // 总是输出 "Button 3 clicked"
  });
}

// 利用闭包修复
for (var i = 0; i < 3; i++) {
  (function(index) {
    document.getElementById('btn' + index).addEventListener('click', function() {
      console.log('Button ' + index + ' clicked'); // 正确输出当前按钮索引
    });
  })(i);
}

// ES6的方式
for (let i = 0; i < 3; i++) { // 使用let创建块级作用域
  document.getElementById('btn' + i).addEventListener('click', function() {
    console.log('Button ' + i + ' clicked'); // 正确输出当前按钮索引
  });
}
```

**闭包可能引起的问题：**

1. **内存泄漏**：闭包会保持对外部变量的引用，如果不当使用，可能导致这些变量无法被垃圾回收机制回收。

```javascript
function createLargeArray() {
  const largeArray = new Array(1000000).fill('some data');

  return function() {
    return largeArray[0]; // 整个大数组都被保留在内存中
  };
}

const getFirstItem = createLargeArray(); // largeArray不会被回收
```

2. **性能问题**：创建大量闭包可能影响性能，因为每个闭包都会占用内存。

```javascript
function addEventListenersInLoop() {
  const elements = document.querySelectorAll('.item'); // 假设有1000个元素

  for (let i = 0; i < elements.length; i++) {
    elements[i].addEventListener('click', function() {
      console.log('Element ' + i + ' clicked');
    }); // 创建1000个闭包
  }
}
```

3. **循环引用**：如果闭包的函数被赋值给HTML元素的事件处理器，而该闭包又引用了该DOM元素，可能形成循环引用。

```javascript
function attachClickHandler() {
  const element = document.getElementById('button');

  element.addEventListener('click', function() {
    console.log('Clicked', element.id); // 闭包引用了element
  });
}
```

> **经验分享**：在实际开发中，闭包是一个非常强大的特性，但需要谨慎使用。我通常遵循以下原则：
> 1. 避免在循环中创建大量闭包，可以考虑使用事件代理模式。
> 2. 当不再需要闭包时，将引用设为null，帮助垃圾回收。
> 3. 注意闭包函数的大小，避免捕获不必要的变量。
> 4. 对于React等现代框架，使用hooks时要特别注意闭包陷阱（stale closure）问题。
> 5. 在大型应用中，可以使用WeakMap等弱引用来存储闭包中需要的数据，减少内存占用。

## 变量提升

### 问题：什么是变量提升(Hoisting)？var、let和const的区别是什么？

**答案：**
变量提升是JavaScript中的一种机制，它将变量和函数的声明移到其作用域的顶部，这发生在代码执行之前的编译阶段。

**变量提升的特点：**

1. **var声明的变量会被提升，但初始化不会被提升**
```javascript
console.log(a); // undefined，而不是ReferenceError
var a = 5;
console.log(a); // 5

// 等效于：
var a;
console.log(a); // undefined
a = 5;
console.log(a); // 5
```

2. **函数声明会被完全提升（包括定义）**
```javascript
sayHello(); // "Hello!"
function sayHello() {
  console.log("Hello!");
}

// 等效于：
function sayHello() {
  console.log("Hello!");
}
sayHello(); // "Hello!"
```

3. **函数表达式不会被提升**
```javascript
sayHi(); // TypeError: sayHi is not a function
var sayHi = function() {
  console.log("Hi!");
};

// 等效于：
var sayHi;
sayHi(); // TypeError: sayHi is not a function
sayHi = function() {
  console.log("Hi!");
};
```

**var、let和const的区别：**

1. **变量提升**
   - var: 会提升到作用域顶部，初始值为undefined
   - let/const: 存在"暂时性死区"(TDZ)，在声明前访问会抛出ReferenceError

```javascript
console.log(varVariable); // undefined
var varVariable = 10;

console.log(letVariable); // ReferenceError
let letVariable = 20;
```

2. **作用域**
   - var: 函数作用域
   - let/const: 块级作用域

```javascript
function scopeTest() {
  {
    var varInBlock = 'var';
    let letInBlock = 'let';
  }
  console.log(varInBlock); // 'var'
  console.log(letInBlock); // ReferenceError
}
```

3. **重复声明**
   - var: 允许在同一作用域内重复声明
   - let/const: 不允许在同一作用域内重复声明

```javascript
var x = 1;
var x = 2; // 正常工作

let y = 1;
let y = 2; // SyntaxError: Identifier 'y' has already been declared
```

4. **全局对象属性**
   - var: 在全局作用域中声明的变量会成为全局对象(window/global)的属性
   - let/const: 不会成为全局对象的属性

```javascript
var globalVar = 'global var';
let globalLet = 'global let';

console.log(window.globalVar); // 'global var'
console.log(window.globalLet); // undefined
```

5. **初始化要求**
   - var/let: 可以先声明后赋值
   - const: 必须在声明时初始化，且不能重新赋值

```javascript
var a;
let b;
const c; // SyntaxError: Missing initializer in const declaration

a = 1; // 正常
b = 2; // 正常
const d = 3;
d = 4; // TypeError: Assignment to constant variable
```

6. **for循环中的表现**
```javascript
// 使用var
for (var i = 0; i < 3; i++) {}
console.log(i); // 3

// 使用let
for (let j = 0; j < 3; j++) {}
console.log(j); // ReferenceError: j is not defined
```

> **经验分享**：在现代JavaScript开发中，我几乎不再使用var，而是遵循以下原则：
> 1. 默认使用const声明变量，确保变量不会被意外修改
> 2. 只在确实需要重新赋值的场景使用let
> 3. 使用IIFE或模块化来创建隔离的作用域
> 4. 注意在代码重构时，将变量声明移动到首次使用之前，避免暂时性死区问题
> 5. 永远不要依赖变量提升机制，这会让代码变得难以维护和理解

这种声明变量的最佳实践有助于编写更加可预测和可维护的代码，减少潜在的bugs。