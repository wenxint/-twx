<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript 代码查看器</title>
    <!-- Prism.js CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"
      rel="stylesheet"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        line-height: 1.6;
        color: #333;
        display: flex;
        min-height: 100vh;
        background-color: #f8f9fa;
      }
      .sidebar {
        width: 280px;
        background-color: #2c3e50;
        color: #ecf0f1;
        padding: 20px 0;
        height: 100vh;
        position: fixed;
        overflow-y: auto;
        transition: all 0.3s;
      }
      .sidebar-header {
        padding: 0 20px 20px;
        border-bottom: 1px solid #34495e;
      }
      .sidebar-header h1 {
        font-size: 1.5rem;
        margin-bottom: 10px;
      }
      .search-container {
        margin: 20px 0;
        padding: 0 20px;
        position: relative;
      }
      .search-input {
        width: 100%;
        padding: 8px 40px 8px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
        box-sizing: border-box;
      }
      .search-input:focus {
        outline: none;
        border-color: #4CAF50;
      }
      .clear-search-btn {
        position: absolute;
        right: 28px;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        font-size: 18px;
        cursor: pointer;
        color: #999;
        padding: 0;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .clear-search-btn:hover {
        color: #666;
      }
      .nav-list {
        list-style: none;
        padding: 0 0 20px 0;
      }
      .nav-item {
        padding: 10px 20px;
        cursor: pointer;
        transition: background-color 0.2s;
        /* 移除边框相关属性 */
      }
      .nav-item:hover {
        background-color: #34495e;
      }
      .nav-item.active {
        background-color: #3498db;
        /* 移除边框相关属性 */
      }
      .main-content {
        flex: 1;
        margin-left: 280px;
        padding: 30px;
        max-width: calc(100% - 280px);
      }
      .code-section {
        padding: 20px;
        margin-bottom: 30px;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .code-section h2 {
        margin-bottom: 15px;
        color: #2c3e50;
        font-size: 1.8rem;
        padding-bottom: 10px;
        border-bottom: 2px solid #ecf0f1;
      }
      .code-description {
        margin-bottom: 15px;
        color: #666;
        line-height: 1.6;
      }
      pre {
        background-color: #f5f5f5;
        padding: 20px;
        border-radius: 5px;
        overflow-x: auto;
        margin-bottom: 10px;
        position: relative;
      }
      code {
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        font-size: 14px;
        color: #333;
      }
      .back-to-top {
        position: fixed;
        bottom: 30px;
        right: 30px;
        background-color: #3498db;
        color: white;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        opacity: 0;
        transition: opacity 0.3s;
      }
      .back-to-top.visible {
        opacity: 1;
      }
      .back-to-top i {
        font-size: 20px;
      }
      @media (max-width: 768px) {
        .sidebar {
          transform: translateX(-100%);
          z-index: 1000;
        }
        .sidebar.active {
          transform: translateX(0);
        }
        .main-content {
          margin-left: 0;
          max-width: 100%;
        }
        .toggle-sidebar {
          display: block;
          position: fixed;
          top: 20px;
          left: 20px;
          z-index: 1001;
          background-color: #3498db;
          color: white;
          border: none;
          border-radius: 4px;
          padding: 8px 12px;
          cursor: pointer;
        }
      }
      /* Prism.js 代码高亮样式调整 */
      pre[class*="language-"] {
        background: #f5f5f5;
        border: 1px solid #e1e1e1;
        border-radius: 8px;
        padding: 20px;
        margin: 15px 0;
        overflow: auto;
        position: relative;
        line-height: 1.5;
      }

      code[class*="language-"] {
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        font-size: 13px;
        line-height: 1.5;
      }

      .language-javascript {
        color: #333;
      }
    </style>
  </head>
  <body>
    <div class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <h1>JavaScript 代码查看器</h1>
        <p>常用 JavaScript 代码片段集合</p>
      </div>
      <div class="search-container">
        <input
          type="text"
          class="search-input"
          id="searchInput"
          placeholder="搜索代码片段..."
        />
        <button class="clear-search-btn" id="clearSearchBtn" style="display: none;">×</button>
      </div>
      <ul class="nav-list" id="navList">
        <li class="nav-item" data-target="requestAnimationFrame">
          requestAnimationFrame 动画优化
        </li>
        <li class="nav-item" data-target="promiseMyAll">Promise.MyAll 实现</li>
        <li class="nav-item" data-target="curry">函数柯里化</li>
        <li class="nav-item" data-target="mySetInterval">自定义 setInterval</li>
        <li class="nav-item" data-target="lengthOfLongestSubstring">
          最长不重复子串
        </li>
        <li class="nav-item" data-target="axiosCancel">Axios 请求取消</li>
        <li class="nav-item" data-target="thousandSeparator">千分位分隔符</li>
        <li class="nav-item" data-target="floatEqual">浮点数比较</li>
        <li class="nav-item" data-target="hyphenToCamelCase">连字符转驼峰</li>
        <li class="nav-item" data-target="binarySearch">二分查找</li>
        <li class="nav-item" data-target="bubbleSort">冒泡排序</li>
        <li class="nav-item" data-target="quickSort">快速排序</li>
        <li class="nav-item" data-target="myCallApplyBind">
          手写 call/apply/bind
        </li>
        <li class="nav-item" data-target="myInstanceof">手写 instanceof</li>
        <li class="nav-item" data-target="deepClone">深拷贝对象</li>
        <li class="nav-item" data-target="simpleLimit">异步并发控制</li>
        <li class="nav-item" data-target="lazyLoad">图片懒加载</li>
        <li class="nav-item" data-target="setOperations">Set集合操作</li>
        <li class="nav-item" data-target="iframeDetection">iframe页面检测</li>
        <li class="nav-item" data-target="myReduce">手写reduce函数</li>
      </ul>
    </div>

    <button class="toggle-sidebar" id="toggleSidebar" style="display: none">
      ☰
    </button>

    <div class="main-content">
      <div class="code-section" id="requestAnimationFrame">
        <h2>requestAnimationFrame 动画优化</h2>
        <div class="code-description">
          使用 requestAnimationFrame 实现平滑动画，相比 setTimeout 和
          setInterval 具有更好的性能和更流畅的动画效果。
        </div>
        <pre><code class="language-javascript">// 使用 requestAnimationFrame 优化动画
let position = 0;
const targetPosition = 300; // 目标位置（300px）
let animationId;

function animate() {
  position += 5;
  element.style.transform = `translateX(${position}px)`;

  // 达到目标位置时停止动画
  if (position < targetPosition) {
    animationId = requestAnimationFrame(animate);
  } else {
    cancelAnimationFrame(animationId); // 取消下一帧请求
    console.log("动画已停止，最终位置：", position, "px");
  }
}

// 启动动画
animationId = requestAnimationFrame(animate);</code></pre>
      </div>

      <div class="code-section" id="promiseMyAll">
        <h2>Promise.MyAll 实现</h2>
        <div class="code-description">
          手动实现 Promise.all 方法，接收一个 Promise 数组，返回一个新的
          Promise，当所有 Promise 都成功时返回结果数组，任一 Promise
          失败则返回失败原因。
        </div>
        <pre><code class="language-javascript">// 首先，让我们回顾一下MyAll的实现
Promise.MyAll = function (promises) {
  // 存储所有 Promise 的结果
  let arr = [],
    // 计数器,记录已完成的 Promise 数量
    count = 0;

  // 返回一个新的 Promise
  return new Promise((resolve, reject) => {
    // 处理空数组的情况
    if (promises.length === 0) {
      resolve([]);
      return;
    }

    // 遍历传入的 promises 数组
    promises.forEach((item, i) => {
      // 将每个项转为 Promise 对象并执行
      Promise.resolve(item).then(
        (res) => {
          // 按照原始顺序存储结果
          arr[i] = res;
          // 完成计数加1
          count += 1;
          // 当所有 Promise 都完成时,返回结果数组
          if (count === promises.length) resolve(arr);
        },
        // 任何一个 Promise 失败时直接 reject
        reject
      );
    });
  });
};

// ==================== 调用示例 ====================

/**
 * 示例1: 处理全部成功的Promise
 */
console.log("\n===== 示例1: 全部成功的Promise =====");

// 创建多种类型的Promise
const promise1 = Promise.resolve(1); // 立即解决的Promise
const promise2 = new Promise((resolve) => setTimeout(() => resolve(2), 1000)); // 延迟解决的Promise
const promise3 = 3; // 非Promise值(会被自动转换为Promise)
const promise4 = new Promise((resolve) => setTimeout(() => resolve(4), 500)); // 另一个延迟解决的Promise

// 使用自定义的MyAll方法
console.log("开始执行MyAll...");
const startTimeMyAll = Date.now();

Promise.MyAll([promise1, promise2, promise3, promise4])
  .then((results) => {
    const endTimeMyAll = Date.now();
    console.log("MyAll结果:", results);
    console.log("MyAll执行时间:", endTimeMyAll - startTimeMyAll, "ms");
    console.log("MyAll结果类型:", Object.prototype.toString.call(results));
    console.log(
      "MyAll保持了原始顺序，即使promise2(1000ms)比promise4(500ms)晚完成"
    );
  })
  .catch((error) => {
    console.error("MyAll错误:", error);
  });</code></pre>
      </div>

      <div class="code-section" id="curry">
        <h2>函数柯里化</h2>
        <div class="code-description">
          实现函数柯里化，将接受多个参数的函数转换为接受单个参数的函数序列，每个函数返回一个新函数，直到收集所有参数后执行原函数。
        </div>
        <pre><code class="language-javascript">/**
 * @description 通用柯里化函数
 * @param {Function} fn - 要柯里化的原始函数
 * @return {Function} 柯里化后的函数
 */
function curry(fn) {
  // 收集参数的闭包变量
  const collectArgs = (...args) => {
    // 如果已收集参数数量满足原始函数要求，执行原始函数
    if (args.length >= fn.length) {
      return fn(...args);
    }
    // 否则返回新函数继续收集参数
    return (...nextArgs) => collectArgs(...args, ...nextArgs);
  };
  return collectArgs;
}</code></pre>
      </div>

      <div class="code-section" id="mySetInterval">
        <h2>自定义 setInterval</h2>
        <div class="code-description">
          使用 setTimeout 实现 setInterval 的功能，可以避免 setInterval
          的一些问题，如回调函数执行时间超过间隔时间导致的连续执行。
        </div>
        <pre><code class="language-javascript">// 手写mySetInterval
function mySetInterval(callback, delay) {
  // 初始调用
  callback(); // 递归调用 setTimeout 来模拟 setInterval
  const intervalId = setTimeout(() => {
    // 清除前一个 setTimeout，防止在回调函数执行时间较长时产生累积的延迟
    clearTimeout(intervalId); // 递归调用 mySetInterval
    mySetInterval(callback, delay); // 执行回调函数
  }, delay);
}
// 使用示例
mySetInterval(() => console.log("Hello, world!"), 1000);

//mySetInterval 中的递归通过 setTimeout 转换为 异步递归 ，每次递归调用的触发点是事件循环的宏任务队列，而非当前调用栈的延续。因此，调用栈不会累积，自然不会触发栈溢出。</code></pre>
      </div>

      <div class="code-section" id="lengthOfLongestSubstring">
        <h2>最长不重复子串</h2>
        <div class="code-description">
          查找字符串中最长的不含重复字符的子串，使用滑动窗口算法实现，时间复杂度为
          O(n)。
        </div>
        <pre><code class="language-javascript">function lengthOfLongestSubstring(s) {
  let start = 0; // 窗口起始位置
  let maxLength = 0; // 最长不重复子串的长度
  let seen = new Set(); // 用于存储窗口内的字符
  for (let end = 0; end < s.length; end++) {
    // 如果当前字符已经在窗口内，则移动窗口的起始位置
    while (seen.has(s[end])) {
      seen.delete(s[start]);
      start++;
    } // 将当前字符添加到窗口内
    seen.add(s[end]); // 更新最长不重复子串的长度
    maxLength = Math.max(maxLength, end - start + 1);
  }
  return maxLength;
}
// 示例
const s = "abcabcbb";
console.log(lengthOfLongestSubstring(s)); // 输出 3</code></pre>
      </div>

      <div class="code-section" id="axiosCancel">
        <h2>axios 取消请求</h2>
        <div class="code-description">
          实现类似 axios
          的请求取消功能，可以在请求发出后主动取消，避免不必要的网络请求和处理。
        </div>
        <pre><code class="language-javascript">// 创建一个 CancelToken 类来处理取消逻辑
class CancelToken {
  constructor() {
    this.promise = new Promise((resolve) => {
      this.cancel = resolve;
    });
  }
}

// 创建一个工厂函数来生成 CancelToken
CancelToken.source = function () {
  const source = new CancelToken();
  return {
    token: source,
    cancel: source.cancel,
  };
};

// 简化版的 axios 请求函数
function request(url, config = {}) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url);

    // 如果配置了 cancelToken，则监听取消事件
    if (config.cancelToken) {
      config.cancelToken.promise.then(() => {
        xhr.abort();
        reject(new Error("Request cancelled"));
      });
    }

    xhr.onload = () => resolve(xhr.response);
    xhr.onerror = () => reject(new Error("Network error"));
    xhr.send();
  });
}

// 使用示例
const source = CancelToken.source();

request("https://api.example.com/data", {
  cancelToken: source.token,
})
  .then((response) => console.log(response))
  .catch((error) => console.log(error.message));

// 3秒后取消请求
setTimeout(() => {
  source.cancel();
}, 3000);</code></pre>
      </div>

      <div class="code-section" id="thousandSeparator">
        <h2>数字千分位分隔符</h2>
        <div class="code-description">
          为数字添加千分位分隔符，支持整数和小数，提高数字的可读性。
        </div>
        <pre><code class="language-javascript">function thousandSeparator(num) {
  // 将数字转换为字符串
  const str = num.toString();

  // 检查是否有小数点
  const parts = str.split('.');

  // 对整数部分添加千分位分隔符
  parts[0] = parts[0].replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1,');

  // 重新组合整数和小数部分
  return parts.join('.');
}

// 使用示例
console.log(thousandSeparator(1234567)); // "1,234,567"
console.log(thousandSeparator(1234567.89)); // "1,234,567.89"
console.log(thousandSeparator(1000)); // "1,000"</code></pre>
      </div>

      <div class="code-section" id="floatEqual">
        <h2>浮点数相等比较</h2>
        <div class="code-description">
          由于浮点数精度问题，直接使用 ===
          比较可能得到错误结果。这个函数提供了准确的浮点数比较方法。
        </div>
        <pre><code class="language-javascript">function floatEqual(a, b, epsilon = Number.EPSILON) {
  return Math.abs(a - b) < epsilon;
}

// 使用示例
console.log(0.1 + 0.2 === 0.3); // false
console.log(floatEqual(0.1 + 0.2, 0.3)); // true

// 自定义精度
console.log(floatEqual(0.1 + 0.2, 0.3, 1e-10)); // true</code></pre>
      </div>

      <div class="code-section" id="hyphenToCamelCase">
        <h2>短横线转驼峰命名</h2>
        <div class="code-description">
          将短横线命名（kebab-case）转换为驼峰命名（camelCase），常用于 CSS
          属性名转换为 JavaScript 中的样式属性名。
        </div>
        <pre><code class="language-javascript">function hyphenToCamelCase(str) {
  return str.replace(/-(\w)/g, (match, letter) => letter.toUpperCase());
}

// 使用示例
console.log(hyphenToCamelCase('background-color')); // "backgroundColor"
console.log(hyphenToCamelCase('font-size')); // "fontSize"
console.log(hyphenToCamelCase('border-top-width')); // "borderTopWidth"</code></pre>
      </div>

      <div class="code-section" id="binarySearch">
        <h2>二分查找</h2>
        <div class="code-description">
          在有序数组中查找目标值的高效算法，时间复杂度为 O(log n)。
        </div>
        <pre><code class="language-javascript">function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);

    if (arr[mid] === target) {
      return mid; // 找到目标值，返回索引
    } else if (arr[mid] < target) {
      left = mid + 1; // 目标值在右半部分
    } else {
      right = mid - 1; // 目标值在左半部分
    }
  }

  return -1; // 未找到目标值
}

// 使用示例
const sortedArray = [1, 3, 5, 7, 9, 11, 13, 15];
console.log(binarySearch(sortedArray, 7)); // 3
console.log(binarySearch(sortedArray, 4)); // -1</code></pre>
      </div>

      <div class="code-section" id="bubbleSort">
        <h2>冒泡排序</h2>
        <div class="code-description">
          简单的排序算法，通过重复遍历要排序的列表，比较相邻元素并交换它们的位置。时间复杂度为
          O(n²)。
        </div>
        <pre><code class="language-javascript">function bubbleSort(arr) {
  const n = arr.length;

  for (let i = 0; i < n - 1; i++) {
    let swapped = false;

    for (let j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        // 交换元素
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        swapped = true;
      }
    }

    // 如果没有交换发生，说明数组已经有序
    if (!swapped) break;
  }

  return arr;
}

// 使用示例
const numbers = [64, 34, 25, 12, 22, 11, 90];
console.log(bubbleSort([...numbers])); // [11, 12, 22, 25, 34, 64, 90]</code></pre>
      </div>

      <div class="code-section" id="quickSort">
        <h2>快速排序</h2>
        <div class="code-description">
          高效的排序算法，采用分治策略，选择一个基准元素，将数组分为两部分进行递归排序。平均时间复杂度为
          O(n log n)。
        </div>
        <pre><code class="language-javascript">function quickSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  const pivot = arr[Math.floor(arr.length / 2)];
  const left = [];
  const right = [];
  const equal = [];

  for (let element of arr) {
    if (element < pivot) {
      left.push(element);
    } else if (element > pivot) {
      right.push(element);
    } else {
      equal.push(element);
    }
  }

  return quickSort(left).concat(equal, quickSort(right));
}

// 使用示例
const numbers = [64, 34, 25, 12, 22, 11, 90];
console.log(quickSort(numbers)); // [11, 12, 22, 25, 34, 64, 90]</code></pre>
      </div>

      <div class="code-section" id="myCallApplyBind">
        <h2>手写 call、apply、bind</h2>
        <div class="code-description">
          手动实现 JavaScript 中的 call、apply、bind 方法，用于改变函数执行时的
          this 指向。
        </div>
        <pre><code class="language-javascript">// 手写 call 方法
Function.prototype.myCall = function(context, ...args) {
  // 如果 context 为 null 或 undefined，则指向全局对象
  context = context || globalThis;

  // 创建一个唯一的属性名，避免覆盖原有属性
  const fnSymbol = Symbol('fn');

  // 将当前函数赋值给 context 的临时属性
  // this 指向当前函数（即调用 myCall 的函数）
  context[fnSymbol] = this;

  // 调用函数并获取结果
  const result = context[fnSymbol](...args);

  // 删除临时属性
  delete context[fnSymbol];

  return result;
};

// 手写 apply 方法
Function.prototype.myApply = function(context, args) {
  // 如果 context 为 null 或 undefined，则指向全局对象
  context = context || globalThis;

  // 创建一个唯一的属性名，避免覆盖原有属性
  const fnSymbol = Symbol('fn');

  // 将当前函数赋值给 context 的临时属性
  // this 指向当前函数（即调用 myApply 的函数）
  context[fnSymbol] = this;

  // 调用函数并获取结果
  const result = context[fnSymbol](...args);

  // 删除临时属性
  delete context[fnSymbol];

  return result;
};

// 手写 bind 方法
Function.prototype.myBind = function(context, ...args) {
  // 如果 context 为 null 或 undefined，则指向全局对象
  context = context || globalThis;

  // 保存原始函数
  const fn = this;

  // 返回一个新的函数
  return function(...bindArgs) {
    // 将 bind 方法的参数与原始函数的参数合并
    const allArgs = [...args, ...bindArgs];

    // 调用原始函数并返回结果
    return fn.apply(context, allArgs);
  };
};</code></pre>
      </div>

      <div class="code-section" id="myInstanceof">
        <h2>手写 instanceof</h2>
        <div class="code-description">
          手动实现 JavaScript 中的 instanceof 运算符，用于检查一个对象是否是另一个构造函数的实例。
        </div>
        <pre><code class="language-javascript">function myInstanceof(obj, constructor) {
  // 如果 constructor 不是函数，抛出错误
  if (typeof constructor !== 'function') {
    throw new TypeError('constructor must be a function');
  }

  // 获取 obj 的原型对象
  let proto = Object.getPrototypeOf(obj);

  // 循环检查原型链
  while (proto !== null) {
    // 如果原型对象等于 constructor.prototype，返回 true
    if (proto === constructor.prototype) {
      return true;
    }
    // 否则继续沿原型链向上查找
    proto = Object.getPrototypeOf(proto);
  }

  // 如果没有找到，返回 false
  return false;
}

// 使用示例
function Animal() {}
function Dog() {}

Dog.prototype = Object.create(Animal.prototype);

const dog = new Dog();
console.log(myInstanceof(dog, Dog)); // true
console.log(myInstanceof(dog, Animal)); // true
console.log(myInstanceof(dog, Object)); // true
console.log(myInstanceof(dog, Array)); // false</code></pre>
      </div>

      <div class="code-section" id="deepClone">
        <h2>深拷贝对象</h2>
        <div class="code-description">
          实现深拷贝函数，可以复制对象及其内部的所有属性和值，包括嵌套对象和数组。
        </div>
        <pre><code class="language-javascript">function deepClone(obj) {
  // 如果是基本类型或 null，直接返回
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }

  // 如果是 Date 对象，返回新的 Date 对象
  if (obj instanceof Date) {
    return new Date(obj);
  }

  // 如果是 RegExp 对象，返回新的 RegExp 对象
  if (obj instanceof RegExp) {
    return new RegExp(obj);
  }

  // 如果是数组，创建新数组并递归处理每个元素
  if (Array.isArray(obj)) {
    const newArr = [];
    for (let i = 0; i < obj.length; i++) {
      newArr[i] = deepClone(obj[i]);
    }
    return newArr;
  }

  // 如果是对象，创建新对象并递归处理每个属性
  const newObj = {};
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      newObj[key] = deepClone(obj[key]);
    }
  }
  return newObj;
}

// 使用示例
const original = {
  a: 1,
  b: {
    c: 2,
    d: [3, 4],
    e: {
      f: 5,
    },
  },
  g: /\d+/,
  h: new Date(),
};

const cloned = deepClone(original);
console.log(cloned);</code></pre>
      </div>

      <div class="code-section" id="simpleLimit">
        <h2>异步并发控制</h2>
        <div class="code-description">
          实现一个简单的异步并发控制器，可以限制同时运行的异步任务数量，避免资源过度占用。
        </div>
        <pre><code class="language-javascript">class SimpleLimit {
  constructor(limit) {
    this.limit = limit;
    this.count = 0;
    this.queue = [];
  }

  async run(task) {
    // 如果当前运行任务数量已达到限制，将任务加入队列
    if (this.count >= this.limit) {
      await new Promise((resolve) => this.queue.push(resolve));
    }

    // 运行任务
    this.count++;
    try {
      await task();
    } finally {
      this.count--;
      // 如果队列中有等待任务，唤醒一个
      if (this.queue.length > 0) {
        this.queue.shift()();
      }
    }
  }
}

// 使用示例
const limit = new SimpleLimit(2);

async function task(id) {
  console.log(`Task ${id} started`);
  await new Promise((resolve) => setTimeout(resolve, 1000));
  console.log(`Task ${id} finished`);
}

for (let i = 1; i <= 5; i++) {
  limit.run(() => task(i));</code></pre>
      </div>

      <div class="code-section" id="lazyLoad">
        <h2>图片懒加载</h2>
        <div class="code-description">
          实现图片懒加载功能，只有当图片进入可视区域时才加载图片，提高页面性能。
        </div>
        <pre><code class="language-javascript">function lazyLoadImages() {
  const images = document.querySelectorAll('img[data-src]');

  const observer = new IntersectionObserver((entries, observer) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        const img = entry.target;
        img.src = img.dataset.src;
        img.removeAttribute('data-src');
        observer.unobserve(img);
      }
    });
  });

  images.forEach((img) => observer.observe(img));
}

// 使用示例
lazyLoadImages();</code></pre>
      </div>

      <div class="code-section" id="setOperations">
        <h2>Set集合操作</h2>
        <div class="code-description">
          实现ES6 Set的交集、并集、差集操作，以及实际应用示例。
        </div>
        <pre><code class="language-javascript">// 交集
function intersection(setA, setB) {
  return new Set([...setA].filter(item => setB.has(item)));
}

// 并集
function union(setA, setB) {
  return new Set([...setA, ...setB]);
}

// 差集
function difference(setA, setB) {
  return new Set([...setA].filter(item => !setB.has(item)));
}

// 实际应用示例
const users1 = new Set(['Alice', 'Bob', 'Charlie']);
const users2 = new Set(['Bob', 'Charlie', 'David']);

// 查找共同好友
const commonFriends = intersection(users1, users2);
console.log('Common friends:', [...commonFriends]);

// 查找所有用户
const allUsers = union(users1, users2);
console.log('All users:', [...allUsers]);

// 查找只属于users1的用户
const uniqueToUsers1 = difference(users1, users2);
console.log('Unique to users1:', [...uniqueToUsers1]);</code></pre>
      </div>

      <div class="code-section" id="iframeDetection">
        <h2>iframe页面检测</h2>
        <div class="code-description">
          检测当前页面是否在iframe中运行，并提供相应的处理逻辑。
        </div>
        <pre><code class="language-javascript">// 基本检测方法：window.self !== window.top
function isInIframe() {
  return window.self !== window.top;
}

// 更完整的检测函数
function isInIframeDetailed() {
  try {
    // 是否可以访问父页面
    const canAccessParent = !!window.parent && window.parent !== window;

    // 父页面origin获取
    const parentOrigin = canAccessParent ? window.parent.origin : null;

    // 嵌套深度计算
    let depth = 0;
    let currentWindow = window;
    while (currentWindow !== currentWindow.parent) {
      depth++;
      currentWindow = currentWindow.parent;
    }

    return {
      isInIframe: true,
      canAccessParent,
      parentOrigin,
      depth,
    };
  } catch (error) {
    return {
      isInIframe: false,
      canAccessParent: false,
      parentOrigin: null,
      depth: 0,
    };
  }
}

// 实际应用场景和处理逻辑
if (isInIframe()) {
  console.log('当前页面在iframe中运行');
  // 可以根据需要进行相应的处理
} else {
  console.log('当前页面是顶级窗口');
}

// 更完整的检测方法
function detectIframeEnvironment() {
  const detection = {
    isInIframe: window.self !== window.top,
    canAccessParent: false,
    parentOrigin: null,
    frameDepth: 0
  };

  // 检测是否可以访问父页面
  try {
    detection.canAccessParent = !!window.parent.location.href;
    detection.parentOrigin = window.parent.location.origin;
  } catch (e) {
    // 跨域情况下会抛出异常
    detection.canAccessParent = false;
  }

  // 计算嵌套深度
  let currentWindow = window;
  while (currentWindow !== currentWindow.parent) {
    detection.frameDepth++;
    currentWindow = currentWindow.parent;

    // 防止无限循环
    if (detection.frameDepth > 10) break;
  }

  return detection;
}

// 使用示例
const envInfo = detectIframeEnvironment();
console.log('环境信息:', envInfo);

// 根据环境信息执行不同逻辑
if (envInfo.isInIframe) {
  console.log(`页面在${envInfo.frameDepth}层iframe中`);

  if (envInfo.canAccessParent) {
    console.log('可以访问父页面，同源');
  } else {
    console.log('无法访问父页面，可能跨域');
  }
}

/**
 * 手写reduce函数实现
 */
Array.prototype.myReduce = function (callback, initialValue) {
  // 1. 检查回调函数是否为函数
  if (typeof callback !== "function") {
    throw new TypeError(callback + " is not a function");
  }

  const array = this; // 当前数组
  const length = array.length;
  let accumulator;
  let startIndex;

  // 2. 处理初始值
  if (arguments.length >= 2) {
    // 如果提供了初始值，从第 0 个元素开始
    accumulator = initialValue;
    startIndex = 0;
  } else {
    // 如果没有提供初始值，使用第一个元素作为初始值，并从第 1 个元素开始
    if (length === 0) {
      throw new TypeError("Reduce of empty array with no initial value");
    }
    accumulator = array[0];
    startIndex = 1;
  }

  // 3. 遍历数组，执行累加器函数
  for (let i = startIndex; i < length; i++) {
    accumulator = callback(accumulator, array[i], i, array);
  }

  // 4. 返回最终的累积值
  return accumulator;
};

// 使用示例和测试

// 示例1: 数组求和
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.myReduce((acc, curr) => acc + curr, 0);
console.log('数组求和:', sum); // 输出: 15

// 示例2: 数组求积
const product = numbers.myReduce((acc, curr) => acc * curr, 1);
console.log('数组求积:', product); // 输出: 120

// 示例3: 查找最大值
const max = numbers.myReduce((acc, curr) => Math.max(acc, curr), -Infinity);
console.log('最大值:', max); // 输出: 5

// 示例4: 数组扁平化
const nestedArray = [[1, 2], [3, [4, 5]]];
const flattened = nestedArray.myReduce((acc, curr) => acc.concat(curr), []);
console.log('数组扁平化:', flattened); // 输出: [1, 2, 3, 4, 5]

// 示例5: 对象属性统计
const objArray = [
  { name: 'Alice', age: 25 },
  { name: 'Bob', age: 30 },
  { name: 'Charlie', age: 25 }
];
const ageCount = objArray.myReduce((acc, curr) => {
  acc[curr.age] = (acc[curr.age] || 0) + 1;
  return acc;
}, {});
console.log('年龄统计:', ageCount); // 输出: { '25': 2, '30': 1 }

// 示例6: 对象数组转换
const objArray2 = [
  { id: 1, name: 'Apple' },
  { id: 2, name: 'Banana' },
  { id: 3, name: 'Cherry' }
];
const objById = objArray2.myReduce((acc, curr) => {
  acc[curr.id] = curr;
  return acc;
}, {});
console.log('对象数组转换:', objById); // 输出: { '1': { id: 1, name: 'Apple' }, '2': { id: 2, name: 'Banana' }, '3': { id: 3, name: 'Cherry' } }

// 错误处理测试用例
try {
  const invalid = [].myReduce(() => {});
} catch (error) {
  console.error('错误处理测试:', error.message); // 输出: is not a function
}

</code></pre>
      </div>

      <button class="back-to-top" id="backToTop">
        <i class="fas fa-arrow-up"></i>
      </button>
    </div>

    <script>
      // 获取所有代码片段
      const codeSections = document.querySelectorAll('.code-section');

      // 获取所有导航项
      const navItems = document.querySelectorAll('.nav-item');

      // 获取搜索输入框和清空按钮
      const searchInput = document.getElementById('searchInput');
      const clearSearchBtn = document.getElementById('clearSearchBtn');

      // 获取返回顶部按钮
      const backToTopBtn = document.getElementById('backToTop');

      // 监听滚动事件
      window.addEventListener('scroll', () => {
        // 显示/隐藏返回顶部按钮
        if (window.scrollY > 200) {
          backToTopBtn.classList.add('visible');
        } else {
          backToTopBtn.classList.remove('visible');
        }
      });

      // 返回顶部按钮点击事件
      backToTopBtn.addEventListener('click', () => {
        window.scrollTo({
          top: 0,
          behavior: 'smooth',
        });
      });

      // 监听搜索输入框输入事件
      searchInput.addEventListener('input', () => {
        const searchText = searchInput.value.toLowerCase();

        // 显示/隐藏清空按钮
        if (searchText.length > 0) {
          clearSearchBtn.style.display = 'block';
        } else {
          clearSearchBtn.style.display = 'none';
        }

        // 遍历所有导航项
        navItems.forEach((item) => {
          const targetId = item.dataset.target;
          const codeSection = document.getElementById(targetId);

          // 如果导航项文本包含搜索文本，显示对应的代码片段
          if (item.textContent.toLowerCase().includes(searchText)) {
            codeSection.style.display = 'block';
          } else {
            codeSection.style.display = 'none';
          }
        });
      });

      // 清空按钮点击事件
      clearSearchBtn.addEventListener('click', () => {
        searchInput.value = '';
        clearSearchBtn.style.display = 'none';

        // 显示所有代码片段
        codeSections.forEach((section) => {
          section.style.display = 'block';
        });
      });

      // 监听导航项点击事件
      navItems.forEach((item) => {
        item.addEventListener('click', () => {
          const targetId = item.dataset.target;
          const targetSection = document.getElementById(targetId);

          // 滚动到对应的代码片段
          targetSection.scrollIntoView({
            behavior: 'smooth',
          });

          // 移除所有导航项的 active 类
          navItems.forEach((item) => {
            item.classList.remove('active');
          });

          // 添加 active 类到当前导航项
          item.classList.add('active');
        });
      });
    </script>

    <!-- Prism.js JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-javascript.min.js"></script>

    <script>
      // 初始化 Prism.js 高亮
      Prism.highlightAll();
    </script>
  </body>
</html>
