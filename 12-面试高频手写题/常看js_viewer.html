<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript 代码查看器</title>
    <!-- Prism.js CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css"
      rel="stylesheet"
    />
    <link
      href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.css"
      rel="stylesheet"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        line-height: 1.6;
        color: #333;
        display: flex;
        min-height: 100vh;
        background-color: #f8f9fa;
      }
      .sidebar {
        width: 280px;
        background-color: #2c3e50;
        color: #ecf0f1;
        padding: 20px 0;
        height: 100vh;
        position: fixed;
        overflow-y: auto;
        transition: all 0.3s;
      }
      .sidebar-header {
        padding: 0 20px 20px;
        border-bottom: 1px solid #34495e;
      }
      .sidebar-header h1 {
        font-size: 1.5rem;
        margin-bottom: 10px;
      }
      .search-container {
        padding: 15px 20px;
        position: sticky;
        top: 0;
        background-color: #2c3e50;
        z-index: 10;
      }
      .search-input {
        width: 100%;
        padding: 8px 12px;
        border: none;
        border-radius: 4px;
        background-color: #34495e;
        color: #ecf0f1;
        font-size: 14px;
      }
      .search-input::placeholder {
        color: #95a5a6;
      }
      .nav-list {
        list-style: none;
        padding: 0 0 20px 0;
      }
      .nav-item {
        padding: 10px 20px;
        cursor: pointer;
        transition: background-color 0.2s;
        /* 移除边框相关属性 */
      }
      .nav-item:hover {
        background-color: #34495e;
      }
      .nav-item.active {
        background-color: #3498db;
        /* 移除边框相关属性 */
      }
      .main-content {
        flex: 1;
        margin-left: 280px;
        padding: 30px;
        max-width: calc(100% - 280px);
      }
      .code-section {
        margin-bottom: 40px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        padding: 25px;
      }
      .code-section h2 {
        margin-bottom: 15px;
        color: #2c3e50;
        font-size: 1.8rem;
        padding-bottom: 10px;
        border-bottom: 2px solid #ecf0f1;
      }
      .code-description {
        margin-bottom: 20px;
        color: #7f8c8d;
      }
      pre {
        background-color: #f5f5f5;
        padding: 20px;
        border-radius: 5px;
        overflow-x: auto;
        margin-bottom: 10px;
        position: relative;
      }
      code {
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        font-size: 14px;
        color: #333;
      }
      .copy-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        background-color: #3498db;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 5px 10px;
        font-size: 12px;
        cursor: pointer;
        opacity: 0.7;
        transition: opacity 0.2s;
      }
      .copy-btn:hover {
        opacity: 1;
      }
      .back-to-top {
        position: fixed;
        bottom: 30px;
        right: 30px;
        background-color: #3498db;
        color: white;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        opacity: 0;
        transition: opacity 0.3s;
      }
      .back-to-top.visible {
        opacity: 1;
      }
      .back-to-top i {
        font-size: 20px;
      }
      @media (max-width: 768px) {
        .sidebar {
          transform: translateX(-100%);
          z-index: 1000;
        }
        .sidebar.active {
          transform: translateX(0);
        }
        .main-content {
          margin-left: 0;
          max-width: 100%;
        }
        .toggle-sidebar {
          display: block;
          position: fixed;
          top: 20px;
          left: 20px;
          z-index: 1001;
          background-color: #3498db;
          color: white;
          border: none;
          border-radius: 4px;
          padding: 8px 12px;
          cursor: pointer;
        }
      }
      /* Prism.js 代码高亮样式调整 */
      pre[class*="language-"] {
        background: #f5f5f5;
        border: 1px solid #e1e1e1;
        border-radius: 8px;
        padding: 20px;
        margin: 15px 0;
        overflow: auto;
        position: relative;
        line-height: 1.5;
      }

      code[class*="language-"] {
        font-family: Consolas, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
        font-size: 13px;
        line-height: 1.5;
      }

      /* 行号相关样式 */
      .line-numbers {
        position: relative;
        padding-left: 3.8em !important;
        counter-reset: linenumber;
      }

      .line-numbers > code {
        position: relative;
        white-space: inherit;
      }

      .line-numbers .line-numbers-rows {
        position: absolute;
        pointer-events: none;
        top: 0;
        font-size: 100%;
        left: -3.8em;
        width: 3em;
        letter-spacing: -1px;
        border-right: 1px solid #999;
        user-select: none;
        z-index: 1;
      }

      .line-numbers-rows > span {
        display: block;
        counter-increment: linenumber;
        height: 1.5em;
        line-height: 1.5em;
      }

      .line-numbers-rows > span:before {
        content: counter(linenumber);
        color: #999;
        display: block;
        padding-right: 0.8em;
        text-align: right;
        font-size: 13px;
      }

      /* 确保代码块在各种情况下都能正确显示 */
      pre.line-numbers {
        position: relative;
        padding-left: 3.8em !important;
        counter-reset: linenumber;
      }

      pre.line-numbers > code {
        position: relative;
        white-space: inherit;
      }

      /* 强制显示行号的备用样式 */
      pre[class*="language-"].line-numbers {
        padding-left: 3.8em !important;
      }

      /* 当Prism.js未加载时的备用行号样式 */
      .manual-line-numbers {
        position: relative;
        padding-left: 3.8em !important;
      }

      .manual-line-numbers .line-numbers-rows {
        position: absolute;
        top: 0;
        left: 0;
        width: 3em;
        padding-right: 0.8em;
        text-align: right;
        color: #999;
        font-size: 13px;
        border-right: 1px solid #ddd;
        background-color: #f9f9f9;
        user-select: none;
        pointer-events: none;
        line-height: 1.5em;
      }
    </style>
  </head>
  <body>
    <div class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <h1>JavaScript 代码查看器</h1>
        <p>常用 JavaScript 代码片段集合</p>
      </div>
      <div class="search-container">
        <input
          type="text"
          class="search-input"
          id="searchInput"
          placeholder="搜索代码片段..."
        />
      </div>
      <ul class="nav-list" id="navList">
        <li class="nav-item" data-target="requestAnimationFrame">
          requestAnimationFrame 动画优化
        </li>
        <li class="nav-item" data-target="promiseMyAll">Promise.MyAll 实现</li>
        <li class="nav-item" data-target="curry">函数柯里化</li>
        <li class="nav-item" data-target="mySetInterval">自定义 setInterval</li>
        <li class="nav-item" data-target="lengthOfLongestSubstring">
          最长不重复子串
        </li>
        <li class="nav-item" data-target="axiosCancel">Axios 请求取消</li>
        <li class="nav-item" data-target="thousandSeparator">千分位分隔符</li>
        <li class="nav-item" data-target="floatEqual">浮点数比较</li>
        <li class="nav-item" data-target="hyphenToCamelCase">连字符转驼峰</li>
        <li class="nav-item" data-target="binarySearch">二分查找</li>
        <li class="nav-item" data-target="bubbleSort">冒泡排序</li>
        <li class="nav-item" data-target="quickSort">快速排序</li>
        <li class="nav-item" data-target="myCallApplyBind">
          手写 call/apply/bind
        </li>
        <li class="nav-item" data-target="myInstanceof">手写 instanceof</li>
        <li class="nav-item" data-target="deepClone">深拷贝对象</li>
        <li class="nav-item" data-target="simpleLimit">异步并发控制</li>
        <li class="nav-item" data-target="lazyLoad">图片懒加载</li>
        <li class="nav-item" data-target="setOperations">Set集合操作</li>
        <li class="nav-item" data-target="iframeDetection">iframe页面检测</li>
        <li class="nav-item" data-target="myReduce">手写reduce函数</li>
      </ul>
    </div>

    <button class="toggle-sidebar" id="toggleSidebar" style="display: none">
      ☰
    </button>

    <div class="main-content">
      <div class="code-section" id="requestAnimationFrame">
        <h2>requestAnimationFrame 动画优化</h2>
        <div class="code-description">
          使用 requestAnimationFrame 实现平滑动画，相比 setTimeout 和
          setInterval 具有更好的性能和更流畅的动画效果。
        </div>
        <pre
          class="line-numbers"
        ><code class="language-javascript">// 使用 requestAnimationFrame 优化动画
let position = 0;
const targetPosition = 300; // 目标位置（300px）
let animationId;

function animate() {
  position += 5;
  element.style.transform = `translateX(${position}px)`;

  // 达到目标位置时停止动画
  if (position < targetPosition) {
    animationId = requestAnimationFrame(animate);
  } else {
    cancelAnimationFrame(animationId); // 取消下一帧请求
    console.log("动画已停止，最终位置：", position, "px");
  }
}

// 启动动画
animationId = requestAnimationFrame(animate);</code></pre>
        <button class="copy-btn">复制代码</button>
      </div>

      <div class="code-section" id="promiseMyAll">
        <h2>Promise.MyAll 实现</h2>
        <div class="code-description">
          手动实现 Promise.all 方法，接收一个 Promise 数组，返回一个新的
          Promise，当所有 Promise 都成功时返回结果数组，任一 Promise
          失败则返回失败原因。
        </div>
        <pre
          class="line-numbers"
        ><code class="language-javascript">// 首先，让我们回顾一下MyAll的实现
Promise.MyAll = function (promises) {
  // 存储所有 Promise 的结果
  let arr = [],
    // 计数器,记录已完成的 Promise 数量
    count = 0;

  // 返回一个新的 Promise
  return new Promise((resolve, reject) => {
    // 处理空数组的情况
    if (promises.length === 0) {
      resolve([]);
      return;
    }

    // 遍历传入的 promises 数组
    promises.forEach((item, i) => {
      // 将每个项转为 Promise 对象并执行
      Promise.resolve(item).then(
        (res) => {
          // 按照原始顺序存储结果
          arr[i] = res;
          // 完成计数加1
          count += 1;
          // 当所有 Promise 都完成时,返回结果数组
          if (count === promises.length) resolve(arr);
        },
        // 任何一个 Promise 失败时直接 reject
        reject
      );
    });
  });
};

// ==================== 调用示例 ====================

/**
 * 示例1: 处理全部成功的Promise
 */
console.log("\n===== 示例1: 全部成功的Promise =====");

// 创建多种类型的Promise
const promise1 = Promise.resolve(1); // 立即解决的Promise
const promise2 = new Promise((resolve) => setTimeout(() => resolve(2), 1000)); // 延迟解决的Promise
const promise3 = 3; // 非Promise值(会被自动转换为Promise)
const promise4 = new Promise((resolve) => setTimeout(() => resolve(4), 500)); // 另一个延迟解决的Promise

// 使用自定义的MyAll方法
console.log("开始执行MyAll...");
const startTimeMyAll = Date.now();

Promise.MyAll([promise1, promise2, promise3, promise4])
  .then((results) => {
    const endTimeMyAll = Date.now();
    console.log("MyAll结果:", results);
    console.log("MyAll执行时间:", endTimeMyAll - startTimeMyAll, "ms");
    console.log("MyAll结果类型:", Object.prototype.toString.call(results));
    console.log(
      "MyAll保持了原始顺序，即使promise2(1000ms)比promise4(500ms)晚完成"
    );
  })
  .catch((error) => {
    console.error("MyAll错误:", error);
  });</code></pre>
        <button class="copy-btn">复制代码</button>
      </div>

      <div class="code-section" id="curry">
        <h2>函数柯里化</h2>
        <div class="code-description">
          实现函数柯里化，将接受多个参数的函数转换为接受单个参数的函数序列，每个函数返回一个新函数，直到收集所有参数后执行原函数。
        </div>
        <pre class="line-numbers"><code class="language-javascript">/**
 * @description 通用柯里化函数
 * @param {Function} fn - 要柯里化的原始函数
 * @return {Function} 柯里化后的函数
 */
function curry(fn) {
  // 收集参数的闭包变量
  const collectArgs = (...args) => {
    // 如果已收集参数数量满足原始函数要求，执行原始函数
    if (args.length >= fn.length) {
      return fn(...args);
    }
    // 否则返回新函数继续收集参数
    return (...nextArgs) => collectArgs(...args, ...nextArgs);
  };
  return collectArgs;
}</code></pre>
        <button class="copy-btn">复制代码</button>
      </div>

      <div class="code-section" id="mySetInterval">
        <h2>自定义 setInterval</h2>
        <div class="code-description">
          使用 setTimeout 实现 setInterval 的功能，可以避免 setInterval
          的一些问题，如回调函数执行时间超过间隔时间导致的连续执行。
        </div>
        <pre
          class="line-numbers"
        ><code class="language-javascript">// 手写mySetInterval
function mySetInterval(callback, delay) {
  // 初始调用
  callback(); // 递归调用 setTimeout 来模拟 setInterval
  const intervalId = setTimeout(() => {
    // 清除前一个 setTimeout，防止在回调函数执行时间较长时产生累积的延迟
    clearTimeout(intervalId); // 递归调用 mySetInterval
    mySetInterval(callback, delay); // 执行回调函数
  }, delay);
}
// 使用示例
mySetInterval(() => console.log("Hello, world!"), 1000);

//mySetInterval 中的递归通过 setTimeout 转换为 异步递归 ，每次递归调用的触发点是事件循环的宏任务队列，而非当前调用栈的延续。因此，调用栈不会累积，自然不会触发栈溢出。</code></pre>
        <button class="copy-btn">复制代码</button>
      </div>

      <div class="code-section" id="lengthOfLongestSubstring">
        <h2>最长不重复子串</h2>
        <div class="code-description">
          查找字符串中最长的不含重复字符的子串，使用滑动窗口算法实现，时间复杂度为
          O(n)。
        </div>
        <pre
          class="line-numbers"
        ><code class="language-javascript">function lengthOfLongestSubstring(s) {
  let start = 0; // 窗口起始位置
  let maxLength = 0; // 最长不重复子串的长度
  let seen = new Set(); // 用于存储窗口内的字符
  for (let end = 0; end < s.length; end++) {
    // 如果当前字符已经在窗口内，则移动窗口的起始位置
    while (seen.has(s[end])) {
      seen.delete(s[start]);
      start++;
    } // 将当前字符添加到窗口内
    seen.add(s[end]); // 更新最长不重复子串的长度
    maxLength = Math.max(maxLength, end - start + 1);
  }
  return maxLength;
}
// 示例
const s = "abcabcbb";
console.log(lengthOfLongestSubstring(s)); // 输出 3</code></pre>
        <button class="copy-btn">复制代码</button>
      </div>

      <div class="code-section" id="axiosCancel">
        <h2>axios 取消请求</h2>
        <div class="code-description">
          实现类似 axios
          的请求取消功能，可以在请求发出后主动取消，避免不必要的网络请求和处理。
        </div>
        <pre
          class="line-numbers"
        ><code class="language-javascript">// 创建一个 CancelToken 类来处理取消逻辑
class CancelToken {
  constructor() {
    this.promise = new Promise((resolve) => {
      this.cancel = resolve;
    });
  }
}

// 创建一个工厂函数来生成 CancelToken
CancelToken.source = function () {
  const source = new CancelToken();
  return {
    token: source,
    cancel: source.cancel,
  };
};

// 简化版的 axios 请求函数
function request(url, config = {}) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url);

    // 如果配置了 cancelToken，则监听取消事件
    if (config.cancelToken) {
      config.cancelToken.promise.then(() => {
        xhr.abort();
        reject(new Error("Request cancelled"));
      });
    }

    xhr.onload = () => resolve(xhr.response);
    xhr.onerror = () => reject(new Error("Network error"));
    xhr.send();
  });
}

// 使用示例
const source = CancelToken.source();

request("https://api.example.com/data", {
  cancelToken: source.token,
})
  .then((response) => console.log(response))
  .catch((error) => console.log(error.message));

// 3秒后取消请求
setTimeout(() => {
  source.cancel();
}, 3000);</code></pre>
        <button class="copy-btn">复制代码</button>
      </div>

      <div class="code-section" id="thousandSeparator">
        <h2>数字千分位分隔符</h2>
        <div class="code-description">
          为数字添加千分位分隔符，支持整数和小数，提高数字的可读性。
        </div>
        <pre
          class="line-numbers"
        ><code class="language-javascript">function thousandSeparator(num) {
  // 将数字转换为字符串
  const str = num.toString();

  // 检查是否有小数点
  const parts = str.split('.');

  // 对整数部分添加千分位分隔符
  parts[0] = parts[0].replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1,');

  // 重新组合整数和小数部分
  return parts.join('.');
}

// 使用示例
console.log(thousandSeparator(1234567)); // "1,234,567"
console.log(thousandSeparator(1234567.89)); // "1,234,567.89"
console.log(thousandSeparator(1000)); // "1,000"</code></pre>
        <button class="copy-btn">复制代码</button>
      </div>

      <div class="code-section" id="floatEqual">
        <h2>浮点数相等比较</h2>
        <div class="code-description">
          由于浮点数精度问题，直接使用 ===
          比较可能得到错误结果。这个函数提供了准确的浮点数比较方法。
        </div>
        <pre
          class="line-numbers"
        ><code class="language-javascript">function floatEqual(a, b, epsilon = Number.EPSILON) {
  return Math.abs(a - b) < epsilon;
}

// 使用示例
console.log(0.1 + 0.2 === 0.3); // false
console.log(floatEqual(0.1 + 0.2, 0.3)); // true

// 自定义精度
console.log(floatEqual(0.1 + 0.2, 0.3, 1e-10)); // true</code></pre>
        <button class="copy-btn">复制代码</button>
      </div>

      <div class="code-section" id="hyphenToCamelCase">
        <h2>短横线转驼峰命名</h2>
        <div class="code-description">
          将短横线命名（kebab-case）转换为驼峰命名（camelCase），常用于 CSS
          属性名转换为 JavaScript 中的样式属性名。
        </div>
        <pre
          class="line-numbers"
        ><code class="language-javascript">function hyphenToCamelCase(str) {
  return str.replace(/-(\w)/g, (match, letter) => letter.toUpperCase());
}

// 使用示例
console.log(hyphenToCamelCase('background-color')); // "backgroundColor"
console.log(hyphenToCamelCase('font-size')); // "fontSize"
console.log(hyphenToCamelCase('border-top-width')); // "borderTopWidth"</code></pre>
        <button class="copy-btn">复制代码</button>
      </div>

      <div class="code-section" id="binarySearch">
        <h2>二分查找</h2>
        <div class="code-description">
          在有序数组中查找目标值的高效算法，时间复杂度为 O(log n)。
        </div>
        <pre
          class="line-numbers"
        ><code class="language-javascript">function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);

    if (arr[mid] === target) {
      return mid; // 找到目标值，返回索引
    } else if (arr[mid] < target) {
      left = mid + 1; // 目标值在右半部分
    } else {
      right = mid - 1; // 目标值在左半部分
    }
  }

  return -1; // 未找到目标值
}

// 使用示例
const sortedArray = [1, 3, 5, 7, 9, 11, 13, 15];
console.log(binarySearch(sortedArray, 7)); // 3
console.log(binarySearch(sortedArray, 4)); // -1</code></pre>
        <button class="copy-btn">复制代码</button>
      </div>

      <div class="code-section" id="bubbleSort">
        <h2>冒泡排序</h2>
        <div class="code-description">
          简单的排序算法，通过重复遍历要排序的列表，比较相邻元素并交换它们的位置。时间复杂度为
          O(n²)。
        </div>
        <pre
          class="line-numbers"
        ><code class="language-javascript">function bubbleSort(arr) {
  const n = arr.length;

  for (let i = 0; i < n - 1; i++) {
    let swapped = false;

    for (let j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        // 交换元素
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        swapped = true;
      }
    }

    // 如果没有交换发生，说明数组已经有序
    if (!swapped) break;
  }

  return arr;
}

// 使用示例
const numbers = [64, 34, 25, 12, 22, 11, 90];
console.log(bubbleSort([...numbers])); // [11, 12, 22, 25, 34, 64, 90]</code></pre>
        <button class="copy-btn">复制代码</button>
      </div>

      <div class="code-section" id="quickSort">
        <h2>快速排序</h2>
        <div class="code-description">
          高效的排序算法，采用分治策略，选择一个基准元素，将数组分为两部分进行递归排序。平均时间复杂度为
          O(n log n)。
        </div>
        <pre
          class="line-numbers"
        ><code class="language-javascript">function quickSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  const pivot = arr[Math.floor(arr.length / 2)];
  const left = [];
  const right = [];
  const equal = [];

  for (let element of arr) {
    if (element < pivot) {
      left.push(element);
    } else if (element > pivot) {
      right.push(element);
    } else {
      equal.push(element);
    }
  }

  return quickSort(left).concat(equal, quickSort(right));
}

// 使用示例
const numbers = [64, 34, 25, 12, 22, 11, 90];
console.log(quickSort(numbers)); // [11, 12, 22, 25, 34, 64, 90]</code></pre>
        <button class="copy-btn">复制代码</button>
      </div>

      <div class="code-section" id="myCallApplyBind">
        <h2>手写 call、apply、bind</h2>
        <div class="code-description">
          手动实现 JavaScript 中的 call、apply、bind 方法，用于改变函数执行时的
          this 指向。
        </div>
        <pre
          class="line-numbers"
        ><code class="language-javascript">// 手写 call 方法
Function.prototype.myCall = function(context, ...args) {
  // 如果 context 为 null 或 undefined，则指向全局对象
  context = context || globalThis;

  // 创建一个唯一的属性名，避免覆盖原有属性
  const fnSymbol = Symbol('fn');

  // 将当前函数赋值给 context 的临时属性
  // this 指向当前函数（即调用 myCall 的函数）
  context[fnSymbol] = this;

  // 调用函数并获取结果
  const result = context[fnSymbol](...args);

  // 删除临时属性
  delete context[fnSymbol];

  return result;
};

// 手写 apply 方法
Function.prototype.myApply = function(context, argsArray) {
  // 如果 context 为 null 或 undefined，则指向全局对象
  context = context || globalThis;

  // 创建一个唯一的属性名
  const fnSymbol = Symbol('fn');

  // 将当前函数赋值给 context 的临时属性
  context[fnSymbol] = this;

  // 调用函数并获取结果
  const result = argsArray ? context[fnSymbol](...argsArray) : context[fnSymbol]();

  // 删除临时属性
  delete context[fnSymbol];

  return result;
};

// 手写 bind 方法
Function.prototype.myBind = function(context, ...bindArgs) {
  const self = this;

  // 返回一个新函数
  return function boundFunction(...callArgs) {
    // 判断是否通过 new 操作符调用
    if (new.target) {
      // 作为构造函数调用
      return new self(...bindArgs, ...callArgs);
    } else {
      // 作为普通函数调用
      return self.apply(context, [...bindArgs, ...callArgs]);
    }
  };
};

// 使用示例
const obj = { name: 'Alice' };

function greet(greeting, punctuation) {
  return `${greeting}, ${this.name}${punctuation}`;
}

// 测试 myCall
console.log(greet.myCall(obj, 'Hello', '!')); // "Hello, Alice!"

// 测试 myApply
console.log(greet.myApply(obj, ['Hi', '.'])); // "Hi, Alice."

// 测试 myBind
const boundGreet = greet.myBind(obj, 'Hey');
console.log(boundGreet('?')); // "Hey, Alice?"</code></pre>
        <button class="copy-btn">复制代码</button>
      </div>

      <div class="code-section" id="myInstanceof">
        <h2>手写 instanceof</h2>
        <div class="code-description">
          自定义实现 instanceof 运算符，检测构造函数的 prototype
          是否存在于对象的原型链中。通过遍历原型链来判断对象是否为特定构造函数的实例。
        </div>
        <pre class="line-numbers"><code class="language-javascript">/**
 * @description 自定义实现instanceof运算符，检测构造函数的prototype是否存在于对象的原型链中
 * @param {Object|Function} obj - 要检测的目标对象（注意：基本类型直接返回false）
 * @param {Function} constructor - 用于检测的构造函数
 * @return {boolean} 目标对象是否为构造函数的实例
 */
function myInstanceof(obj, constructor) {
  // 处理基本类型：基本类型没有原型链，直接返回false（null也在此处处理）
  if ((typeof obj !== "object" && typeof obj !== "function") || obj === null) {
    return false;
  }
  // 获取目标对象的原型（等同于obj.__proto__，但推荐使用标准方法）
  let proto = Object.getPrototypeOf(obj);
  // 遍历原型链，直到原型为null（原型链终点）
  while (proto !== null) {
    // 检查当前原型是否等于构造函数的prototype属性
    if (proto === constructor.prototype) {
      return true; // 找到匹配，返回true
    }
    // 继续向上查找原型链
    proto = Object.getPrototypeOf(proto);
  }
  // 遍历完整个原型链未找到匹配，返回false
  return false;
}

// 使用示例
function Animal() {}
const cat = new Animal();
console.log(myInstanceof(cat, Animal)); // 输出: true
console.log(myInstanceof(cat, Object)); // 输出: true
console.log(myInstanceof(123, Number)); // 输出: false（基本类型直接返回false）</code></pre>
        <button class="copy-btn">复制代码</button>
      </div>

      <div class="code-section" id="deepClone">
        <h2>深拷贝对象</h2>
        <div class="code-description">
          实现对象的深拷贝功能，递归处理对象和数组的每个属性，创建完全独立的副本。解决浅拷贝时嵌套对象仍然共享引用的问题。
        </div>
        <pre class="line-numbers"><code class="language-javascript">/**
 * 深拷贝一个对象
 *
 * @param {any} obj 需要深拷贝的对象
 * @returns {any} 深拷贝后的对象
 */
function deepClone(obj) {
  // 如果传入的对象不是对象或者为null，则直接返回该对象
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }

  let clone;
  // 如果传入的对象是数组
  if (Array.isArray(obj)) {
    clone = [];
    // 遍历数组中的每个元素，递归调用deepClone进行深拷贝
    for (let i = 0; i < obj.length; i++) {
      clone[i] = deepClone(obj[i]);
    }
  } else {
    // 如果传入的对象不是数组，则初始化为空对象
    clone = {};
    // 遍历对象的每个属性，递归调用deepClone进行深拷贝
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        clone[key] = deepClone(obj[key]);
      }
    }
  }

  return clone;
}

// 使用示例
const originalObj = {
  name: "张三",
  age: 25,
  hobbies: ["读书", "游戏"],
  address: {
    city: "北京",
    district: "朝阳区"
  }
};

const clonedObj = deepClone(originalObj);
clonedObj.hobbies.push("运动");
clonedObj.address.city = "上海";

console.log("原对象:", originalObj);
// 原对象: { name: "张三", age: 25, hobbies: ["读书", "游戏"], address: { city: "北京", district: "朝阳区" } }

console.log("克隆对象:", clonedObj);
// 克隆对象: { name: "张三", age: 25, hobbies: ["读书", "游戏", "运动"], address: { city: "上海", district: "朝阳区" } }</code></pre>
        <button class="copy-btn">复制代码</button>
      </div>

      <div class="code-section" id="simpleLimit">
        <h2>异步并发控制</h2>
        <div class="code-description">
          实现一个简单的异步任务并发控制器，限制同时执行的异步任务数量。通过队列管理待执行任务，动态调度任务执行，避免系统资源过载。
        </div>
        <pre class="line-numbers"><code class="language-javascript">/**
 * 超简单版本：控制固定数量异步任务的并发执行
 * @param {number} limit - 最大并发数
 */
function simpleLimit(limit) {
  // 等待执行的任务队列
  const queue = [];
  // 当前正在执行的任务数量
  let activeCount = 0;

  // 执行队列中的下一个任务
  const runNext = () => {
    if (queue.length === 0) return;

    // 如果正在执行的任务数量小于限制，则执行下一个任务
    if (activeCount < limit) {
      // 从队列中取出一个任务
      const { fn, resolve, reject } = queue.shift();
      activeCount++;

      Promise.resolve(fn())
        .then(resolve)
        .catch(reject)
        .finally(() => {
          activeCount--;
          runNext(); // 任务完成后，尝试执行下一个任务
        });
    }
  };

  // 返回一个函数，用于添加任务
  return (fn) => {
    return new Promise((resolve, reject) => {
      queue.push({ fn, resolve, reject });
      runNext();
    });
  };
}

// 使用示例
const runTask = simpleLimit(2); // 最多同时执行2个任务

// 创建5个模拟的异步任务
const createTask = (id, delay) => () => {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log(`任务${id}完成，耗时${delay}ms`);
      resolve(`任务${id}的结果`);
    }, delay);
  });
};

// 执行任务并获取结果
runTask(createTask(1, 1000)).then((result) => console.log(result));
runTask(createTask(2, 2000)).then((result) => console.log(result));
runTask(createTask(3, 1500)).then((result) => console.log(result));
runTask(createTask(4, 800)).then((result) => console.log(result));

// 输出顺序示例：
// 任务4完成，耗时800ms
// 任务4的结果
// 任务1完成，耗时1000ms
// 任务1的结果
// 任务3完成，耗时1500ms
// 任务3的结果
// 任务2完成，耗时2000ms
// 任务2的结果</code></pre>
        <button class="copy-btn">复制代码</button>
      </div>

      <div class="code-section" id="lazyLoad">
        <h2>图片懒加载</h2>
        <div class="code-description">
          实现一个功能完整的图片懒加载类，支持 IntersectionObserver API
          和传统的滚动监听方式。提供节流优化、动态扫描、错误处理等功能，有效提升页面性能。
        </div>
        <pre class="line-numbers"><code class="language-javascript">/**
 * 图片懒加载类
 * @class LazyLoad
 */
class LazyLoad {
  /**
   * 创建懒加载实例
   * @param {Object} options - 配置选项
   * @param {string} options.selector - 懒加载图片的CSS选择器
   * @param {string} options.dataSrc - 存储真实图片地址的data属性名
   * @param {number} options.threshold - IntersectionObserver的阈值
   * @param {number} options.throttleDelay - 节流延迟时间（毫秒）
   */
  constructor(options = {}) {
    this.options = {
      selector: ".lazy-image",
      dataSrc: "data-src",
      threshold: 0.1,
      throttleDelay: 200,
      ...options,
    };

    this.images = [];
    this.observer = null;
    this.initialized = false;

    // 绑定方法的this
    this.throttledLoad = this.throttle(
      this.loadImages.bind(this),
      this.options.throttleDelay
    );
  }

  /**
   * 初始化懒加载
   */
  init() {
    if (this.initialized) return;

    this.images = Array.from(document.querySelectorAll(this.options.selector));

    if ("IntersectionObserver" in window) {
      this.initIntersectionObserver();
    } else {
      this.initLegacyLazyLoad();
    }

    this.initialized = true;
  }

  /**
   * 使用IntersectionObserver初始化
   */
  initIntersectionObserver() {
    this.observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            this.loadImage(entry.target);
            this.observer.unobserve(entry.target);
          }
        });
      },
      {
        threshold: this.options.threshold,
      }
    );

    this.images.forEach((image) => {
      if (image.hasAttribute(this.options.dataSrc)) {
        this.observer.observe(image);
      }
    });
  }

  /**
   * 初始化传统的滚动监听方式
   */
  initLegacyLazyLoad() {
    // 初始检查
    this.loadImages();

    // 添加滚动事件监听
    window.addEventListener("scroll", this.throttledLoad);
    window.addEventListener("resize", this.throttledLoad);
    window.addEventListener("orientationchange", this.throttledLoad);
  }

  /**
   * 加载所有在可视区域内的图片
   */
  loadImages() {
    this.images = this.images.filter((image) => {
      if (!image.hasAttribute(this.options.dataSrc)) {
        return false;
      }

      if (this.isInViewport(image)) {
        this.loadImage(image);
        return false;
      }

      return true;
    });

    // 如果所有图片都已加载，移除事件监听
    if (this.images.length === 0) {
      this.destroy();
    }
  }

  /**
   * 加载单张图片
   * @param {HTMLImageElement} image - 要加载的图片元素
   */
  loadImage(image) {
    const src = image.getAttribute(this.options.dataSrc);
    if (!src) return;

    // 设置加载事件
    image.onload = () => {
      image.removeAttribute(this.options.dataSrc);
      image.classList.add("lazy-loaded");
    };

    // 设置错误处理
    image.onerror = () => {
      console.error(`Failed to load image: ${src}`);
      image.removeAttribute(this.options.dataSrc);
    };

    // 触发图片加载
    image.src = src;
  }

  /**
   * 检查元素是否在可视区域内
   * @param {HTMLElement} element - 要检查的元素
   * @returns {boolean} 是否在可视区域内
   */
  isInViewport(element) {
    const rect = element.getBoundingClientRect();
    return (
      rect.top <=
        (window.innerHeight || document.documentElement.clientHeight) &&
      rect.bottom >= 0 &&
      rect.left <=
        (window.innerWidth || document.documentElement.clientWidth) &&
      rect.right >= 0
    );
  }

  /**
   * 节流函数
   * @param {Function} func - 要节流的函数
   * @param {number} delay - 延迟时间（毫秒）
   * @returns {Function} 节流后的函数
   */
  throttle(func, delay) {
    let lastCall = 0;
    return function (...args) {
      const now = Date.now();
      if (now - lastCall >= delay) {
        lastCall = now;
        func.apply(this, args);
      }
    };
  }

  /**
   * 重新扫描页面中的懒加载图片
   * 用于动态添加的内容
   */
  rescan() {
    const newImages = Array.from(
      document.querySelectorAll(this.options.selector)
    ).filter(
      (image) =>
        !this.images.includes(image) && image.hasAttribute(this.options.dataSrc)
    );

    if (newImages.length > 0) {
      this.images = [...this.images, ...newImages];

      if (this.observer) {
        newImages.forEach((image) => this.observer.observe(image));
      } else {
        this.loadImages();
      }
    }
  }

  /**
   * 销毁懒加载实例，移除所有事件监听
   */
  destroy() {
    if (this.observer) {
      this.observer.disconnect();
    } else {
      window.removeEventListener("scroll", this.throttledLoad);
      window.removeEventListener("resize", this.throttledLoad);
      window.removeEventListener("orientationchange", this.throttledLoad);
    }

    this.initialized = false;
  }
}

// 使用示例
const lazyLoader = new LazyLoad({
  selector: '.lazy-image',
  dataSrc: 'data-src',
  threshold: 0.1,
  throttleDelay: 200
});

// 初始化懒加载
lazyLoader.init();

// HTML示例：
// <img class="lazy-image" data-src="real-image.jpg" src="placeholder.jpg" alt="描述">
// <img class="lazy-image" data-src="another-image.jpg" src="placeholder.jpg" alt="描述"></code></pre>
        <button class="copy-btn">复制代码</button>
      </div>

      <div class="code-section" id="setOperations">
        <h2>Set集合操作</h2>
        <div class="code-description">
          使用ES6
          Set数据结构实现集合的交集、并集和差集操作，提供高效的集合运算功能。
        </div>
        <pre class="line-numbers"><code class="language-javascript">/**
 * Set集合操作交集、并集和差集
 */

const a = new Set([1, 2, 3]);
const b = new Set([2, 3, 4]);

// 并集 - 合并两个集合，去除重复元素
const union = new Set([...a, ...b]);
console.log(union); // Set(4) {1, 2, 3, 4}

// 交集 - 获取两个集合的共同元素
const intersection = new Set([...a].filter((x) => b.has(x)));
console.log(intersection); // Set(2) {2, 3}

// 差集 (a - b) - 获取在a中但不在b中的元素
const difference = new Set([...a].filter((x) => !b.has(x)));
console.log(difference); // Set(1) {1}

// 实际应用示例
const users1 = new Set(['张三', '李四', '王五']);
const users2 = new Set(['李四', '王五', '赵六']);

// 所有用户（并集）
const allUsers = new Set([...users1, ...users2]);
console.log('所有用户:', [...allUsers]); // ['张三', '李四', '王五', '赵六']

// 共同用户（交集）
const commonUsers = new Set([...users1].filter(x => users2.has(x)));
console.log('共同用户:', [...commonUsers]); // ['李四', '王五']

// 独有用户（差集）
const uniqueUsers1 = new Set([...users1].filter(x => !users2.has(x)));
console.log('第一组独有用户:', [...uniqueUsers1]); // ['张三']</code></pre>
        <button class="copy-btn">复制代码</button>
      </div>

      <div class="code-section" id="iframeDetection">
        <h2>iframe页面检测</h2>
        <div class="code-description">
          检测当前页面是否在iframe中运行，这在防止页面被恶意嵌套或实现特定功能时很有用。
        </div>
        <pre
          class="line-numbers"
        ><code class="language-javascript">// 判断当前页面是否在 iframe 中
const isInIframe = window.self !== window.top;

if (isInIframe) {
  console.log("当前页面被嵌入在 iframe 中");

  // iframe中的特殊处理逻辑
  document.body.style.backgroundColor = '#f0f0f0';

  // 可以向父页面发送消息
  window.parent.postMessage({
    type: 'iframe_loaded',
    message: '子页面已加载完成'
  }, '*');

} else {
  console.log("当前页面是顶级窗口");

  // 顶级窗口的处理逻辑
  document.title = '主页面 - ' + document.title;
}

// 更完整的检测方法
function detectIframeEnvironment() {
  const detection = {
    isInIframe: window.self !== window.top,
    canAccessParent: false,
    parentOrigin: null,
    frameDepth: 0
  };

  // 检测是否可以访问父页面
  try {
    detection.canAccessParent = !!window.parent.location.href;
    detection.parentOrigin = window.parent.location.origin;
  } catch (e) {
    // 跨域情况下会抛出异常
    detection.canAccessParent = false;
  }

  // 计算嵌套深度
  let currentWindow = window;
  while (currentWindow !== currentWindow.parent) {
    detection.frameDepth++;
    currentWindow = currentWindow.parent;

    // 防止无限循环
    if (detection.frameDepth > 10) break;
  }

  return detection;
}

// 使用示例
const envInfo = detectIframeEnvironment();
console.log('环境信息:', envInfo);

// 根据环境信息执行不同逻辑
if (envInfo.isInIframe) {
  console.log(`页面在${envInfo.frameDepth}层iframe中`);

  if (envInfo.canAccessParent) {
    console.log('可以访问父页面，同源');
  } else {
    console.log('无法访问父页面，可能跨域');
  }
}</code></pre>
        <button class="copy-btn">复制代码</button>
      </div>

      <div class="code-section" id="myReduce">
        <h2>手写reduce函数</h2>
        <div class="code-description">
          自定义实现Array.prototype.reduce方法，理解reduce的工作原理和实现细节。支持初始值参数和错误处理。
        </div>
        <pre class="line-numbers"><code class="language-javascript">/**
 * 手写reduce函数实现
 */
Array.prototype.myReduce = function (callback, initialValue) {
  // 1. 检查回调函数是否为函数
  if (typeof callback !== "function") {
    throw new TypeError(callback + " is not a function");
  }

  const array = this; // 当前数组
  const length = array.length;
  let accumulator;
  let startIndex;

  // 2. 处理初始值
  if (arguments.length >= 2) {
    // 如果提供了初始值，从第 0 个元素开始
    accumulator = initialValue;
    startIndex = 0;
  } else {
    // 如果没有提供初始值，使用第一个元素作为初始值，并从第 1 个元素开始
    if (length === 0) {
      throw new TypeError("Reduce of empty array with no initial value");
    }
    accumulator = array[0];
    startIndex = 1;
  }

  // 3. 遍历数组，执行累加器函数
  for (let i = startIndex; i < length; i++) {
    accumulator = callback(accumulator, array[i], i, array);
  }

  // 4. 返回最终的累积值
  return accumulator;
};

// 使用示例和测试

// 示例1: 数组求和
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.myReduce((acc, curr) => acc + curr, 0);
console.log('数组求和:', sum); // 输出: 15

// 示例2: 数组求积
const product = numbers.myReduce((acc, curr) => acc * curr, 1);
console.log('数组求积:', product); // 输出: 120

</code></pre>
        <button class="copy-btn">复制代码</button>
      </div>
    </div>

    <div class="back-to-top" id="backToTop">↑</div>

    <!-- Prism.js JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-javascript.min.js"></script>

    <script>
      // 初始化代码
      document.addEventListener("DOMContentLoaded", function () {
        console.log("DOM加载完成，开始初始化...");

        // 等待Prism.js加载完成
        function waitForPrism() {
          return new Promise((resolve) => {
            let checkCount = 0;
            const maxChecks = 50; // 最多检查50次（5秒）

            function check() {
              checkCount++;
              console.log(`检查Prism.js状态 (${checkCount}/${maxChecks})...`);

              if (
                typeof Prism !== "undefined" &&
                Prism.plugins &&
                Prism.plugins.lineNumbers
              ) {
                console.log("Prism.js及行号插件已加载");
                resolve(true);
              } else if (checkCount >= maxChecks) {
                console.warn("Prism.js加载超时，使用备用方案");
                resolve(false);
              } else {
                setTimeout(check, 100);
              }
            }

            check();
          });
        }

        // 强制生成行号的函数
        function forceGenerateLineNumbers(pre) {
          try {
            console.log("为代码块生成行号:", pre);

            // 确保有line-numbers类
            if (!pre.classList.contains("line-numbers")) {
              pre.classList.add("line-numbers");
            }

            // 移除现有的行号
            const existingRows = pre.querySelector(".line-numbers-rows");
            if (existingRows) {
              existingRows.remove();
            }

            // 获取代码内容
            const code = pre.querySelector("code");
            if (!code) return;

            const codeContent = code.textContent || code.innerText;
            const lines = codeContent.split("\n");

            // 移除最后的空行
            if (lines[lines.length - 1] === "") {
              lines.pop();
            }

            // 创建行号容器
            const lineNumbersRows = document.createElement("span");
            lineNumbersRows.className = "line-numbers-rows";
            lineNumbersRows.setAttribute("aria-hidden", "true");

            // 生成行号
            for (let i = 0; i < lines.length; i++) {
              const span = document.createElement("span");
              lineNumbersRows.appendChild(span);
            }

            // 插入行号
            pre.appendChild(lineNumbersRows);
            console.log(`成功生成 ${lines.length} 行号`);
          } catch (error) {
            console.error("生成行号时出错:", error);
          }
        }

        // 初始化Prism
        async function initializePrism() {
          try {
            console.log("开始初始化Prism.js...");

            // 等待Prism加载
            const prismLoaded = await waitForPrism();

            // 查找所有代码块
            const preElements = document.querySelectorAll("pre");
            console.log(`找到 ${preElements.length} 个代码块`);

            preElements.forEach((pre, index) => {
              console.log(`处理代码块 ${index + 1}/${preElements.length}`);

              // 确保有正确的类名
              if (!pre.classList.contains("line-numbers")) {
                pre.classList.add("line-numbers");
              }

              const code = pre.querySelector("code");
              if (code && !code.className.includes("language-")) {
                code.className += " language-javascript";
              }
            });

            if (prismLoaded) {
              try {
                // 使用Prism高亮
                console.log("使用Prism.js进行代码高亮...");
                Prism.highlightAll();

                // 触发行号生成
                if (Prism.plugins && Prism.plugins.lineNumbers) {
                  Prism.plugins.lineNumbers.resize();
                }

                // 延迟检查行号是否正确生成
                setTimeout(() => {
                  preElements.forEach((pre, index) => {
                    const lineNumbersRows =
                      pre.querySelector(".line-numbers-rows");
                    if (
                      !lineNumbersRows ||
                      lineNumbersRows.children.length === 0
                    ) {
                      console.log(`代码块 ${index + 1} 缺少行号，强制生成...`);
                      forceGenerateLineNumbers(pre);
                    }
                  });
                }, 500);
              } catch (error) {
                console.error("Prism高亮失败:", error);
                throw error;
              }
            } else {
              throw new Error("Prism.js未能正确加载");
            }
          } catch (error) {
            console.error("Prism初始化失败，使用备用方案:", error);

            // 备用方案：强制为所有代码块生成行号
            const preElements = document.querySelectorAll("pre");
            preElements.forEach((pre, index) => {
              console.log(`备用方案：为代码块 ${index + 1} 生成行号`);
              forceGenerateLineNumbers(pre);
            });
          }
        }

        // 开始初始化
        initializePrism();

        // 窗口大小改变时重新计算行号
        let resizeTimer;
        window.addEventListener("resize", function () {
          clearTimeout(resizeTimer);
          resizeTimer = setTimeout(() => {
            console.log("窗口大小改变，重新计算行号...");
            if (
              typeof Prism !== "undefined" &&
              Prism.plugins &&
              Prism.plugins.lineNumbers
            ) {
              Prism.plugins.lineNumbers.resize();
            }
          }, 300);
        });

        // 导航功能
        const navItems = document.querySelectorAll(".nav-item");
        navItems.forEach((item) => {
          item.addEventListener("click", function () {
            const targetId = this.getAttribute("data-target");
            const targetSection = document.getElementById(targetId);
            if (targetSection) {
              // 更新活跃状态
              navItems.forEach((nav) => nav.classList.remove("active"));
              this.classList.add("active");

              // 滚动到目标位置
              window.scrollTo({
                top: targetSection.offsetTop - 20,
                behavior: "instant",
              });
            }
          });
        });

        // 搜索功能
        const searchInput = document.getElementById("searchInput");
        if (searchInput) {
          searchInput.addEventListener("input", function () {
            const searchTerm = this.value.toLowerCase();
            navItems.forEach((item) => {
              const text = item.textContent.toLowerCase();
              const parent = item.parentElement;
              if (text.includes(searchTerm)) {
                parent.style.display = "block";
              } else {
                parent.style.display = "none";
              }
            });
          });
        }

        // 复制代码功能
        document.addEventListener("click", function (e) {
          if (e.target.classList.contains("copy-btn")) {
            const codeBlock = e.target.nextElementSibling;
            const code = codeBlock.querySelector("code");
            if (code) {
              const text = code.textContent;
              navigator.clipboard
                .writeText(text)
                .then(() => {
                  e.target.textContent = "已复制!";
                  setTimeout(() => {
                    e.target.textContent = "复制代码";
                  }, 2000);
                })
                .catch((err) => {
                  console.error("复制失败:", err);
                });
            }
          }
        });

        // 返回顶部功能
        const backToTop = document.getElementById("backToTop");
        if (backToTop) {
          window.addEventListener("scroll", function () {
            if (window.pageYOffset > 300) {
              backToTop.style.display = "block";
            } else {
              backToTop.style.display = "none";
            }
          });

          backToTop.addEventListener("click", function () {
            window.scrollTo({
              top: 0,
              behavior: "smooth",
            });
          });
        }

        // 移动端侧边栏切换
        const sidebarToggle = document.getElementById("sidebarToggle");
        const sidebar = document.querySelector(".sidebar");
        if (sidebarToggle && sidebar) {
          sidebarToggle.addEventListener("click", function () {
            sidebar.classList.toggle("show");
          });

          // 点击内容区域关闭侧边栏
          document.addEventListener("click", function (e) {
            if (
              !sidebar.contains(e.target) &&
              !sidebarToggle.contains(e.target)
            ) {
              sidebar.classList.remove("show");
            }
          });
        }

        console.log("页面初始化完成！");
      });
    </script>
  </body>
</html>
